<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PRMLS</title>
    <link href="/2025/09/16/PRMLS/"/>
    <url>/2025/09/16/PRMLS/</url>
    
    <content type="html"><![CDATA[<h1 id="PATTERN-RECOGNITION-AND-MACHINE-LEARNING-SYSTEMS"><a href="#PATTERN-RECOGNITION-AND-MACHINE-LEARNING-SYSTEMS" class="headerlink" title="PATTERN RECOGNITION AND MACHINE LEARNING SYSTEMS"></a>PATTERN RECOGNITION AND MACHINE LEARNING SYSTEMS</h1><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><h3 id="2-1-Neural-Network-Models-and-Designs"><a href="#2-1-Neural-Network-Models-and-Designs" class="headerlink" title="2.1 Neural Network Models and Designs"></a>2.1 <strong>Neural Network Models and</strong> Designs</h3><h4 id="2-1-1-径向基函数-Radial-Basis-Function-Networks"><a href="#2-1-1-径向基函数-Radial-Basis-Function-Networks" class="headerlink" title="2.1.1 径向基函数 Radial Basis Function Networks"></a>2.1.1 径向基函数 Radial Basis Function Networks</h4><h4 id="（1）Architecture"><a href="#（1）Architecture" class="headerlink" title="（1）Architecture"></a>（1）<strong>Architecture</strong></h4><ol><li><p>输入层与隐藏层完全连接</p></li><li><p>隐藏层与输出层完全连接</p></li></ol><p><strong>node</strong></p><ol><li>输入层的每个节点：接受输入变量的值</li><li>每个隐藏节点：提供变量的径向基函数</li><li>输出层的每个节点：对应于输入变量的非线形函数</li></ol><p><strong>weight</strong></p><ol><li>和第 i 个内部节点之间的连接上有一个可调权重向量 W，表示径向基函数的中心（通过无监督学习</li><li>连接内部节点和输出节点的可调权重（通过监督学习）</li></ol><h4 id="（2）Active"><a href="#（2）Active" class="headerlink" title="（2）Active"></a>（2）Active</h4><p>第 j 个基函数（核）对位于其核中心 cj 相同径向距离内的所有输入给出相同的激活值。核节点通常使用高斯激活基函数，该函数取决于输入向量 x 和节点中心向量 ci 之间的距离。在这种情况下，隐藏层第 i 个节点的激活值计算如下，其中 σi 是平滑参数（也称为归一化因子）：</p><img src="/Users/lijiajun/Library/Application Support/typora-user-images/image-20250916100540368.png" alt="image-20250916100540368" style="zoom:50%;" /><h4 id="（3）Training"><a href="#（3）Training" class="headerlink" title="（3）Training"></a>（3）Training</h4><ul><li>two parameters (c i and σi ) to be found for each kernel node i</li><li>a full weight set for output nodes</li></ul><p><strong>two stage training</strong></p><ul><li><p>寻找隐藏层节点的中心和平滑参数值（无监督学习）</p><ul><li><p>要找到每个 RBF 节点的“中心” (c_i) 和“半径&#x2F;宽度” (\sigma_i)。</p></li><li><p>这一步通常通过 <strong>聚类算法</strong> 来完成，比如 <strong>C-Means clustering</strong>（常用的是 Hard K-Means）。</p></li><li><p>简单理解：先把训练样本分成若干簇，每个簇的中心作为一个 RBF 节点的中心，簇的分布决定宽度。</p></li><li><p><strong>Learning for Kernel Centre (求核中心)</strong></p><ul><li><p>如果样本数很小，可以直接把每个样本作为一个中心（自增长网络的思想）。</p></li><li><p>如果样本数很大，先用 K-Means 聚类，把聚类中心作为 RBF 的核中心。</p></li><li><p>数学表达式：<br>$$<br>c_j &#x3D; \frac{1}{m_j} \sum_{x_i \in \Theta_j} x_i<br>$$</p></li><li><p>意思是：第 j 个簇的中心 &#x3D; 簇中所有样本的平均值。</p></li></ul></li><li><p><strong>Learning for Smoothing Parameter (求平滑参数 σ)</strong></p><ul><li><p>\sigma_j 决定 RBF 的“宽度”，控制函数对输入的响应范围。</p></li><li><p>通常由簇内样本到中心的平均距离来决定。</p></li><li><p>数学表达式：</p></li><li><p>$$<br>\sigma_j^2 &#x3D; \frac{1}{m_j} \sum_{x \in \Theta_j} (x - c_j)^T(x - c_j)<br>$$</p></li><li><p>意思是：\sigma_j^2 就是簇内样本与中心的平均平方距离（类似方差）。</p></li></ul></li></ul></li><li><p>寻找输出节点的权重（监督学习）</p><ul><li><p>在隐藏层节点确定之后，每个输入样本就能映射成一组 RBF 激活值。</p></li><li><p>这时，输出层就是一个 <strong>线性模型</strong>：输出 &#x3D; 激活值 × 权重。</p></li><li><p>可以用 <strong>监督学习方法</strong>（如最小二乘法）来训练这些权重，使输出尽量匹配目标值。</p></li><li><p><strong>权重更新规则</strong><br>$$<br>W_{ji}(t+1) &#x3D; W_{ji}(t) + \Delta W_{ji}<br>$$</p><p>意思：在第 t 次迭代后，权重会更新一个增量。</p></li><li><p><strong>权重增量计算</strong><br>$$<br>\Delta W_{ji} &#x3D; \eta \delta_j O_i<br>$$</p><ul><li>\eta：学习率</li><li>O_i：隐藏层第 i 个节点的输出（RBF 激活值）</li><li>\delta_j：输出层第 j 个节点的误差</li></ul></li><li><p><strong>误差计算</strong></p><p>\delta_j &#x3D; T_j - O_j</p><ul><li>T_j：目标输出（训练样本的标签）</li><li>O_j：当前网络在输出层 j 的预测值</li></ul></li><li><p><strong>训练过程</strong></p><ul><li>不断迭代更新权重</li><li>直到 <strong>收敛</strong>（即输出误差足够小或达到最大迭代次数）</li></ul></li><li><p>示例</p><ul><li><p>输出层权重：</p><p>W_{o1} &#x3D; W_{o2} &#x3D; W_{o3} &#x3D; W_{o4} &#x3D; 0.5</p></li><li><p>学习率：\eta &#x3D; 0.5</p></li></ul><table><thead><tr><th><strong>样本</strong></th><th><strong>输入 (In1, In2)</strong></th><th><strong>目标输出 (T)</strong></th><th><strong>激活的中心</strong></th></tr></thead><tbody><tr><td>P1</td><td>(0,0)</td><td>0</td><td>C1</td></tr><tr><td>P2</td><td>(0,1)</td><td>1</td><td>C2</td></tr><tr><td>P3</td><td>(1,0)</td><td>1</td><td>C3</td></tr><tr><td>P4</td><td>(1,1)</td><td>0</td><td>C4</td></tr></tbody></table><p><strong>样本 P1: (0,0), T&#x3D;0</strong></p><ul><li><p>激活 C1，当前输出 Out&#x3D;0.5</p></li><li><p>误差：T - Out &#x3D; 0 - 0.5 &#x3D; -0.5</p></li><li><p>更新：</p><p>W_{o1}(t+1) &#x3D; 0.5 + 0.5 \times (-0.5) \times 1 &#x3D; 0.25</p></li></ul><p>结果：W_{o1}&#x3D;0.25, W_{o2}&#x3D;0.5, W_{o3}&#x3D;0.5, W_{o4}&#x3D;0.5</p><p><strong>样本 P2: (0,1), T&#x3D;1</strong></p><ul><li><p>激活 C2，当前输出 Out&#x3D;0.5</p></li><li><p>误差：1 - 0.5 &#x3D; 0.5</p></li><li><p>更新：</p><p>W_{o2}(t+1) &#x3D; 0.5 + 0.5 \times (0.5) \times 1 &#x3D; 0.75</p></li></ul><p>结果：W_{o1}&#x3D;0.25, W_{o2}&#x3D;0.75, W_{o3}&#x3D;0.5, W_{o4}&#x3D;0.5</p><p><strong>样本 P3: (1,0), T&#x3D;1</strong></p><ul><li><p>激活 C3，当前输出 Out&#x3D;0.5</p></li><li><p>误差：1 - 0.5 &#x3D; 0.5</p></li><li><p>更新：</p><p>W_{o3}(t+1) &#x3D; 0.5 + 0.5 \times (0.5) \times 1 &#x3D; 0.75</p></li></ul><p>结果：W_{o1}&#x3D;0.25, W_{o2}&#x3D;0.75, W_{o3}&#x3D;0.75, W_{o4}&#x3D;0.5</p><p><strong>样本 P4: (1,1), T&#x3D;0</strong></p><ul><li><p>激活 C4，当前输出 Out&#x3D;0.5</p></li><li><p>误差：0 - 0.5 &#x3D; -0.5</p></li><li><p>更新：</p><p>W_{o4}(t+1) &#x3D; 0.5 + 0.5 \times (-0.5) \times 1 &#x3D; 0.25</p></li></ul><p>结果：W_{o1}&#x3D;0.25, W_{o2}&#x3D;0.75, W_{o3}&#x3D;0.75, W_{o4}&#x3D;0.25</p><p><strong>最终权重表</strong></p><table><thead><tr><th><strong>权重</strong></th><th><strong>初始值</strong></th><th><strong>P1后</strong></th><th><strong>P2后</strong></th><th><strong>P3后</strong></th><th><strong>P4后</strong></th></tr></thead><tbody><tr><td>W_o1</td><td>0.5</td><td>0.25</td><td>0.25</td><td>0.25</td><td>0.25</td></tr><tr><td>W_o2</td><td>0.5</td><td>0.5</td><td>0.75</td><td>0.75</td><td>0.75</td></tr><tr><td>W_o3</td><td>0.5</td><td>0.5</td><td>0.5</td><td>0.75</td><td>0.75</td></tr><tr><td>W_o4</td><td>0.5</td><td>0.5</td><td>0.5</td><td>0.5</td><td>0.25</td></tr></tbody></table><ul><li>对应 <strong>输出应为 0 的模式 (P1, P4)</strong> → 权重下降 (0.25)</li><li>对应 <strong>输出应为 1 的模式 (P2, P3)</strong> → 权重上升 (0.75)</li><li>最终网络能正确区分 XOR：<ul><li>(0,0) → 0</li><li>(0,1) → 1</li><li>(1,0) → 1</li><li>(1,1) → 0</li></ul></li></ul><p>RBF 学习过程中，<strong>每个训练样本只更新一个对应的核权重</strong>，经过几次迭代后，权重分化为 {低 (0.25), 高 (0.75)}，成功学会 XOR 逻辑。</p></li></ul></li></ul><h4 id="2-1-2-General-Regression-Neural-Networks-GRNN"><a href="#2-1-2-General-Regression-Neural-Networks-GRNN" class="headerlink" title="2.1.2 General Regression Neural Networks (GRNN)"></a>2.1.2 General Regression Neural Networks (GRNN)</h4><h4 id="（1）Architecture-1"><a href="#（1）Architecture-1" class="headerlink" title="（1）Architecture"></a>（1）<strong>Architecture</strong></h4><ul><li>an input-layer</li><li>three computational layers: pattern, summation, output</li></ul><p><strong>Nodes &amp; Connections</strong></p><ul><li>输入层：将输入模式传递到模式层 (pattern layer)，通过全连接权重。</li><li>模式层 (Pattern layer)：每个模式节点计算输入向量与权值向量的距离。</li><li>求和层 (Summation layer)：分为 <strong>A 型节点</strong>和 <strong>B 型节点</strong>，对模式层输出做加权求和。</li><li>输出层：对 A、B 两类求和节点的结果做比值运算，得到回归输出。</li></ul><p><strong>Activation</strong></p><ul><li><p>模式层计算距离：</p></li><li><p>$$<br>D_i^2 &#x3D; (x - w_i)^T (x - w_i)<br>$$</p></li><li><p>模式层激活函数（常用高斯核）：</p></li><li><p>$$<br>O_i &#x3D; \exp \left(-\frac{D_i^2}{2\sigma^2}\right)<br>$$</p></li><li><p>输出层回归公式：</p></li><li><p>$$<br>\hat{z} &#x3D; \frac{\sum_{i&#x3D;1}^P A_i \exp(-D_i^2&#x2F;2\sigma^2)}{\sum_{i&#x3D;1}^P B_i \exp(-D_i^2&#x2F;2\sigma^2)}<br>$$</p></li><li><ul><li>P：模式节点数</li><li>\sigma：平滑参数</li></ul></li></ul><p><strong>Learning of GRNN</strong></p><ul><li><p>模式层：每个训练样本对应一个新节点，权值设为样本或簇中心。</p></li><li><p>求和层：每次看到属于簇 i 的样本 z_j，更新：</p><p>A_i(k) &#x3D; A_i(k-1) + z_j, \quad B_i(k) &#x3D; B_i(k-1) + 1</p><p>初始 A_i(0)&#x3D;0, B_i(0)&#x3D;0。</p></li><li><p>平滑常数 \sigma：实验确定，控制决策边界。</p></li></ul><p><strong>Mapping Surface &amp; σ)</strong></p><ul><li>小 \sigma：表面尖锐，拟合点附近很好，但泛化差。</li><li>大 \sigma：表面平滑，泛化更好，但过度平滑可能欠拟合。</li><li><strong>好泛化效果需要在两者之间权衡</strong>。</li></ul><p><strong>Summary</strong></p><p><strong>特点</strong></p><ul><li>基于记忆 (memory-based)，不丢弃训练样本。</li><li>一次学习算法 (one-pass learning)，无需反复迭代。</li><li>自增长网络：每个新样本生成一个新模式节点。</li></ul><p><strong>应用</strong></p><ul><li>适合 <strong>预测、控制、建模</strong>等任务，尤其在训练数据分布未知时。</li><li>优点：<ul><li>随着样本的增加，估计值会收敛到真实的回归曲面。</li><li>广义相对论神经网络 (GRNN) 能够处理稀疏数据和实时环境，因为回归曲面在任何地方都能即时定义，并且网络能够实现从一个观测值到另一个观测值的平滑过渡。</li><li>训练 GRNN 快速而简单，只需对训练集进行一次遍历。网络在提供单个训练样本后即可开始执行回归。</li></ul></li><li>缺点：<ul><li>由于训练集中的每个模式都会添加一个模式单元，因此网络可能会变得非常庞大（除非使用聚类来确定原型中心）。</li><li>网络的计算负载相对较重。</li></ul></li></ul><p>GRNN 是一种基于 RBF 的记忆型神经网络，通过模式层的高斯核映射 + 求和层比值计算，实现快速的一次性学习，特别适合回归和预测问题。</p><h4 id="2-1-3-Self-Organizing-Map-SOM-Kohonen-Network-学习笔记"><a href="#2-1-3-Self-Organizing-Map-SOM-Kohonen-Network-学习笔记" class="headerlink" title="2.1.3 Self-Organizing Map (SOM, Kohonen Network) 学习笔记"></a>2.1.3 Self-Organizing Map (SOM, Kohonen Network) 学习笔记</h4><p><strong>1. 基本概念</strong></p><ul><li><strong>SOM 是一种用于聚类与降维的神经网络</strong></li><li>特点：<strong>无监督学习</strong>，通过竞争学习 (winner-takes-all) 将高维输入映射到低维空间 (通常是 1D 或 2D 网格)</li><li>网络结构：<ul><li><strong>输入层</strong>：接收输入向量</li><li>**输出层 (Cluster Layer)**：一组神经元，通常排列成一维或二维网格，每个神经元代表一个“簇”</li></ul></li></ul><p><strong>2. 竞争学习机制 (Competitive Learning)</strong></p><ul><li><p>输入模式与所有输出神经元的权重比较 → 找到距离最近的神经元 (Best Matching Unit, BMU)</p></li><li><p>胜者神经元及其邻居调整权重，向输入向量靠近</p></li><li><p>数学条件：</p></li><li><p>$$<br>|| w_i - x || \leq || w_k - x ||, \quad \forall k \neq i<br>$$</p></li><li><p>即选择与输入最接近的神经元作为赢家</p></li></ul><p><strong>3. Kohonen 学习规则</strong></p><ul><li><p>更新权重：</p></li><li><p>$$<br>w_i(t+1) &#x3D; w_i(t) + \eta(t) \cdot h_{ci}(t) \cdot (x(t) - w_i(t))<br>$$</p><ul><li>\eta(t)：学习率，随时间递减</li><li>h_{ci}(t)：邻域函数，控制 BMU 周围神经元的更新幅度</li></ul></li><li><p>胜者更新最大，邻居也会部分更新，形成空间拓扑映射</p></li></ul><p><strong>4. SOM 的结构形式</strong></p><ul><li><strong>一维 SOM</strong>：输出层为一条直线，神经元顺序排列</li><li><strong>二维 SOM</strong>：输出层为一个网格 (lattice)，适合可视化高维数据</li><li>拓扑结构保证了相似输入在映射空间中也会相邻</li></ul><p><strong>5. 特点与应用</strong></p><p><strong>特点</strong></p><ul><li>无监督聚类</li><li>保持拓扑关系（相似输入 → 相邻输出）</li><li>降维可视化（高维数据映射到 2D 网格）</li></ul><p><strong>应用</strong></p><ul><li><p>数据聚类与模式识别</p></li><li><p>高维数据可视化 (如文本、基因数据)</p></li><li><p>图像分析、语音识别</p></li><li><p>客户细分、市场分析</p></li><li><p>SOM 通过 <strong>竞争学习 + 邻域更新</strong>，能把复杂高维数据映射到低维拓扑结构中。</p></li><li><p><strong>Winner-takes-all</strong> 确保最佳匹配单元学习输入特征，邻居共享更新，形成连续的“特征地图”。</p></li><li><p>它既能做 <strong>聚类</strong>，又能做 <strong>可视化与降维</strong>。</p></li></ul><p><strong>6. Kohonen 学习算法步骤</strong></p><ol><li><p><strong>初始化权重</strong>：所有权重向量 w_r 用均匀分布随机初始化 (0,1)。</p></li><li><p><strong>输入信号</strong>：将输入向量 x 输入网络。</p></li><li><p>**选择获胜单元 (BMU)**：找到与输入最接近的权重向量</p></li><li><p>$$<br>||x - w_r|| &#x3D; \min_r ||x - w_r||<br>$$</p></li><li><p><strong>更新权重</strong></p><ul><li><p>$$<br>w_r^{new} &#x3D; w_r^{old} + \alpha \cdot h_{rr’} \cdot (x - w_r^{old})<br>$$</p></li><li><p>邻域神经元也更新，幅度随距离衰减。</p></li><li><p>其中：\alpha 为学习率，h_{rr’} 为邻域函数。</p></li></ul></li><li><p><strong>重复步骤 2–4</strong>，直到网络权重收敛。</p></li><li><p><strong>逐步减小学习率与邻域范围</strong>，提升收敛稳定性。</p></li></ol><p><strong>7. 邻域函数 (Neighbourhood Function)</strong></p><ul><li>决定 BMU 周围哪些神经元会被更新，以及更新幅度。</li><li>常见形式：<ul><li><strong>方形邻域</strong></li><li><strong>六边形邻域</strong></li><li>**高斯函数 (Gaussian)**：平滑衰减效果更自然。</li></ul></li></ul><p><strong>8. SOM 映射过程</strong></p><ul><li>输入模式空间被映射到神经网络格子 (lattice)。</li><li>BMU 及其邻居的权重向输入靠近：<ul><li><strong>越靠近 BMU → 更新越大</strong></li><li><strong>距离远的 → 更新越小</strong></li></ul></li><li>结果：输入数据的拓扑结构在 SOM 网格上得到保留。</li></ul><p><strong>9. SOM 仿真例子</strong></p><ul><li>将二维输入 (x_1, x_2) 映射到 SOM 网格<ul><li>(a) 输入数据：在 [0,1] \times [0,1] 范围内均匀分布</li><li>(b) 初始权重：随机分布</li><li>(c) 迭代 30 次后，权重逐渐向数据分布靠近</li><li>(d) 迭代 1000 次后，SOM 权重形成平滑网格，保持拓扑关系</li></ul></li></ul><p><strong>10. SOM 的优点</strong></p><ul><li>不需要事先指定簇数（克服了 C-Means 的局限）。</li><li>能同时进行 <strong>聚类</strong> 和 <strong>降维</strong>。</li><li>提供了一种 <strong>数据压缩</strong> 方法。</li><li>对有标签数据，还能作为分类器。</li><li>最重要的是：提供 <strong>数据可视化</strong> 功能，可直观展现高维数据结构。</li></ul>]]></content>
    
    
    <categories>
      
      <category>class_note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ISS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/09/16/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/"/>
    <url>/2025/09/16/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="笔试真题"><a href="#笔试真题" class="headerlink" title="笔试真题"></a>笔试真题</h2><h3 id="3-15-阿里笔试"><a href="#3-15-阿里笔试" class="headerlink" title="3.15 阿里笔试"></a>3.15 阿里笔试</h3><h2 id="笔试模拟"><a href="#笔试模拟" class="headerlink" title="笔试模拟"></a>笔试模拟</h2><h3 id="3-15-OPPO提前批笔试"><a href="#3-15-OPPO提前批笔试" class="headerlink" title="3.15 OPPO提前批笔试"></a>3.15 OPPO提前批笔试</h3><ol><li>构造二阶行列式</li></ol><h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>小欧希望你构造一个二阶行列式，满足行列式中每个数均为不超过 20 的正整数，且行列式的值恰好等于x。你能帮帮她吗?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.Map.Entry;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> in.nextInt();<br>        <span class="hljs-keyword">if</span>(target &gt;= <span class="hljs-number">400</span> || target &lt;=-<span class="hljs-number">400</span>)&#123;<br>            System.out.println(-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; <span class="hljs-number">20</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;j &lt; <span class="hljs-number">20</span>;j++)&#123;<br>                map.put(i*j, i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(Entry&lt;Integer, Integer&gt; entry: map.entrySet())&#123;<br>            <span class="hljs-keyword">if</span>(map.containsKey(entry.getKey()-target))&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> entry.getKey();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> entry.getValue();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> A / a;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> entry.getKey()-target;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> map.get(entry.getKey()-target);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> B/b;<br>                System.out.println(a+ <span class="hljs-string">&quot; &quot;</span>+ b);<br>                System.out.println(c+ <span class="hljs-string">&quot; &quot;</span>+ d);<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>        &#125;<br><br>        System.out.println(-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>挑战boss</li></ol><h6 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h6><p>小欧正在一个回合制格斗游戏中挑战一个boss。已知游戏的0&#x2F;3机制如下: </p><p>每回合小欧先手攻击boss，然后boss攻击小欧，此时1回合结束。</p><p>小欧有时可以闪避boss的攻击，当闪避成功时这回合将不受boss的伤害。 小欧攻击boss时可以攒“连击点”，她攻击造成的伤害为a+kb，其中a为基础攻击力，b为基础连击伤害，k为连击次数。小欧每次攻击后会让连击次数加1，但当小欧受到伤害后会重置连击次数为0。 </p><p>小欧想知道，她最终共对boss造成了多少伤害?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">roundCnt</span> <span class="hljs-operator">=</span> in.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> in.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> in.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 吃掉后面的空格</span><br>        in.nextLine();<br>        <span class="hljs-type">char</span>[] rounds = in.nextLine().toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; roundCnt;i++)&#123;<br>            ans += a+k*b;<br>            <span class="hljs-keyword">if</span>(rounds[i] == <span class="hljs-string">&#x27;o&#x27;</span>)&#123;<br>                k++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                k = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br><br>        System.out.println(ans);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>国际象棋</strong></p><h6 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h6><p>小欧获得了国际象棋中“象”和”马”的能力，她在一个无穷大的平面直角坐标系中，每一步可以效仿国际象棋中 的”象”和”马”跳一步。 </p><p>如下图，小红初始坐标为(x，y)时，只跳一步时可以跳到以下 </p><p>1.(x+k，y+k)，k是任意整数。 </p><p>2.(x+k,y-k)，k是任意整数。 </p><p>3.(x+a,y+b).其中|a|+|b|&#x3D;3且1&lt;&#x3D;a,b&lt;&#x3D;2. 小欧想知道，自己初始坐标为x1，y1，他跳到x2,y2最少需要跳多少步？共有t次询问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] horse = &#123;<br>        &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">1</span>,-<span class="hljs-number">2</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">2</span>&#125;, <br>        &#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>&#125;,&#123;-<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;,&#123;-<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>&#125;<br>    &#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">moveCnt</span> <span class="hljs-operator">=</span> in.nextInt();<br>        <span class="hljs-keyword">while</span>(moveCnt-- &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> in.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y1</span> <span class="hljs-operator">=</span> in.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x2</span> <span class="hljs-operator">=</span> in.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y2</span> <span class="hljs-operator">=</span> in.nextInt();<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">move</span> <span class="hljs-operator">=</span> calMove(x1,y1,x2,y2);<br>            System.out.println(move);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calMove</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span>&#123;<br>        <span class="hljs-keyword">if</span>(x1 == x2 &amp;&amp; y1 == y2)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">dx</span> <span class="hljs-operator">=</span> Math.abs(x1-x2);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">dy</span> <span class="hljs-operator">=</span> Math.abs(y1-y2);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">delta</span> <span class="hljs-operator">=</span> Math.abs(dx-dy);<br><br>        <span class="hljs-keyword">if</span>(dx == dy || (dx == <span class="hljs-number">1</span> &amp;&amp; dy == <span class="hljs-number">2</span>) || (dx == <span class="hljs-number">2</span> &amp;&amp; dy == <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(delta % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">8</span>;j++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> x1 + horse[j][<span class="hljs-number">0</span>],b = y1 + horse[j][<span class="hljs-number">1</span>];<br>            res = Math.min(res,calMove(a,b,x2,y2) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2025/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2025/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络（面试题）"><a href="#计算机网络（面试题）" class="headerlink" title="计算机网络（面试题）"></a>计算机网络（面试题）</h1><h3 id="1-介绍TCP-IP模型和OSI模型的区别"><a href="#1-介绍TCP-IP模型和OSI模型的区别" class="headerlink" title="1. 介绍TCP&#x2F;IP模型和OSI模型的区别"></a>1. 介绍TCP&#x2F;IP模型和OSI模型的区别</h3><p>首先从网络模型的结构来讲，TCP&#x2F;IP模型分为四层：应用层，传输层，网络层，网络接口层；OSI模型分为七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p>TCP&#x2F;IP模型可以简单的与OSI模型进行对应。OSI的物理层和数据链路层与TCP的网络接口层对应；OSI的上三层与TCP的应用层对应。</p><p>虽然OSI参考模型描写的更为完善，但是由于其实现的复杂性，现在更为广泛使用的模型是TCP的四层模型。</p><ol><li>其中应用层主要用于两个设备上的应用程序进行数据交换，应用层的数据单位为报文。包括HTTP协议、SMTP协议、POP3等。</li><li>传输层主要用于两个设备进程之间的通信提供数据传输服务。主要包括TCP 面向连接的可靠数据传输服务和UDP无连接的尽最大努力的数据传输服务。</li><li>网络层的核心功能是<strong>转发和路由</strong>。网络层主要包括IP协议。数据为IP数据报。<strong>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</strong>网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做 <strong>网际层</strong> 或 <strong>IP 层</strong>。</li><li>网络接口层可以看成是数据链路层和物理层的合体。链路层将IP数据报组装成帧，每一帧包括必要的控制信息。物理层实现相邻计算机节点之间的比特流透明传输。</li></ol><h3 id="2-从输入-URL-到页面展示到底发生了什么？"><a href="#2-从输入-URL-到页面展示到底发生了什么？" class="headerlink" title="2. 从输入 URL 到页面展示到底发生了什么？"></a>2. 从输入 URL 到页面展示到底发生了什么？</h3><ol><li>在浏览器中输入指定网页的 URL。</li><li>浏览器通过 DNS 协议，层层解析域名并获取域名对应的 IP 地址。</li><li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。</li><li>基于HTTP&#x2F;HTTPs协议，浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li><li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li><li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL，再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li><li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li></ol><h3 id="3-HTTP请求报文和响应报文是怎样的，有哪些常见的字段？"><a href="#3-HTTP请求报文和响应报文是怎样的，有哪些常见的字段？" class="headerlink" title="3. HTTP请求报文和响应报文是怎样的，有哪些常见的字段？"></a>3. HTTP请求报文和响应报文是怎样的，有哪些常见的字段？</h3><p>TTP报文分为请求报文和响应报文。</p><p>（1） 请求报文 请求报文主要由请求行、请求头、空行、请求体构成。 请求行包括如下字段：</p><ul><li>方法（Method）：指定要执行的操作，如 GET、POST、PUT、DELETE 等。</li><li>资源路径（Resource Path）：请求的资源的URI（统一资源标识符）。</li><li>HTTP版本（HTTP Version）：使用的HTTP协议版本，如 HTTP&#x2F;1.1 或 HTTP&#x2F;2.0。</li></ul><p>请求头的字段较多，常使用的包含以下几个：</p><ul><li>Host：请求的服务器的域名。</li><li>Accept：客户端能够处理的媒体类型。</li><li>Accept-Encoding：客户端能够解码的内容编码。</li><li>Authorization：用于认证的凭证信息，比如token数据。</li><li>Content-Length：请求体的长度。</li><li>Content-Type：请求体的媒体类型。</li><li>Cookie：存储在客户端的cookie数据。</li><li>If-None-Match：资源的ETag值，用于缓存控制。</li><li>Connection：管理连接的选项，如 keep-alive。</li></ul><p>空行是请求头部和请求主体之间的空行，用于分隔请求头部和请求主体。而请求体通常用于 POST 和 PUT 请求，包含发送给服务器的数据。</p><p>（2) 响应报文</p><p>HTTP响应报文是服务器向客户端返回的数据格式，用于传达服务器对客户端请求的处理结果以及相关的数据。一个标准的HTTP响应报文通常包含状态行、响应头、空行、响应体。</p><p>状态行包含HTTP版本、状态码和状态消息。例如：<code>HTTP/1.1 200 OK</code></p><p>响应头部也是以键值对的形式提供的额外信息，类似于请求头部，用于告知客户端有关响应的详细信息。一些常见的响应头部字段包括：</p><ul><li>Content-Type：指定响应主体的媒体类型。</li><li>Content-Length：指定响应主体的长度（字节数）。</li><li>Server：指定服务器的信息。</li><li><strong>Expires</strong>: 响应的过期时间，之后内容被认为是过时的。</li><li><strong>ETag</strong>: 响应体的实体标签，用于缓存和条件请求。</li><li><strong>Last-Modified</strong>： 资源最后被修改的日期和时间。</li><li>Location：在重定向时指定新的资源位置。</li><li>Set-Cookie：在响应中设置Cookie。</li><li>Access-Control-Allow-Origin: 跨源资源共享（CORS）策略，指示哪些域可以访问资源。</li></ul><p>空行（Empty Line）在响应头和响应体之间，表示响应头的结束。而响应体是服务端实际传输的数据，可以是文本、HTML页面、图片、视频等，也可能为空。</p><h3 id="4-HTTP有哪些请求方式？"><a href="#4-HTTP有哪些请求方式？" class="headerlink" title="4. HTTP有哪些请求方式？"></a>4. HTTP有哪些请求方式？</h3><ul><li><p><strong>方法定义</strong>: 能够清晰地定义每个请求方法的基本用途，知道哪些方法可能会改变服务器状态，哪些不会，并能够根据场景选择合适的HTTP方法。</p></li><li><p><strong>安全性</strong>: 了解每种方法在安全性方面的考虑，特别是GET和POST方法的区别。</p></li><li><p><strong>幂等性</strong>: 理解幂等性的概念，并能识别哪些HTTP方法是幂等的（如GET、PUT、DELETE）。</p></li><li><p>GET：<code>GET</code> 方法请求一个指定资源的表示形式，使用 <code>GET</code> 的请求应该只被用于获取数据。</p></li><li><p>HEAD：<code>HEAD</code> 方法请求一个与 <code>GET</code> 请求的响应相同的响应，但没有响应体。</p></li><li><p>POST：<code>POST</code> 方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用。1）可以创建新的资源或提交数据到服务器进行处理。2）客户端可以只发送部分资源内容。3）如果请求成功，服务器会返回一个表示新资源的 URI。4）POST 请求不具有幂等性。</p></li><li><p>PUT：<code>PUT</code> 方法用有效载荷请求替换目标资源的所有当前表示。1）可以更新整个资源。2）客户端需要发送完整的资源内容。3）如果服务器上不存在该资源，则会创建一个新的资源。4）PUT 请求具有幂等性，即执行多次 PUT 请求的结果应该相同。</p></li><li><p>DELETE：<code>DELETE</code> 方法删除指定的资源。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/CONNECT"><code>CONNECT</code></a>:<code>CONNECT</code> 方法建立一个到由目标资源标识的服务器的隧道。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS"><code>OPTIONS</code></a>:<code>OPTIONS</code> 方法用于描述目标资源的通信选项。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/TRACE"><code>TRACE</code></a>:<code>TRACE</code> 方法沿着到目标资源的路径执行一个消息环回测试。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/PATCH"><code>PATCH</code></a>:<code>PATCH</code> 方法用于对资源应用部分修改。</p></li></ul><h3 id="5-GET请求和POST请求的区别"><a href="#5-GET请求和POST请求的区别" class="headerlink" title="5. GET请求和POST请求的区别"></a>5. GET请求和POST请求的区别</h3><ul><li>GET语义是从服务器获取指定的资源，请求参数一般写在url中，字符限制为ASCII。get在只进行请求指定资源时是安全的、幂等的、可被缓存的。浏览器中的GET请求可以被保存为书签。</li><li>POST是根据请求报文body对指定资源做出处理。会修改服务器上的资源，所以是不安全的，多次提交就会创建多个资源，所以不是幂等的。</li></ul><h3 id="6-HTTP中常见的状态码有哪些"><a href="#6-HTTP中常见的状态码有哪些" class="headerlink" title="6. HTTP中常见的状态码有哪些"></a>6. HTTP中常见的状态码有哪些</h3><p>1XX：协议处理的中间状态</p><p>2XX：成功报文已被正确处理</p><ul><li>200 OK：标识一切正常，如果不是HEAD请求，会返回body数据</li><li>204 NO Content：响应头没有body数据</li><li>206 Partial Content：应用于 HTTP 分块下载或断点续传</li></ul><p>3XX：资源重定向</p><ul><li>301 永久重定向</li><li>302 临时重定向</li><li>304 缓存重定向</li></ul><p>4XX：报文有误</p><ul><li>400 Bad Request 笼统错误</li><li>403 Forbidden 服务器禁止访问资源</li><li>404 Not Found 资源不存在</li></ul><p>5XX：服务器内部错误</p><ul><li>500 笼统错误</li><li>501 功能未支持</li><li>502 网关错误</li><li>503 Service Unavailable</li></ul><h3 id="7-什么是强缓存和协商缓存"><a href="#7-什么是强缓存和协商缓存" class="headerlink" title="7. 什么是强缓存和协商缓存"></a>7. 什么是强缓存和协商缓存</h3><p><img src="C:\Users\MasterLi\Documents\GitHub\hexo_myblog\source_posts\计算机网络\image-20250223140337972.png" alt="image-20250223140337972"></p><ul><li>强制缓存：强制缓存是浏览器判断能否是由从本地缓存读取，是否使用缓存的主动性在于浏览器这边。<ul><li>Cache-Control 和 Expires两个头部字段实现</li><li>Cache-Control的优先级高于Expire<ul><li>第一次请求服务器资源时，服务器返回资源的同时在响应头部加上Cache-Control，在其中设置过期时间大小，再次访问时根据请求时间与过期时间来计算资源是否过期</li><li>再次收到请求时会更新Cache-Control的值</li></ul></li></ul></li><li>协商缓存：在强制缓存失效时，可以根据响应头中是否含有协商缓存对应的字段来使用协商缓存。通过服务端来告知本地的缓存是否可以使用的方式叫做协商缓存。<ul><li>方法一：基于请求头部中的If-Modified-Since和响应头部中的Last-Modified字段实现。基于时间实现。<ul><li>响应头中的last-Modified标识响应资源的最后修改时间</li><li>请求头中的If-Modified-Since，当强制缓存发现资源过期时发现响应头中具有Last-Modified声明，则再次发起请求的时候带上Last-Modified的时间，服务器收到请求后将If-Modified-since与Last-Modified进行对比，如果修改时间较新，说明资源被修改，返回最新资源Http 200 OK，否则响应Http 304</li></ul></li><li>方法二：基于请求头部中的If-None-Match字段与响应头部中的Etag。基于唯一标识符的方法。<ul><li>响应头部中Etag是唯一标识响应资源；</li><li>请求头部中的If-None-Match：当资源过期时，浏览器发现响应头有Etag，则再次向服务器发起请求时会将If-None-Match的值设置为Etag的值。服务器收到后进行对比，如果资源变化没有返回304，如果资源变化了返回200</li></ul></li><li>第二种可以更准确的判断文件内容是否被修改，避免由于时间篡改的不可靠问题</li><li>Etag优先级高于LastModified<ul><li>最后修改时间可能会出现变化</li><li>文件是秒级以内修改的</li><li>服务器不能精确获得最后修改时间。</li></ul></li></ul></li></ul><h3 id="8-HTTP"><a href="#8-HTTP" class="headerlink" title="8. HTTP"></a>8. HTTP</h3><p>HTTP1.0 和 HTTP1.1的区别</p><ol><li><strong>持久连接</strong>：<code>HTTP/1.1</code> 默认支持持久连接，允许在一个TCP连接上发送多个HTTP请求和响应，减少了连接建立和关闭的开销。而<code>HTTP/1.0</code> 默认为短连接，每次请求都需要建立一个TCP连接，并通过<code>Connection: keep-alive</code>头来实现持久连接。</li><li><strong>管道化</strong>：<code>HTTP/1.1</code> 支持管道化(不是默认开启)，允许客户端在第一个请求的响应到达之前发送多个请求，这可以减少等待时间，提高效率。HTTP&#x2F;1.0不支持管道化。</li><li><strong>缓存控制</strong>：<code>HTTP1.0</code>主要使用<code>If-Modified-Since/Expires</code>来做为缓存判断的标准，而<code>HTTP1.1</code>则引入了更多的缓存控制策略例如<code>Etag / If-None-Match</code>等更多可供选择的缓存头来控制缓存策略。</li><li>错误处理：<code>HTTP/1.1</code> 增加了一些新的HTTP状态码，如<code>100 Continue</code>，用于增强错误处理和请求的中间响应。</li><li><code>Host</code> 头：<code>HTTP/1.1</code> 引入了<code>Host</code>头，允许客户端指定请求的主机名，这使得在同一台服务器上托管多个域名成为可能。HTTP&#x2F;1.0没有这个头字段。</li><li>带宽优化 ：<code>HTTP1.0</code>中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能， 而<code>HTTP1.1</code>则在请求头引入了<code>range</code>头域，它允许只请求资源的某个部分，即返回码是<code>206（Partial Content）</code></li></ol><h4 id="8-1-HTTP-1-1"><a href="#8-1-HTTP-1-1" class="headerlink" title="8.1 HTTP&#x2F;1.1"></a>8.1 HTTP&#x2F;1.1</h4><p>优点：</p><ul><li>简单</li><li>灵活和易于扩展</li><li>应用广泛 跨平台</li></ul><p>缺点：</p><ul><li>无状态<ul><li>好处：不需要额外资源来记录状态信息，还能减轻服务器负担，把更多的CPU和内存用来提供服务。</li><li>坏处：没有记忆能力，在有关联性操作的时候会非常麻烦。解决无状态的问题最简单的就是Cookie技术。在请求和响应报文中写入Cookie信息来控制客户端的状态。</li></ul></li><li>明文传输<ul><li>信息裸奔，不安全，可以使用HTTPS的方式解决</li></ul></li></ul><p>性能：基于TCP&#x2F;IP并且使用了请求-应答，性能问题主要在这两点中</p><ul><li>长连接：HTTP&#x2F;1.0中的问题，就是每发起一个请求，都要新建一次TCP链接，通信开销较大。只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</li><li>管道传输网络：使用长连接使得管道成为了可能。在同一个TCP链接里用户可以发起多个请求，只要第一个请求发出，可以直接发出第二个请求，可以减少整体的响应时间。管道解决了请求的队头堵塞，没有解决响应的队头堵塞。</li><li>队头阻塞：当顺序发送的请求队列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也被一并阻塞</li></ul><h4 id="8-2-HTTP-2-0"><a href="#8-2-HTTP-2-0" class="headerlink" title="8.2 HTTP&#x2F;2.0"></a>8.2 HTTP&#x2F;2.0</h4><ul><li>HTTP&#x2F;2协议是基于HTTPs的所以安全。</li><li>头部压缩<ul><li>如果发出多个头部相同的请求，协议会帮你消除重复的部分</li><li><code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，只发送索引号，这样可以提高速度。</li></ul></li><li>二进制格式<ul><li>不再是纯文本报文，全面采用二进制格式，将原有报文分为头信息帧和数据帧。增加数据传输效率</li></ul></li><li>并发传输<ul><li>多条Stream复用在一条TCP链接。不同HTTP请求使用独一无二的Stream ID来区分，接收端可以通过Stream ID有序组装成HTTP消息，不同stream的帧可以乱序发送。</li></ul></li><li>服务器主动推源<ul><li>双方都可以建立Stream，客户端奇数号，服务端偶数号</li></ul></li></ul><p>HTTP2.0 的问题主要出现在TCP中，如果TCP出现丢包需要重传时，所有Stream必须等重传后应用层才能继续</p><h4 id="8-3-HTTP-3-0"><a href="#8-3-HTTP-3-0" class="headerlink" title="8.3 HTTP&#x2F;3.0"></a>8.3 HTTP&#x2F;3.0</h4><p>将下层协议改为UDP，基于UDP的QUIC协议可以实现TCP的可靠性传输。</p><ul><li>无队头阻塞：也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。多个Stream独立。</li><li>更快的链接建立<ul><li>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl实现的表示层，难以合并在一起。</li><li>HTTP3 再数据传输前需要QUIC协议握手，但是只需要1RTT，QUIC协议包括TLS&#x2F;1.3协议</li><li>并且可以实现对话恢复时0-RTT的效果。</li><li><img src="C:\Users\MasterLi\Documents\GitHub\hexo_myblog\source_posts\计算机网络\image-20250223214005765.png" alt="image-20250223214005765"></li></ul></li><li>连接迁移<ul><li>当移动设备的网络从4G切换到WIFI时，意味着IP地址变化了，必须要断开链接再重新链接。包括TCP的三次握手和TLS的四次握手以及TCP的慢启动。</li><li>QUIC协议通过连接ID标记通信两端，客户端和服务器可以各自选择一组ID来标记自己，即使IP地址变化，只要有上下文信息，就可以无缝复用原链接，达到了连接迁移的功能。</li></ul></li></ul><h4 id="8-4-HTTP和HTTPs的区别"><a href="#8-4-HTTP和HTTPs的区别" class="headerlink" title="8.4 HTTP和HTTPs的区别"></a>8.4 HTTP和HTTPs的区别</h4><p>两者的主要区别在于安全性和数据加密：</p><ol><li><strong>加密层</strong>：<code>HTTPS</code> 在<code>HTTP</code> 的基础上增加了<code>SSL/TLS</code> 协议作为加密层，确保数据传输的安全性。而<code>HTTP</code> 数据传输是明文的，容易受到攻击。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li><li><strong>端口</strong>：<code>HTTPS</code> 通常使用端口<code>443</code> ，而<code>HTTP</code> 使用端口80。</li><li>HTTPS 协议需要向 CA 申请数字证书，来保证服务器的身份是可信的。</li></ol><h4 id="8-5-HTTPs的工作原理"><a href="#8-5-HTTPs的工作原理" class="headerlink" title="8.5 HTTPs的工作原理"></a>8.5 HTTPs的工作原理</h4><p><code>HTTPS</code> 主要基于<code>SSL/TLS</code> 协议，确保了数据传输的安全性和完整性, 其建立连接并传输数据的过程如下：</p><ol><li><strong>密钥交换</strong>：客户端发起HTTPS请求，客户端随机数，协议版本，加密，服务器会发送其公钥证书给客户端。</li><li><strong>证书验证</strong>：客户端会验证服务器的证书是否由受信任的证书颁发机构（<code>CA</code> ）签发，并检查证书的有效性。</li><li><strong>加密通信</strong>：一旦证书验证通过，客户端会生成一个随机的对称加密密钥，并使用服务器的公钥加密这个密钥，然后发送给服务器。</li><li><strong>建立安全连接</strong>：服务器使用自己的私钥解密得到对称加密密钥，此时客户端和服务器都有了相同的密钥，可以进行加密和解密操作。</li><li><strong>数据传输</strong>：使用对称加密密钥对所有传输的数据进行加密，确保数据在传输过程中的安全性。</li><li><strong>完整性校验</strong>：SSL&#x2F;TLS协议还包括消息完整性校验机制，如消息认证码，确保数据在传输过程中未被篡改。</li><li><strong>结束连接</strong>：数据传输完成后，通信双方会进行会话密钥的销毁，以确保不会留下安全隐患。</li></ol><h3 id="9-TCP"><a href="#9-TCP" class="headerlink" title="9 TCP"></a>9 TCP</h3><h4 id="9-1-TCP连接如何确保可靠性"><a href="#9-1-TCP连接如何确保可靠性" class="headerlink" title="9.1 TCP连接如何确保可靠性"></a>9.1 TCP连接如何确保可靠性</h4><p>TCP连接主要通过TCP头部的字段以及超时重传、流量控制、拥塞控制方法确保传输的可靠性。</p><ul><li>首先每个TCP段都有一个序列号seq，确保数据包的顺序正确。还有确认应答号ack用于解决丢包问题</li><li>TCP首部中含有校验和字段，通过校验和可以进行数据校验，如果检测到错误，接收方会丢弃该数据包。</li><li>使用滑动窗口机制进行流量控制，确保接收方能够处理发送方的数据量</li><li>使用超时重传、快速重传、SACK、D-SACK等方式解决数据包丢失问题</li><li>TCP使用滑动窗口机制进行流量控制，确保接收方可以处理发送方的数据</li><li>TCP通过慢启动、拥塞避免、快重传和快恢复来控制数据的发送速率，防止网络拥塞。</li></ul><h4 id="9-2-拥塞控制是怎么实现的嘛"><a href="#9-2-拥塞控制是怎么实现的嘛" class="headerlink" title="9.2 拥塞控制是怎么实现的嘛"></a>9.2 拥塞控制是怎么实现的嘛</h4><p>TCP拥塞控制可以在网络出现拥塞时动态地调整数据传输的速率，以防止网络过载。TCP拥塞控制的主要机制包括以下几个方面：</p><ol><li><strong>慢启动（Slow Start）：</strong>发送方每收到一个ACK，拥塞窗口的大小就会加1。 初始阶段，TCP发送方会以较小的发送窗口开始传输数据。随着每次成功收到确认的数据，发送方逐渐增加发送窗口的大小，实现指数级的增长，这称为慢启动。这有助于在网络刚开始传输时谨慎地逐步增加速率，以避免引发拥塞。</li><li><strong>拥塞避免（Congestion Avoidance）：</strong> 一旦达到一定的阈值（通常是慢启动阈值ssthresh），TCP发送方就会进入拥塞避免阶段。在拥塞避免阶段，发送方以线性增加的方式增加发送窗口的大小，而不再是指数级的增长。这有助于控制发送速率，以避免引起网络拥塞。</li><li><strong>快速重传（Fast Retransmit）：</strong> 如果发送方连续收到相同的确认，它会认为发生了数据包的丢失，并会快速重传未确认的数据包，而不必等待超时。这有助于更快地恢复由于拥塞引起的数据包丢失。<ul><li>超时重传算法：ssthresh &#x3D; cwnd&#x2F;2 cwnd &#x3D; 初始值。</li><li>快速重传算法：当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速的重传。 cwnd &#x3D; cwnd&#x2F;2 ssthresh &#x3D; cwnd，之后进入快速恢复算法。</li></ul></li><li><strong>快速恢复（Fast Recovery）：</strong> 在发生快速重传后，TCP进入快速恢复阶段。在这个阶段，发送方不会回到慢启动阶段，而是将慢启动阈值设置为当前窗口的一半，并将拥塞窗口大小设置为慢启动阈值加上已确认但未被快速重传的数据块的数量。这有助于更快地从拥塞中恢复。</li></ol><img src="C:\Users\MasterLi\Documents\GitHub\hexo_myblog\source\_posts\计算机网络\image-20250302214202082.png" alt="image-20250302214202082" style="zoom:50%;" /><h4 id="9-3-流量控制怎么实现"><a href="#9-3-流量控制怎么实现" class="headerlink" title="9.3 流量控制怎么实现"></a>9.3 流量控制怎么实现</h4><p><strong>流量控制</strong>就是让发送方发送速率不要过快，让接收方来得及接收。利用<strong>滑动窗口机制</strong>就可以实施流量控制，主要方法就是动态调整发送方和接收方之间数据传输速率。</p><ul><li><strong>滑动窗口大小：</strong> 在TCP通信中，每个TCP报文段都包含一个窗口字段，该字段指示发送方可以发送多少字节的数据而不等待确认。这个窗口大小是动态调整的。</li><li><strong>接收方窗口大小：</strong> 接收方通过TCP报文中的窗口字段告诉发送方自己当前的可接收窗口大小。这是接收方缓冲区中还有多少可用空间。</li><li><strong>流量控制的目标：</strong> 流量控制的目标是确保发送方不要发送超过接收方缓冲区容量的数据。如果接收方的缓冲区快满了，它会减小窗口大小，通知发送方暂停发送，以防止溢出。</li><li><strong>动态调整：</strong> 发送方会根据接收方的窗口大小动态调整发送数据的速率。如果接收方的窗口大小增加，发送方可以加速发送数据。如果窗口大小减小，发送方将减缓发送数据的速率。</li><li><strong>确认机制：</strong> 接收方会定期发送确认（ACK）报文，告知发送方已成功接收数据。这也与流量控制密切相关，因为接收方可以通过ACK报文中的窗口字段来通知发送方它的当前窗口大小。</li><li>当接收窗口为0时，启动计时器，如果计时器超时，发送方发送窗口探帧报文，可以打破死锁局面。</li></ul><h4 id="9-4-UDP怎么实现可靠传输"><a href="#9-4-UDP怎么实现可靠传输" class="headerlink" title="9.4 UDP怎么实现可靠传输"></a>9.4 UDP怎么实现可靠传输</h4><p>UDP它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。传输层无法保证数据的可靠传输，只能通过<strong>应用层</strong>来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。关键在于两点，从应用层角度考虑：</p><p>（1）提供超时重传，能避免数据报丢失。</p><p>（2）提供确认序列号，可以对数据报进行确认和排序。</p><p><strong>本端</strong>：首先在UDP数据报定义一个首部，首部包含确认序列号和时间戳，时间戳是用来计算RTT(数据报传输的往返时间)，计算出合适的RTO(重传的超时时间)。然后以等-停的方式发送数据报，即收到对端的确认之后才发送下一个的数据报。当时间超时，本端重传数据报，同时RTO扩大为原来的两倍，重新开始计时。</p><p><strong>对端</strong>：接受到一个数据报之后取下该数据报首部的时间戳和确认序列号，并添加本端的确认数据报首部之后发送给本端。根据此序列号对已收到的数据报进行排序并丢弃重复的数据报。</p><h4 id="9-5-TCP为什么是三次握手，可以是两次或者更多吗"><a href="#9-5-TCP为什么是三次握手，可以是两次或者更多吗" class="headerlink" title="9.5 TCP为什么是三次握手，可以是两次或者更多吗"></a>9.5 TCP为什么是三次握手，可以是两次或者更多吗</h4><p>(1) 三次握手的过程</p><ol><li><strong>第一次握手</strong>：客户端向服务器发送一个<code>SYN</code> （同步序列编号）报文，请求建立连接，客户端进入<code>SYN_SENT</code> 状态。</li><li><strong>第二次握手</strong>：服务器收到<code>SYN</code> 报文后，如果同意建立连接，则会发送一个<code>SYN-ACK</code> （同步确认）报文作为响应，同时进入<code>SYN_RCVD</code> 状态。</li><li><strong>第三次握手</strong>：客户端收到服务器的<code>SYN-ACK</code> 报文后，会发送一个<code>ACK</code> （确认）报文作为最终响应，之后客户端和服务器都进入<code>ESTABLISHED</code> 状态，连接建立成功。</li></ol><p>通过三次握手，客户端和服务器都能够确认对方的接收和发送能力。第一次握手确认了客户端到服务器的通道是开放的；第二次握手确认了服务器到客户端的通道是开放的；第三次握手则确认了客户端接收到服务器的确认，从而确保了双方的通道都是可用的。</p><p>而如果仅使用两次握手，服务器可能无法确定客户端的接收能力是否正常，比如客户端可能已经关闭了连接，但之前发送的连接请求报文在网络上延迟到达了服务器，服务器就会主动去建立一个连接，但是客户端接收不到，导致资源的浪费。三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。而四次握手可以优化为三次。</p><ul><li><p>三次握手可以阻止重复历史链接的初始化：在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接造成资源浪费。</p></li><li><p>三次握手可以同步双方初始序列号：两次握手只能保证一方的初始序列号被对方成功接收</p></li><li><p>三次握手可以避免浪费资源：</p><ul><li>只有两次握手的情况下服务端每收到一个SYN就建立一个连接，如果多个SYN重复发送，收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。</li></ul></li></ul><h4 id="9-6-TCP为什么是四次挥手"><a href="#9-6-TCP为什么是四次挥手" class="headerlink" title="9.6 TCP为什么是四次挥手"></a>9.6 TCP为什么是四次挥手</h4><p>客户端：FIN_WAIT1 FIN_WAIT2 TIME_WAIT CLOSE</p><p>服务端：CLOSE_WAIT LAST_ACK CLOSE</p><ul><li>服务端需要等待数据的发送和处理，所以ACK和FIN会分开发送。</li></ul><p>（1）四次挥手的过程</p><ol><li>第一次挥手：客户端发送一个<code>FIN</code>报文给服务端，表示自己要断开数据传送，报文中会指定一个序列号 <code>(seq=x)</code>。然后,客户端进入<code>FIN-WAIT-1 </code>状态。</li><li>第二次挥手：服务端收到<code>FIN</code>报文后，回复<code>ACK</code>报文给客户端，且把客户端的序列号值<code>+1</code>，作为ACK报文的序列号<code>(seq=x+1)</code>。然后，服务端进入<code>CLOSE-WAIT(seq=x+1)</code>状态，客户端进入<code>FIN-WAIT-2</code>状态。</li><li>第三次挥手：服务端也要断开连接时，发送<code>FIN</code>报文给客户端，且指定一个序列号<code>(seq=y+1)</code>，随后服务端进入<code>LAST-ACK</code>状态。</li><li>第四次挥手：客户端收到<code>FIN</code>报文后，发出<code>ACK</code>报文进行应答，并把服务端的序列号值<code>+1</code>作为<code>ACK</code>报文序列号<code>(seq=y+2)</code>。此时客户端进入<code>TIME-WAIT</code>状态。服务端在收到客户端的<code>ACK </code>报文后进入<code>CLOSE</code> 状态。如果客户端等待<code>2MSL</code>没有收到回复，才关闭连接。</li></ol><p>（2）为什么需要四次挥手</p><p><code>TCP</code>是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。 当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后才会完全关闭<code> TCP</code> 连接。因此两次挥手可以释放一端到另一端的<code>TCP</code>连接，完全释放连接一共需要四次挥手。</p><p>只有通过四次挥手，才可以确保双方都能接收到对方的最后一个数据段的确认，主动关闭方在发送完最后一个<code>ACK</code>后进入<code>TIME-WAIT</code> 状态，这是为了确保被动关闭方接收到最终的<code>ACK</code> ，如果被动关闭方没有接收到，它可以重发<code>FIN</code> 报文，主动关闭方可以再次发送<code>ACK</code> 。</p><p>而如果使用三次挥手，被动关闭方可能在发送最后一个数据段后立即关闭连接，而主动关闭方可能还没有接收到这个数据段的确认</p><h4 id="9-7-HTTP和TCP的Keep-Alive是一个东西吗"><a href="#9-7-HTTP和TCP的Keep-Alive是一个东西吗" class="headerlink" title="9.7 HTTP和TCP的Keep-Alive是一个东西吗"></a>9.7 HTTP和TCP的Keep-Alive是一个东西吗</h4><ul><li>HTTP的Keep-Alive是由应用层（用户态）实现，HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</li><li>TCP的Keep-Alive是TCP的保活机制，如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件：<ul><li>如果对端程序正常工作。TCP的保活探测报文发送给对端对端正常响应，这样TCP的保活时间会重置，等待下一个TCP保活时间到来。</li><li>否则TCP会报告连接死亡。</li></ul></li></ul><ol><li><code>HTTP</code> 的 <code>Keep-Alive</code>，是由应用层实现的，称为 HTTP 长连接</li></ol><p>每次请求都要经历这样的过程：建立 <code>TCP</code>连接 -&gt; <code>HTTP</code>请求资源 -&gt; 响应资源 -&gt; 释放连接，这就是HTTP短连接，但是这样每次建立连接都只能请求一次资源，所以<code>HTTP </code>的 <code>Keep-Alive</code>实现了使用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销，就就是 <strong>HTTP 长连接</strong>。通过设置HTTP头<code>Connection: keep-alive</code>来实现。</p><ol><li><code>TCP</code> 的 <code>Keepalive</code>，是由<code>TCP </code>层（内核态）实现的，称为 <code>TCP </code>保活机制，是一种用于在 <code>TCP </code>连接上检测空闲连接状态的机制</li></ol><p>当<code>TCP</code>连接建立后，如果一段时间内没有任何数据传输，<code>TCP Keepalive</code>会发送探测包来检查连接是否仍然有效。</p><p>补充说明：</p><p>其实这里tcp的keepalive，不只是支持http，还可以支持ftp和smtp的，他是一个能力，类似于gc。</p><p>http的这个keepalive感觉更是一种策略吧，比如你有一个http用了keepalive，然后过了一会，你不传输数据了，这个时候没有通知对方close，这个时候tcp的keepalive就会起到用处去关闭这次链接。</p><h4 id="9-8-DNS查询过程"><a href="#9-8-DNS查询过程" class="headerlink" title="9.8 DNS查询过程"></a>9.8 DNS查询过程</h4><img src="C:\Users\MasterLi\Documents\GitHub\hexo_myblog\source\_posts\计算机网络\image-20250302233703435.png" alt="image-20250302233703435" style="zoom:50%;" /><img src="C:\Users\MasterLi\Documents\GitHub\hexo_myblog\source\_posts\计算机网络\image-20250302233740538.png" alt="image-20250302233740538" style="zoom:50%;" /><h4 id="9-9-CDN是什么，有什么作用"><a href="#9-9-CDN是什么，有什么作用" class="headerlink" title="9.9 CDN是什么，有什么作用"></a>9.9 CDN是什么，有什么作用</h4><ul><li>内容分发网络（CDN）是一个互连服务器网络，可加快数据密集型应用程序的网页加载速度。CDN 可以表示内容分发网络或内容分配网络。当用户访问某个网站时，来自该网站服务器的数据必须通过互联网传输到用户的计算机。如果用户距离该服务器较远，则加载大文件（例如视频或网站图像）将需要很长时间。相反，如果网站内容存储在距离用户较近的 CDN 服务器上，就可以更快到达他们的计算机。<ul><li><strong>就近访问</strong>：CDN 在全球范围内部署了多个服务器节点，用户的请求会被路由到距离最近的 CDN 节点，提供快速的内容访问。</li><li><strong>内容缓存</strong>：CDN 节点会缓存静态资源，如图片、样式表、脚本等。当用户请求访问这些资源时，CDN 会首先检查是否已经缓存了该资源。如果有缓存，CDN 节点会直接返回缓存的资源，如果没有缓存所需资源，它会从源服务器（原始服务器）回源获取资源，并将资源缓存到节点中，以便以后的请求。通过缓存内容，减少了对原始服务器的请求，减轻了源站的负载。</li><li>可用性：即使某些节点出现问题，用户请求可以被重定向到其他健康的节点。</li></ul></li></ul><h4 id="9-10-Cookie和Session"><a href="#9-10-Cookie和Session" class="headerlink" title="9.10 Cookie和Session"></a>9.10 Cookie和Session</h4><p>(1) Cookie和Session是什么？</p><p><code>Cookie </code>和 <code>Session </code>都用于管理用户的状态和身份, <code>Cookie</code>通过在客户端记录信息确定用户身份，<code>Session</code>通过在服务器端记录信息确定用户身份。</p><ol><li>Cookie</li></ol><ul><li>通常，服务器会将一个或多个<code> Cookie</code> 发送到用户浏览器，然后浏览器将这些 <code>Cookie</code> 存储在本地。</li><li>服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的<code>Cookie</code>得到客户端特有的信息，从而动态生成与该客户端相对应的内容。</li></ul><ol><li>Session</li></ol><p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是<code>Session</code>。Session 主要用于维护用户登录状态、存储用户的临时数据和上下文信息等。服务器为每个用户分配一个唯一的<code>Session ID</code>，通常存储在<code>Cookie</code>中。</p><p>（2） Cookie和Session的区别？</p><ul><li>存储位置：<code>Cookie</code> 数据存储在用户的浏览器中，而 <code>Session</code> 数据存储在服务器上。</li><li>数据容量：<code>Cookie</code> 存储容量较小，一般为几 KB。<code>Session</code> 存储容量较大，通常没有固定限制，取决于服务器的配置和资源。</li><li>安全性：由于 <code>Cookie</code> 存储在用户浏览器中，因此可以被用户读取和篡改。相比之下，Session 数据存储在服务器上，更难被用户访问和修改。</li><li>生命周期：<code>Cookie</code>可以设置过期时间，<code>Session</code> 依赖于会话的持续时间或用户活动。</li><li>传输方式：<code>Cookie</code> 在每次 <code>HTTP</code> 请求中都会被自动发送到服务器，而 <code>Session ID</code> 通常通过<code> Cookie</code> 或 URL 参数传递。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>实习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后端面经</title>
    <link href="/2025/01/24/%E5%90%8E%E7%AB%AF%E9%9D%A2%E7%BB%8F/"/>
    <url>/2025/01/24/%E5%90%8E%E7%AB%AF%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="后端面经"><a href="#后端面经" class="headerlink" title="后端面经"></a>后端面经</h1><h2 id="Java-base"><a href="#Java-base" class="headerlink" title="Java base"></a>Java base</h2><h4 id="1-HashMap原理"><a href="#1-HashMap原理" class="headerlink" title="1. HashMap原理"></a>1. HashMap原理</h4><p><a href="https://zhuanlan.zhihu.com/p/127147909">https://zhuanlan.zhihu.com/p/127147909</a></p><h4 id="2-ArrayList原理"><a href="#2-ArrayList原理" class="headerlink" title="2. ArrayList原理"></a>2. ArrayList原理</h4><p><a href="https://cloud.tencent.com/developer/news/700913">https://cloud.tencent.com/developer/news/700913</a></p><h4 id="3-Java和C-的区别"><a href="#3-Java和C-的区别" class="headerlink" title="3. Java和C++的区别"></a>3. Java和C++的区别</h4><p>虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：</p><ul><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li></ul><h4 id="4-所有整型包装类对象之间值的比较，全部使用-equals-方法比较。"><a href="#4-所有整型包装类对象之间值的比较，全部使用-equals-方法比较。" class="headerlink" title="4. 所有整型包装类对象之间值的比较，全部使用 equals 方法比较。"></a>4. 所有整型包装类对象之间值的比较，全部使用 equals 方法比较。</h4><h3 id="自动装箱与拆箱了解吗？原理是什么？"><a href="#自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="自动装箱与拆箱了解吗？原理是什么？"></a><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%E4%BA%86%E8%A7%A3%E5%90%97-%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">自动装箱与拆箱了解吗？原理是什么？</a></h3><p><strong>什么是自动拆装箱？</strong></p><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><p>使用BigDecimal来解决浮点数精度丢失的问题</p><h4 id="5-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#5-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="5. 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>5. <a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D">深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</a></h4><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li></ul><p>上面的结论没有完全理解的话也没关系，我们来看一个具体的案例！</p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/2025/01/24/%E5%90%8E%E7%AB%AF%E9%9D%A2%E7%BB%8F/image-20250209170156618.png" class="" title="image-20250209170156618"></h4><h4 id="6-序列化和反序列化"><a href="#6-序列化和反序列化" class="headerlink" title="6. 序列化和反序列化"></a>6. 序列化和反序列化</h4><p>简单来说：</p><ul><li><strong>序列化</strong>：将数据结构或对象转换成可以存储或传输的形式，通常是二进制字节流，也可以是 JSON, XML 等文本格式</li><li><strong>反序列化</strong>：将在序列化过程中所生成的数据转换为原始数据结构或者对象的过程</li></ul><p>下面是序列化和反序列化常见应用场景：</p><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li></ul><p>如果有字段不想序列化，使用transient关键字进行修饰。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h4 id="7-I-O"><a href="#7-I-O" class="headerlink" title="7. I&#x2F;O"></a>7. I&#x2F;O</h4><p>BIO</p><p>&#x2F;&#x2F; todo</p><h5 id="7-1-NIO-核心组件"><a href="#7-1-NIO-核心组件" class="headerlink" title="7.1 NIO 核心组件"></a>7.1 <a href="#nio-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6">NIO 核心组件</a></h5><p>NIO 主要包括以下三个核心组件：</p><ul><li><strong>Buffer（缓冲区）</strong>：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</li><li><strong>Channel（通道）</strong>：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过 Channel 来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。</li><li><strong>Selector（选择器）</strong>：允许一个线程处理多个 Channel，基于事件驱动的 I&#x2F;O 多路复用模型。所有的 Channel 都可以注册到 Selector 上，由 Selector 来分配线程来处理事件。</li></ul><style>.isepuokekdxn{zoom:50%;}</style><img src="/2025/01/24/%E5%90%8E%E7%AB%AF%E9%9D%A2%E7%BB%8F/image-20250217161746454.png" class="isepuokekdxn" alt="image-20250217161746454"><p><strong>Buffer</strong></p><p>在传统的 BIO 中，数据的读写是面向流的， 分为字节流和字符流。</p><p>在 Java 1.4 的 NIO 库中，所有数据都是用缓冲区处理的，这是新库和之前的 BIO 的一个重要区别，有点类似于 BIO 中的缓冲流。NIO 在读取数据时，它是直接读到缓冲区中的。在写入数据时，写入到缓冲区中。 使用 NIO 在读写数据时，都是通过缓冲区进行操作。</p><p>Buffer中包括一下四个变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span> &#123;<br>    <span class="hljs-comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">mark</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> limit;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>容量（<code>capacity</code>）：<code>Buffer</code>可以存储的最大数据量，<code>Buffer</code>创建时设置且不可改变；</li><li>界限（<code>limit</code>）：<code>Buffer</code> 中可以读&#x2F;写数据的边界。写模式下，<code>limit</code> 代表最多能写入的数据，一般等于 <code>capacity</code>（可以通过<code>limit(int newLimit)</code>方法设置）；读模式下，<code>limit</code> 等于 Buffer 中实际写入的数据大小。</li><li>位置（<code>position</code>）：下一个可以被读写的数据的位置（索引）。从写操作模式到读操作模式切换的时候（flip），<code>position</code> 都会归零，这样就可以从头开始读写了。</li><li>标记（<code>mark</code>）：<code>Buffer</code>允许将位置直接定位到该标记处，这是一个可选属性；</li></ul><p>Buffer分为读模式和写模式，uffer 被创建之后默认是写模式，调用 <code>flip()</code> 可以切换到读模式。如果要再次切换回写模式，可以调用 <code>clear()</code> 或者 <code>compact()</code> 方法。</p><ul><li><p><code>flip</code> ：将缓冲区从写模式切换到读模式，它会将 <code>limit</code> 的值设置为当前 <code>position</code> 的值，将 <code>position</code> 的值设置为 0。</p></li><li><p><code>clear</code>: 清空缓冲区，将缓冲区从读模式切换到写模式，并将 <code>position</code> 的值设置为 0，将 <code>limit</code> 的值设置为 <code>capacity</code> 的值。</p></li></ul><p><strong>Channel</strong></p><p>Channel 最核心的两个方法：</p><ol><li><code>read</code> ：读取数据并写入到 Buffer 中。</li><li><code>write</code> ：将 Buffer 中的数据写入到 Channel 中。</li></ol><p>这里我们以 <code>FileChannel</code> 为例演示一下是读取文件数据的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;/Users/guide/Documents/test_read.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>))<br><span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> reader.getChannel();<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>channel.read(buffer);<br></code></pre></td></tr></table></figure><p><strong>Selector</strong></p><p>Selector（选择器） 是 NIO 中的一个关键组件，它允许一个线程处理多个 Channel。Selector 是基于事件驱动的 I&#x2F;O 多路复用模型，主要运作原理是：通过 Selector 注册通道的事件，Selector 会不断地轮询注册在其上的 Channel。当事件发生时，比如：某个 Channel 上面有新的 TCP 连接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来。Selector 会将相关的 Channel 加入到就绪集合中。通过 SelectionKey 可以获取就绪 Channel 的集合，然后对这些就绪的 Channel 进行相应的 I&#x2F;O 操作。</p><p>一个多路复用器 Selector 可以同时轮询多个 Channel，由于 JDK 使用了 <code>epoll()</code> 代替传统的 <code>select</code> 实现，所以它并没有最大连接句柄 <code>1024/2048</code> 的限制。这也就意味着只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端。</p><p>Selector 可以监听以下四种事件类型：</p><ol><li><code>SelectionKey.OP_ACCEPT</code>：表示通道接受连接的事件，这通常用于 <code>ServerSocketChannel</code>。</li><li><code>SelectionKey.OP_CONNECT</code>：表示通道完成连接的事件，这通常用于 <code>SocketChannel</code>。</li><li><code>SelectionKey.OP_READ</code>：表示通道准备好进行读取的事件，即有数据可读。</li><li><code>SelectionKey.OP_WRITE</code>：表示通道准备好进行写入的事件，即可以写入数据。</li></ol><h5 id="NIO-零拷贝"><a href="#NIO-零拷贝" class="headerlink" title="NIO 零拷贝"></a>NIO 零拷贝</h5><ol><li>传统 I&#x2F;O 的问题</li></ol><p>在传统 Java I&#x2F;O（如 <code>FileInputStream</code> 和 <code>FileOutputStream</code>）中，数据从文件传输到网络的典型流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 伪代码示例：传统文件传输</span><br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;source.txt&quot;</span>);<br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;target.txt&quot;</span>);<br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span> ((len = fis.read(buffer)) != -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 步骤1：内核态→用户态拷贝</span><br>    fos.write(buffer, <span class="hljs-number">0</span>, len);           <span class="hljs-comment">// 步骤2：用户态→内核态拷贝</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>涉及 4 次数据拷贝和 4 次上下文切换</strong>：</p><ol><li><p><strong>DMA</strong> 将磁盘数据拷贝到内核缓冲区（内核态）。</p></li><li><p><strong>CPU</strong> 将内核缓冲区的数据拷贝到用户缓冲区（用户态）。</p></li><li><p><strong>CPU</strong> 将用户缓冲区的数据拷贝到 Socket 内核缓冲区（内核态）。</p></li><li><p><strong>DMA</strong> 将 Socket 内核缓冲区的数据拷贝到网卡（网络发送）。</p></li><li><p>NIO零拷贝实现</p></li></ol><p>Java NIO 通过 <code>FileChannel.transferTo()</code> 或 <code>transferFrom()</code> 方法实现零拷贝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 伪代码示例：零拷贝文件传输</span><br><span class="hljs-type">FileChannel</span> <span class="hljs-variable">sourceChannel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;source.txt&quot;</span>).getChannel();<br><span class="hljs-type">FileChannel</span> <span class="hljs-variable">targetChannel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;target.txt&quot;</span>).getChannel();<br>sourceChannel.transferTo(<span class="hljs-number">0</span>, sourceChannel.size(), targetChannel); <span class="hljs-comment">// 直接传输</span><br></code></pre></td></tr></table></figure><p><strong>零拷贝的流程</strong>：</p><ol><li><strong>DMA</strong> 将磁盘数据拷贝到内核缓冲区（内核态）。</li><li><strong>CPU</strong> 直接将内核缓冲区的数据拷贝到目标缓冲区（如 Socket 缓冲区），无需经过用户态。</li><li><strong>DMA</strong> 将数据从目标缓冲区传输到网卡（网络发送）。</li></ol><p><strong>优化效果</strong>：</p><ul><li><strong>减少 2 次数据拷贝</strong>（用户态与内核态之间的拷贝）。</li><li><strong>减少 2 次上下文切换</strong>（用户态和内核态的切换）。</li><li>显著降低 CPU 和内存占用，提升吞吐量。</li></ul><p><a href="https://developer.ibm.com/articles/j-zerocopy/">https://developer.ibm.com/articles/j-zerocopy/</a></p>]]></content>
    
    
    <categories>
      
      <category>backend</category>
      
    </categories>
    
    
    <tags>
      
      <tag>backend</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Hot 100</title>
    <link href="/2025/01/20/Leetcode-Hot-100/"/>
    <url>/2025/01/20/Leetcode-Hot-100/</url>
    
    <content type="html"><![CDATA[<h3 id="1-哈希"><a href="#1-哈希" class="headerlink" title="1. 哈希"></a>1. 哈希</h3><p><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>      <span class="hljs-comment">// solution 1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;j &lt; nums.length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]+nums[j] == target)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i,j&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">// solution 2</span><br>        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.containsKey(target-nums[i]))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, map.get(target-nums[i])&#125;;<br>            &#125;<br>            map.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></p><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sortString</span><span class="hljs-params">(String s)</span>&#123;<br>        String[] sArray = s.split(<span class="hljs-string">&quot;&quot;</span>);<br><br>        Arrays.sort(sArray);<br>        <span class="hljs-keyword">return</span> Arrays.toString(sArray);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        Map&lt;String, ArrayList&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(String s: strs)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> sortString(s);<br>            <span class="hljs-keyword">if</span>(map.containsKey(key))&#123;<br>                map.get(key).add(s);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                map.put(key,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                map.get(key).add(s);<br>            &#125;<br>        &#125;<br>        List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(ArrayList&lt;String&gt; tmp : map.values())&#123;<br>            ans.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></p><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n: nums)&#123;<br>            set.add(n);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n: set)&#123;<br>            <span class="hljs-keyword">if</span>(!set.contains(n-<span class="hljs-number">1</span>))&#123;<br>                temp = <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> n;<br>                <span class="hljs-keyword">while</span>(set.contains(curr+<span class="hljs-number">1</span>))&#123;<br>                    curr += <span class="hljs-number">1</span>;<br>                    temp += <span class="hljs-number">1</span>;<br>                &#125;<br>                ans = Math.max(ans, temp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-双指针"><a href="#2-双指针" class="headerlink" title="2. 双指针"></a>2. 双指针</h3><p><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(;fast &lt; nums.length;fast++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast] != <span class="hljs-number">0</span>)&#123;<br>                nums[slow++] = nums[fast];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(;slow &lt; nums.length;slow++)&#123;<br>            nums[slow] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></p><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = height.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            max = Math.max(max, (r-l)*Math.min(height[l],height[r]));<br>            <span class="hljs-keyword">if</span>(height[l]&lt;height[r])&#123;<br>                l++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></p><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>,r = nums.length-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[i]+nums[l] + nums[r];<br>                <span class="hljs-keyword">if</span>(res == <span class="hljs-number">0</span>)&#123;<br>                    ans.add(Arrays.asList(nums[i],nums[l],nums[r]));<br>                    <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[r-<span class="hljs-number">1</span>] == nums[r]) r--;<br>                    <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[l+<span class="hljs-number">1</span>] == nums[l]) l++;<br>                    l++;<br>                    r--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res &gt; <span class="hljs-number">0</span>)&#123;<br>                    r--;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    l++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></p><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, postMax = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,r = height.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            preMax = Math.max(preMax, height[l]);<br>            postMax = Math.max(postMax, height[r]);<br>            <span class="hljs-keyword">if</span>(preMax &lt; postMax)&#123;<br>                ans += preMax-height[l];<br>                l++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans += postMax-height[r];<br>                r--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="3. 滑动窗口"></a>3. 滑动窗口</h3><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长</strong> <strong>子串</strong>的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        Set&lt;Character&gt; charset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, e = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(e &lt; len)&#123;<br>            <span class="hljs-keyword">while</span>(charset.contains(s.charAt(e)))&#123;<br>                    charset.remove(s.charAt(start++));<br>            &#125;<br>                <br>            charset.add(s.charAt(e++));<br>            ans = Math.max(ans,charset.size());<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></p><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong>的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] sCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-type">int</span>[] pCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>]; <br>     <span class="hljs-comment">// solution 1 超时</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkAnagrams</span><span class="hljs-params">(String p, String winStr)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; p.length();i++)&#123;<br>            sArray.add(p.charAt(i));<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; p.length();i++)&#123;<br>            <span class="hljs-keyword">if</span>(sArray.contains(winStr.charAt(i)))&#123;<br>                sArray.remove((Character) winStr.charAt(i));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sArray.isEmpty();<br>    &#125;<br>  <br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        <br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = start+p.length();<br><br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(;end &lt;= len;end++)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s.substring(start,end);<br>            <span class="hljs-keyword">if</span>(checkAnagrams(p,temp))&#123;<br>                ans.add(start);<br>                start++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                start++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br><br><span class="hljs-comment">// solution 2</span><br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pLen</span> <span class="hljs-operator">=</span> p.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sLen</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span>(pLen &gt; sLen)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = start+pLen;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; pLen;i++)&#123;<br>            pCount[p.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            sCount[s.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(;end &lt; sLen;end++)&#123;<br>            <span class="hljs-keyword">if</span>(Arrays.equals(sCount,pCount))&#123;<br>                ans.add(start);<br>            &#125;<br>            sCount[s.charAt(start++)-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            sCount[s.charAt(end)-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(Arrays.equals(sCount,pCount))&#123;<br>            ans.add(start);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-子串"><a href="#4-子串" class="headerlink" title="4. 子串"></a>4. 子串</h3><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p><p>子数组是数组中元素的连续非空序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>      <span class="hljs-comment">// solution 1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>           <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>                preSum[i] = nums[i];<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(preSum[i] == k) ans++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;j &lt; nums.length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(preSum[j]-preSum[i] == k)&#123;<br>                    ans++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>      <span class="hljs-comment">// solution 2</span><br>      Map&lt;Integer, Integer&gt; m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>      <span class="hljs-comment">// 用于处理前缀和即为k的结果</span><br>        m.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;<br>            preSum+=num;<br>          <span class="hljs-comment">// 先检查是否存在presum - 另一个presum = k，再更新结果，保证不会重复计算</span><br>            <span class="hljs-keyword">if</span>(m.containsKey(preSum-k))&#123;<br>                ans += m.get(preSum-k);<br>            &#125;<br><br>            m.put(preSum, m.getOrDefault(preSum,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></p><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>      <span class="hljs-comment">// Solution 1</span><br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] pair1, <span class="hljs-type">int</span>[] pair2)</span>&#123;<br>                <span class="hljs-comment">// 如果两数相同， 比较在数组中的位置，位置越靠后越大</span><br>                <span class="hljs-keyword">return</span> pair1[<span class="hljs-number">0</span>] != pair2[<span class="hljs-number">0</span>] ? pair2[<span class="hljs-number">0</span>] - pair1[<span class="hljs-number">0</span>] : pair2[<span class="hljs-number">1</span>] - pair1[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; k;i++)&#123;<br>            pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nums[i],i&#125;);<br>        &#125;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length-k+<span class="hljs-number">1</span>];<br>        ans[<span class="hljs-number">0</span>] = pq.peek()[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = k;<br>        <span class="hljs-keyword">for</span>(;end &lt; nums.length;end++)&#123;<br>            pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nums[end],end&#125;);<br>            <span class="hljs-comment">// 当前最大值超出空间范围</span><br>            <span class="hljs-keyword">while</span>(pq.peek()[<span class="hljs-number">0</span>] &lt;= start)&#123;<br>                pq.poll();<br>            &#125;<br>            ans[++start] = pq.peek()[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>      <span class="hljs-comment">// Solution 2 双端队列维护当前每个窗口最大值的下标</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Deque&lt;Integer&gt; dq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n-k+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; k;i++)&#123;<br>            <span class="hljs-keyword">while</span>(!dq.isEmpty() &amp;&amp; nums[i] &gt;= nums[dq.peekLast()])&#123;<br>                dq.pollLast();<br>            &#125;<br>            dq.offerLast(i);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = k;<br>        ans[<span class="hljs-number">0</span>] = nums[dq.peekFirst()];<br>        <span class="hljs-keyword">for</span>(;end &lt; n; end++)&#123;<br>            <span class="hljs-keyword">while</span>(!dq.isEmpty() &amp;&amp; nums[end] &gt;= nums[dq.peekLast()])&#123;<br>                dq.pollLast();<br>            &#125;<br>            dq.offerLast(end);<br>            <span class="hljs-keyword">while</span>(dq.peekFirst() &lt;= start)&#123;<br>                dq.pollFirst();<br>            &#125;<br>            ans[++start] = nums[dq.peekFirst()];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></p><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (t.length() &gt; s.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] sMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">52</span>];<br>        <span class="hljs-type">int</span>[] tMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">52</span>];<br><br>        <span class="hljs-comment">// 初始化 tMap，并计算需要匹配的字符种类数 required</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">required</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; t.length(); i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> getIndex(t.charAt(i));<br>            tMap[index]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">52</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (tMap[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                required++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">formed</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前窗口中满足要求的字符种类数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minLen</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minStart</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (end &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(end);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> getIndex(c);<br>            <span class="hljs-keyword">if</span> (index == -<span class="hljs-number">1</span>) &#123;<br>                end++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            sMap[index]++;<br>            <span class="hljs-keyword">if</span> (tMap[index] &gt; <span class="hljs-number">0</span> &amp;&amp; sMap[index] == tMap[index]) &#123;<br>                formed++;<br>            &#125;<br><br>            <span class="hljs-comment">// 尝试收缩窗口</span><br>            <span class="hljs-keyword">while</span> (start &lt;= end &amp;&amp; formed == required) &#123;<br>                <span class="hljs-comment">// 更新最小覆盖子串</span><br>                <span class="hljs-keyword">if</span> (end - start + <span class="hljs-number">1</span> &lt; minLen) &#123;<br>                    minLen = end - start + <span class="hljs-number">1</span>;<br>                    minStart = start;<br>                &#125;<br><br>                <span class="hljs-type">char</span> <span class="hljs-variable">cStart</span> <span class="hljs-operator">=</span> s.charAt(start);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">indexStart</span> <span class="hljs-operator">=</span> getIndex(cStart);<br>                <span class="hljs-keyword">if</span> (indexStart != -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-comment">// 当前符合要求的字符数要减少</span><br>                    <span class="hljs-keyword">if</span> (tMap[indexStart] &gt; <span class="hljs-number">0</span> &amp;&amp; sMap[indexStart] == tMap[indexStart]) &#123;<br>                        formed--;<br>                    &#125;<br>                    <span class="hljs-comment">// 该计数减少</span><br>                    sMap[indexStart]--;<br>                &#125;<br>                start++;<br>            &#125;<br>            end++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="hljs-string">&quot;&quot;</span> : s.substring(minStart, minStart + minLen);<br>    &#125;<br><br>    <span class="hljs-comment">// 辅助方法，将字符映射到数组索引</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getIndex</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> c - <span class="hljs-string">&#x27;A&#x27;</span>; <span class="hljs-comment">// 0 - 25</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> c - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">26</span>; <span class="hljs-comment">// 26 - 51</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 非字母字符</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-普通数组"><a href="#5-普通数组" class="headerlink" title="5. 普通数组"></a>5. 普通数组</h3><p><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></p><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preSum</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> preSum;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(preSum &lt; <span class="hljs-number">0</span>)&#123;<br>                preSum = <span class="hljs-number">0</span>;<br>            &#125;<br>            preSum += nums[i];<br>            ans = Math.max(preSum, ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></p><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span>&#123;<br>                <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>]-o2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br>        ArrayList&lt;<span class="hljs-type">int</span>[]&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], right = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; intervals.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &gt; right)&#123;<br>                ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left, right&#125;);<br>                left = intervals[i][<span class="hljs-number">0</span>];<br>                right = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right = Math.max(right,intervals[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left, right&#125;);<br>        <span class="hljs-keyword">return</span> ans.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ans.size()][]);<br>    &#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></p><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        k %= nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, p2 =nums.length-<span class="hljs-number">1</span>-k,p3 = p2+<span class="hljs-number">1</span>, p4 = nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(p1 &lt;= (p2+p1)/<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[p1];<br>            nums[p1++] = nums[p2];<br>            nums[p2--] = temp;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(p3 &lt;= (p4+p3)/<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[p3];<br>            nums[p3++] = nums[p4];<br>            nums[p4--] = temp;<br>        &#125;<br>        p1 = <span class="hljs-number">0</span>;<br>        p4 = nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(p1&lt;=(p4+p1)/<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[p1];<br>            nums[p1++] = nums[p4];<br>            nums[p4--] = temp;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></p><p>给你一个整数数组 <code>nums</code>，返回 数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p><p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p><p>请 <strong>不要使用除法，</strong>且在 <code>O(n)</code> 时间复杂度内完成此题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] preProd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-type">int</span>[] postProd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        Arrays.fill(preProd, <span class="hljs-number">1</span>);<br>        Arrays.fill(postProd, <span class="hljs-number">1</span>);<br>        <br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; len;i++)&#123;<br>            preProd[i] = nums[i-<span class="hljs-number">1</span>] * preProd[i-<span class="hljs-number">1</span>];<br>            postProd[len-i-<span class="hljs-number">1</span>] = nums[len-i] * postProd[len-i];<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; len;i++)&#123;<br>            ans[i] = preProd[i] * postProd[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a></p><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">while</span>(i &lt; len)&#123;<br>            <span class="hljs-keyword">while</span>(nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i])&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>                nums[i] = nums[nums[i]-<span class="hljs-number">1</span>];<br>                nums[temp - <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; len;j++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[j] != j+<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> j+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len+<span class="hljs-number">1</span>;<br>        <br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="6-矩阵"><a href="#6-矩阵" class="headerlink" title="6. 矩阵"></a>6. 矩阵</h3><p><a href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵置零</a></p><p>给定一个 <code>*m* x *n*</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法<strong>。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">boolean</span>[] row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[matrix.length];<br>        <span class="hljs-type">boolean</span>[] col = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[matrix[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>)&#123;<br>                    row[i] = <span class="hljs-literal">true</span>;<br>                    col[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">if</span>(row[i])&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; n;j++)&#123;<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(col[i])&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; m;j++)&#123;<br>                    matrix[j][i] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></p><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">spiralOrder</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n-<span class="hljs-number">1</span>, top = <span class="hljs-number">0</span>, bottom = m-<span class="hljs-number">1</span>;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= bottom)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left;i &lt;= right;i++)&#123;<br>                ans.add(matrix[top][i]);<br>            &#125;<br>            top++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> top;j &lt;= bottom;j++)&#123;<br>                ans.add(matrix[j][right]);<br>            &#125;<br>            right--;<br>            <span class="hljs-keyword">if</span>(top &lt;= bottom)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right;i &gt;= left;i--)&#123;<br>                    ans.add(matrix[bottom][i]);<br>                &#125;<br>            &#125;<br>            bottom--;<br>            <span class="hljs-keyword">if</span>(left &lt;= right)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bottom;j &gt;= top;j--)&#123;<br>                    ans.add(matrix[j][left]);<br>                &#125;<br>            &#125;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="7-链表"><a href="#7-链表" class="headerlink" title="7. 链表"></a>7. 链表</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></p><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> headA;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> headB;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(t1 != <span class="hljs-literal">null</span>)&#123;<br>        len1++;<br>        t1 = t1.next;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(t2 != <span class="hljs-literal">null</span>)&#123;<br>        len2++;<br>        t2 = t2.next;<br>    &#125;<br><br>    len1 = len2 -len1;<br>    t1 = headA;<br>    t2 = headB;<br>    <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">while</span>(len1 &lt; <span class="hljs-number">0</span>)&#123;<br>            t1 = t1.next;<br>            len1++;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len1 &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">while</span>(len1 &gt; <span class="hljs-number">0</span>)&#123;<br>            t2 = t2.next;<br>            len1--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(t1 != <span class="hljs-literal">null</span> &amp;&amp; t2 != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(t1 == t2) <span class="hljs-keyword">return</span> t1;<br>        t1 = t1.next;<br>        t2 = t2.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.next;<br>        cur.next = pre;<br>        pre = cur;<br>        cur = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></p><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>        <span class="hljs-keyword">while</span>(fast.next!=<span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>)&#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>        &#125;<br>        <br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">reverseHead</span> <span class="hljs-operator">=</span> reverse(slow);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head.val != reverseHead.val)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            head = head.next;<br>            reverseHead = reverseHead.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = temp;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></p><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(fast == slow)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></p><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br><br>        <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>)&#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span>(fast == slow)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fast.next == <span class="hljs-literal">null</span> || fast.next.next == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        slow = head;<br>        <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>            slow = slow.next;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode p1, ListNode p2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">preHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> preHead;<br>        <span class="hljs-keyword">while</span>(p1 != <span class="hljs-literal">null</span> &amp;&amp; p2 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p2.val &lt;= p1.val)&#123;<br>               pre.next = p2;<br>               p2 = p2.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                pre.next = p1;<br>                p1 = p1.next;<br>            &#125;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p2 != <span class="hljs-literal">null</span>)&#123;<br>            pre.next = p2;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            pre.next = p1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> preHead.next;<br>    &#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></p><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> l1;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> l2;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> ans;<br>       <span class="hljs-keyword">while</span>(p1!=<span class="hljs-literal">null</span> &amp;&amp; p2 !=<span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> c + p1.val + p2.val;<br>           c = temp/<span class="hljs-number">10</span>;<br>           temp %= <span class="hljs-number">10</span>;<br>           curr.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(temp);<br>           p1 = p1.next;<br>           p2 = p2.next;<br>           curr = curr.next;<br>       &#125;<br>       <span class="hljs-keyword">while</span>(p1 != <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> c + p1.val;<br>           c = temp/<span class="hljs-number">10</span>;<br>           temp %= <span class="hljs-number">10</span>;<br>           curr.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(temp);<br>           p1 = p1.next;<br>           curr = curr.next;<br>       &#125;<br>       <span class="hljs-keyword">while</span>(p2 != <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> c + p2.val;<br>           c = temp/<span class="hljs-number">10</span>;<br>           temp %= <span class="hljs-number">10</span>;<br>           curr.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(temp);<br>           p2 = p2.next;<br>           curr = curr.next;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(c != <span class="hljs-number">0</span>)&#123;<br>           curr.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(c);<br>       &#125;<br>       <span class="hljs-keyword">return</span> ans.next;<br>   &#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></p><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    dummy.next = head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummy;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> dummy;<br><br>    <span class="hljs-keyword">while</span>(n--&gt;<span class="hljs-number">0</span>)&#123;<br>        fast = fast.next;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span>)&#123;<br>        pre = slow;<br>        fast = fast.next;<br>        slow = slow.next;<br>    &#125;<br>    pre.next = slow.next;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></p><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        dummy.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span>(pre.next != <span class="hljs-literal">null</span> &amp;&amp; pre.next.next != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> pre.next;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> pre.next.next;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> p2.next;<br><br>            pre.next = p2;<br>            p2.next = p1;<br>            p1.next = temp;<br>            <br>            pre = p1;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">138. 随机链表的复制</a></p><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a><strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。</strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p><p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p><p>返回复制链表的头节点。</p><p>用一个由 <code>n</code> 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p><ul><li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li><li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code> 。</li></ul><p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(Node head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    Map&lt;Node, Node&gt; m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">null</span>)&#123;<br>        m.put(curr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(curr.val));<br>        curr = curr.next;<br>    &#125;<br><br>    curr = head;<br>    <span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">null</span>)&#123;<br>        m.get(curr).next = m.get(curr.next);<br>        m.get(curr).random = m.get(curr.random);<br>        curr = curr.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> m.get(head);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></p><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        ArrayList&lt;ListNode&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(p.val);<br>            list.add(temp);<br>            p = p.next;<br>        &#125;<br>        Collections.sort(list,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;ListNode&gt;()&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(ListNode p1, ListNode p2)</span> &#123;<br><span class="hljs-keyword">return</span> p1.val - p2.val;<br>&#125;<br>&#125;);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">for</span>(ListNode q : list)&#123;<br>            h.next = q;<br>            h = h.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// solution 2</span><br><span class="hljs-comment">// merge sort</span><br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></p><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">DLinkedNode</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> val;<br>        DLinkedNode prev;<br>        DLinkedNode next;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DLinkedNode</span><span class="hljs-params">()</span>&#123;&#125;;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DLinkedNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span>&#123;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> DLinkedNode head;<br>    <span class="hljs-keyword">private</span> DLinkedNode tail;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.size = <span class="hljs-number">0</span>;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLinkedNode</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLinkedNode</span>();<br>        head.next = tail;<br>        tail.prev = head;<br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span>(!cache.containsKey(key))&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> cache.get(key);<br>        moveToHead(node);<br>        <span class="hljs-keyword">return</span> node.val;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-keyword">if</span>(cache.containsKey(key))&#123;<br>            <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> cache.get(key);<br>            node.val = val;<br>            moveToHead(node);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLinkedNode</span>(key,val);<br>            cache.put(key,node);<br>            addToHead(node);<br>            <span class="hljs-built_in">this</span>.size++;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.size &gt; <span class="hljs-built_in">this</span>.capacity)&#123;<br>                <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> removeTail();<br>                cache.remove(t.key);<br>                size--;<br>            &#125; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToHead</span><span class="hljs-params">(DLinkedNode node)</span>&#123;<br>        node.prev = head;<br>        node.next = head.next;<br>        head.next.prev = node;<br>        head.next = node;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(DLinkedNode node)</span> &#123;<br>        node.prev.next = node.next;<br>        node.next.prev = node.prev;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToHead</span><span class="hljs-params">(DLinkedNode node)</span>&#123;<br>        remove(node);<br>        addToHead(node);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> DLinkedNode <span class="hljs-title function_">removeTail</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> tail.prev;<br>        remove(node);<br><br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-二叉树"><a href="#8-二叉树" class="headerlink" title="8. 二叉树"></a>8. 二叉树</h3><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// solution 1 递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        inorder(root);<br><br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        inorder(root.left);<br>        list.add(root.val);<br>        inorder(root.right);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//solution 2 迭代</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// inorder(root);</span><br><br>        <span class="hljs-comment">// return list;</span><br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">null</span> || !stack.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">null</span>)&#123;<br>                stack.push(root);<br>                root = root.left;<br>            &#125;<br>            root = stack.pop();<br>            list.add(root.val);<br>            root = root.right;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Solution 1 递归 dfs</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Solution 2 BFS</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        q.offer(root);<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> q.size();<br>            <span class="hljs-keyword">while</span>(size &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> q.poll();<br>                <span class="hljs-keyword">if</span>(temp.left != <span class="hljs-literal">null</span>)&#123;<br>                    q.offer(temp.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(temp.right != <span class="hljs-literal">null</span>)&#123;<br>                   q.offer(temp.right);<br>                &#125;<br>                size--;<br>            &#125;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></p><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> root.left;<br>        root.left = root.right;<br>        root.right = temp;<br>        invertTree(root.left);<br>        invertTree(root.right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></p><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-keyword">return</span> check(root, root);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(TreeNode u, TreeNode v)</span>&#123;<br>        <span class="hljs-keyword">if</span>(u == <span class="hljs-literal">null</span> &amp;&amp; v == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(u == <span class="hljs-literal">null</span> &amp;&amp; v != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(v == <span class="hljs-literal">null</span> &amp;&amp; u != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> u.val == v.val &amp;&amp; check(u.left, v.right) &amp;&amp; check(u.right, v.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></p><p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p><p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p><p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> ans;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        ans = <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        maxDepth(root);<br>        <span class="hljs-keyword">return</span> ans-<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode t)</span>&#123;<br>        <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// if(t.left == null &amp;&amp; t.right == null)&#123;</span><br>        <span class="hljs-comment">//     return 1;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">L</span> <span class="hljs-operator">=</span> maxDepth(t.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">R</span> <span class="hljs-operator">=</span> maxDepth(t.right);<br>        ans = Math.max(ans, L+R+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> Math.max(L,R)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        &#125;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        q.offer(root);<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            List&lt;TreeNode&gt; nodeTemp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q.poll();<br>                nodeTemp.add(t);<br>                temp.add(t.val);<br>            &#125;<br>            <span class="hljs-keyword">for</span>(TreeNode t: nodeTemp)&#123;<br>                <span class="hljs-keyword">if</span>(t.left!=<span class="hljs-literal">null</span>)&#123;<br>                    q.offer(t.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(t.right!=<span class="hljs-literal">null</span>)&#123;<br>                    q.offer(t.right);<br>                &#125;<br>            &#125;<br>            ans.add(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></p><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 平衡 二叉搜索树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> nums.length/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// int[] left = new int[mid];</span><br>        <span class="hljs-comment">// int[] right = new int[mid];</span><br>        <span class="hljs-comment">// System.arraycopy(left, 0, nums, 0, mid);</span><br>        <span class="hljs-comment">// if(nums.length%2 == 0)&#123;</span><br>        <span class="hljs-comment">//     System.arraycopy(right, 0,nums, mid+1, mid-1);</span><br>        <span class="hljs-comment">// &#125;else&#123;</span><br>        <span class="hljs-comment">//     System.arraycopy(right, 0,nums, mid+1, mid);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[mid]);<br>        root.left = sortedArrayToBST(Arrays.copyOfRange(nums,<span class="hljs-number">0</span>,mid));<br>        root.right = sortedArrayToBST(Arrays.copyOfRange(nums,mid+<span class="hljs-number">1</span>,nums.length));<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> lowBound, <span class="hljs-type">long</span> highBound)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">if</span>(root.val &lt;= lowBound || root.val &gt;= highBound)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> isValidBST(root.left, lowBound, root.val);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> isValidBST(root.right, root.val, highBound);<br>        <span class="hljs-keyword">return</span> l &amp;&amp; r;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第 K 小的元素</a></p><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 小的元素（从 1 开始计数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 中序遍历二叉搜索树可以得到有序序列，在遍历中增加rank变量，当rank == k时即为答案</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rank</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        findKth(root,k);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">findKth</span><span class="hljs-params">(TreeNode root,<span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        findKth(root.left, k);<br>        rank++;<br>        <span class="hljs-keyword">if</span>(rank == k)&#123;<br>            ans = root.val;<br>        &#125;<br>        findKth(root.right,k);<br>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></p><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 层序遍历，只保留最右节点</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        q.offer(root);<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> q.size();<br>            <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> q.poll();<br>                <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>)&#123;<br>                    ans.add(temp.val);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(temp.left != <span class="hljs-literal">null</span>)&#123;<br>                    q.offer(temp.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(temp.right != <span class="hljs-literal">null</span>)&#123;<br>                    q.offer(temp.right);<br>                &#125;<br>                len--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></p><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        flatten(root.left);<br>        flatten(root.right);<br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> root.right;<br>            root.right = root.left;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root.right;<br>            <span class="hljs-keyword">while</span>(p.right != <span class="hljs-literal">null</span>)&#123;<br>                p = p.right;<br>            &#125;<br>            p.right = temp;<br>            root.left = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// solution 1 使用中序遍历的值作为key，减少每次查询位置的消耗</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; valOfInOrder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> preorder.length;<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; len;i++)&#123;<br>            valOfInOrder.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> helper(preorder, <span class="hljs-number">0</span>, len-<span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, len-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder,<span class="hljs-type">int</span> preBegin, <span class="hljs-type">int</span> preEnd, </span><br><span class="hljs-params">                            <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inBegin, <span class="hljs-type">int</span> inEnd)</span>&#123;<br>        <span class="hljs-keyword">if</span>(preBegin &gt; preEnd)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preBegin]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootval</span> <span class="hljs-operator">=</span> preorder[preBegin];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootIndex</span> <span class="hljs-operator">=</span> valOfInOrder.get(rootval);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftSize</span> <span class="hljs-operator">=</span> rootIndex - inBegin;<br><br>        root.left = helper(preorder, preBegin+<span class="hljs-number">1</span>, preBegin+leftSize, inorder, inBegin, rootIndex-<span class="hljs-number">1</span>);<br>        root.right = helper(preorder, preBegin+leftSize+<span class="hljs-number">1</span>, preEnd, inorder, rootIndex+<span class="hljs-number">1</span>, inEnd);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></p><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p><p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// solution 1 前缀和</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        Map&lt;Long, Integer&gt; prefix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        prefix.put(<span class="hljs-number">0L</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> helper(root, prefix, <span class="hljs-number">0</span>, targetSum);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root, Map&lt;Long, Integer&gt; prefix ,<span class="hljs-type">long</span> curr, <span class="hljs-type">int</span> targetSum)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        curr += root.val;<br>        ans = prefix.getOrDefault(curr-targetSum, <span class="hljs-number">0</span>);<br>        prefix.put(curr, prefix.getOrDefault(curr,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        ans += helper(root.left, prefix, curr, targetSum);<br>        ans += helper(root.right, prefix, curr, targetSum);<br>        prefix.put(curr, prefix.getOrDefault(curr,<span class="hljs-number">0</span>)-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><span class="hljs-comment">// solution 2 DFS遍历所有节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> checkSum(root, targetSum);<br>        ans += pathSum(root.left, targetSum);<br>        ans += pathSum(root.right, targetSum); <br><br>        <span class="hljs-keyword">return</span> ans;  <br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">checkSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> targetSum)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root.val == targetSum) &#123;<br>            ret++;<br>        &#125;<br>        ret += checkSum(root.left, targetSum-root.val);<br>        ret += checkSum(root.right, targetSum-root.val);<br><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> TreeNode ans;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        dfs(root, p, q);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">lson</span> <span class="hljs-operator">=</span> dfs(root.left, p, q);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">rson</span> <span class="hljs-operator">=</span> dfs(root.right,p , q);<br><br>        <span class="hljs-keyword">if</span>( (lson &amp;&amp; rson) || ((root.val == p.val || root.val == q.val) &amp;&amp; (lson || rson)))&#123;<br>            ans = root;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lson || rson || (root.val == p.val || root.val == q.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-图论"><a href="#9-图论" class="headerlink" title="9. 图论"></a>9. 图论</h3><p><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></p><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">if</span>(!inArea(grid, i, j))&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>        <br>        dfs(grid, i, j-<span class="hljs-number">1</span>);<br>        dfs(grid, i, j+<span class="hljs-number">1</span>);<br>        dfs(grid, i-<span class="hljs-number">1</span>, j);<br>        dfs(grid, i+<span class="hljs-number">1</span>, j);<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">if</span>(grid == <span class="hljs-literal">null</span> || grid.length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; grid.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; grid[<span class="hljs-number">0</span>].length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    ans++;<br>                    dfs(grid, i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">inArea</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <br>        <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; i &lt; grid.length)&#123;<br>            <span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-number">0</span> &amp;&amp; j &lt; grid[<span class="hljs-number">0</span>].length)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a><br>在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：</p><p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。</p><p>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">orangeNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rottenOrangeNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    Queue&lt;<span class="hljs-type">int</span>[]&gt; startPoint = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">orangesRotting</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">if</span>(grid == <span class="hljs-literal">null</span> || grid[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] != <span class="hljs-number">0</span>) orangeNum++;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">2</span>) &#123;<br>                    rottenOrangeNum++;<br>                    startPoint.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i,j&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> bfs(grid);<br>        <span class="hljs-keyword">if</span>(orangeNum == rottenOrangeNum) <span class="hljs-keyword">return</span> ans == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : ans-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!startPoint.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> startPoint.size();<br>            <span class="hljs-keyword">while</span>(size--&gt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span>[] pairs = startPoint.poll();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> pairs[<span class="hljs-number">0</span>], j = pairs[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(inArea(grid, i+<span class="hljs-number">1</span> ,j)) &#123;<br>                    grid[i+<span class="hljs-number">1</span>][j] = <span class="hljs-number">2</span>;<br>                    rottenOrangeNum++;<br>                    startPoint.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i+<span class="hljs-number">1</span>,j&#125;);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(inArea(grid, i-<span class="hljs-number">1</span> ,j)) &#123;<br>                    grid[i-<span class="hljs-number">1</span>][j] = <span class="hljs-number">2</span>;<br>                    rottenOrangeNum++;<br>                    startPoint.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i-<span class="hljs-number">1</span>,j&#125;);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(inArea(grid, i ,j+<span class="hljs-number">1</span>)) &#123;<br>                    grid[i][j+<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>                    rottenOrangeNum++;<br>                    startPoint.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i,j+<span class="hljs-number">1</span>&#125;);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(inArea(grid, i ,j-<span class="hljs-number">1</span>)) &#123;<br>                    grid[i][j-<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>                    rottenOrangeNum++;<br>                    startPoint.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i,j-<span class="hljs-number">1</span>&#125;);<br>                &#125;<br>            &#125;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">inArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; grid.length)&#123;<br>            <span class="hljs-keyword">if</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; grid[<span class="hljs-number">0</span>].length)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></p><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p><ul><li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; numCourses;i++)&#123;<br>            graph.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] pair : prerequisites)&#123;<br>            graph.get(pair[<span class="hljs-number">1</span>]).add(pair[<span class="hljs-number">0</span>]);<br>            in[pair[<span class="hljs-number">0</span>]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; numCourses;i++)&#123;<br>            <span class="hljs-keyword">if</span>(in[i] == <span class="hljs-number">0</span>)&#123;<br>                q.offer(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">visited</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            visited++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s: graph.get(q.poll()))&#123;<br>                in[s]--;<br>                <span class="hljs-keyword">if</span>(in[s] == <span class="hljs-number">0</span>) q.offer(s);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> visited == numCourses;<br>    &#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></p><p>**<a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a>**（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    Node[] son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-type">boolean</span> end;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">private</span> Node root;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: word.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(curr.son[c-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)&#123;<br>                curr.son[c-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>            &#125;<br>            curr = curr.son[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        curr.end = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: word.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(curr.son[c-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            curr = curr.son[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(curr.end == <span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: prefix.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(curr.son[c-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            curr = curr.son[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>       <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-回溯"><a href="#10-回溯" class="headerlink" title="10. 回溯"></a>10. 回溯</h3><p><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></p><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以按任意顺序 返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums);<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() == nums.length)&#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!path.contains(nums[i]))&#123;<br>                path.add(nums[i]);<br>                backtracking(nums);<br>                path.remove(path.size()-<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/subsets/">78.子集</a><br>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; subset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>        backtracking(<span class="hljs-number">0</span>, nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> count, <span class="hljs-type">int</span>[] nums)</span>&#123;<br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(subset));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> count;i &lt; nums.length;i++)&#123;<br>            subset.add(nums[i]);<br>            backtracking(i+<span class="hljs-number">1</span>, nums);<br>            subset.remove(subset.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></p><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    HashMap&lt;Character, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    Map&lt;Character, String&gt; phoneMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character, String&gt;() &#123;&#123;<br>        put(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>        put(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&quot;def&quot;</span>);<br>        put(<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&quot;ghi&quot;</span>);<br>        put(<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br>        put(<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&quot;mno&quot;</span>);<br>        put(<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>);<br>        put(<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&quot;tuv&quot;</span>);<br>        put(<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>);<br>    &#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-keyword">if</span>(digits.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;<br>        <br>        backtracking(<span class="hljs-number">0</span>, digits);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> index, String digits)</span>&#123;<br>        <span class="hljs-keyword">if</span>(index == digits.length())&#123;<br>            ans.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: phoneMap.get(digits.charAt(index)).toCharArray())&#123;<br>            sb.append(c);<br>            backtracking(index+<span class="hljs-number">1</span>, digits);<br>            sb.deleteCharAt(sb.length()-<span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></p><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        backtracking(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, target, candidates);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] candidates)</span>&#123;<br>        <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum == target)&#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(temp));<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index;i &lt; candidates.length;i++)&#123;<br>            temp.add(candidates[i]);<br>            backtracking(sum+candidates[i], i, target, candidates);<br>            temp.remove(temp.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a><br>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        backtracking(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span>(l &gt; n || l &lt; r)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(sb.length() == <span class="hljs-number">2</span>*n)&#123;<br>            ans.add(sb.toString());<br>        &#125;<br><br>        sb.append(<span class="hljs-string">&quot;(&quot;</span>);<br>        backtracking(l+<span class="hljs-number">1</span>, r, n);<br>        sb.deleteCharAt(sb.length()-<span class="hljs-number">1</span>);<br>        sb.append(<span class="hljs-string">&quot;)&quot;</span>);<br>        backtracking(l,r+<span class="hljs-number">1</span>, n);<br>        sb.deleteCharAt(sb.length()-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a><br>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-keyword">if</span>(board == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length, n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(board[i][j] == word.charAt(<span class="hljs-number">0</span>))&#123;<br>                    dfs(i,j,<span class="hljs-number">0</span>,word,board,visited);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> len, String word, <span class="hljs-type">char</span>[][] board, <span class="hljs-type">boolean</span>[][] visited)</span>&#123;<br>        <span class="hljs-keyword">if</span>(len == word.length())&#123;<br>            ans = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= board.length || j&lt;<span class="hljs-number">0</span> || j &gt;= board[<span class="hljs-number">0</span>].length)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(visited[i][j] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">return</span>; <br>        <span class="hljs-keyword">if</span>(board[i][j] != word.charAt(len))&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        dfs(i+<span class="hljs-number">1</span>,j,len+<span class="hljs-number">1</span>,word,board,visited);<br>        dfs(i-<span class="hljs-number">1</span>,j,len+<span class="hljs-number">1</span>,word,board,visited);<br>        dfs(i,j+<span class="hljs-number">1</span>,len+<span class="hljs-number">1</span>,word,board,visited);<br>        dfs(i,j-<span class="hljs-number">1</span>,len+<span class="hljs-number">1</span>,word,board,visited);<br>        visited[i][j] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></p><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-keyword">if</span>(board == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length, n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(board[i][j] == word.charAt(<span class="hljs-number">0</span>))&#123;<br>                    dfs(i,j,<span class="hljs-number">0</span>,word,board,visited);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> len, String word, <span class="hljs-type">char</span>[][] board, <span class="hljs-type">boolean</span>[][] visited)</span>&#123;<br>        <span class="hljs-keyword">if</span>(len == word.length())&#123;<br>            ans = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= board.length || j&lt;<span class="hljs-number">0</span> || j &gt;= board[<span class="hljs-number">0</span>].length)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(visited[i][j] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">return</span>; <br>        <span class="hljs-keyword">if</span>(board[i][j] != word.charAt(len))&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        dfs(i+<span class="hljs-number">1</span>,j,len+<span class="hljs-number">1</span>,word,board,visited);<br>        dfs(i-<span class="hljs-number">1</span>,j,len+<span class="hljs-number">1</span>,word,board,visited);<br>        dfs(i,j+<span class="hljs-number">1</span>,len+<span class="hljs-number">1</span>,word,board,visited);<br>        dfs(i,j-<span class="hljs-number">1</span>,len+<span class="hljs-number">1</span>,word,board,visited);<br>        visited[i][j] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></p><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些 子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; par = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        backtracking(<span class="hljs-number">0</span>, s);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> startIndex, String s)</span>&#123;<br>        <span class="hljs-keyword">if</span>(startIndex == s.length())&#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(par));<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; s.length();i++)&#123;<br>            <span class="hljs-keyword">if</span>(isPalindrome(startIndex, i, s))&#123;<br>                par.add(s.substring(startIndex, i+<span class="hljs-number">1</span>));<br>                backtracking(i+<span class="hljs-number">1</span>, s);<br>                par.remove(par.size()-<span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, String s)</span>&#123;<br>        <span class="hljs-keyword">while</span>(start &lt; end)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(start) != s.charAt(end))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            start++;<br>            end--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>实习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-Advance</title>
    <link href="/2025/01/11/Java-Advance/"/>
    <url>/2025/01/11/Java-Advance/</url>
    
    <content type="html"><![CDATA[<h1 id="Java进阶"><a href="#Java进阶" class="headerlink" title="Java进阶"></a>Java进阶</h1><h2 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1. 多线程"></a>1. 多线程</h2><h3 id="1-1-Java创建多线程的方式"><a href="#1-1-Java创建多线程的方式" class="headerlink" title="1.1 Java创建多线程的方式"></a>1.1 Java创建多线程的方式</h3><p><code>Java</code>创建线程有很多种方式啊，像实现<code>Runnable、Callable</code>接口、继承<code>Thread</code>类、创建线程池等等，不过这些方式并没有真正创建出线程，严格来说，<code>Java</code>就只有一种方式可以创建线程，那就是通过<code>new Thread().start()</code>创建。<br>而所谓的<code>Runnable、Callable……</code>对象，这仅仅只是线程体，也就是提供给线程执行的任务，并不属于真正的<code>Java</code>线程，它们的执行，最终还是需要依赖于<code>new Thread()</code></p><h4 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a><a href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA">一句话简单了解堆和方法区</a></h4><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h4 id="Synchronized如何提升性能"><a href="#Synchronized如何提升性能" class="headerlink" title="Synchronized如何提升性能"></a>Synchronized如何提升性能</h4><p>首先对于线程不安全的操作，我们会使用synchronized进行封装，保证操作的原子性。但是如果使用</p><p><code>synchronized(this)</code>粒度太大，我们可以对不同粒度的资源进行加锁，在不影响线程安全的情况下，我们可以使用<code>synchronized(String)</code>来对共享资源加锁。这样可以提升性能。但是，String放在JVM的常量池中，如果有其他的服务线程来使用这个常量同样也会被阻塞，为了解决这个问题，我们可以使用ConcurrentHashMap来获取常量资源的锁对象，从而实现更细粒度的加锁。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis</title>
    <link href="/2025/01/07/Mybatis/"/>
    <url>/2025/01/07/Mybatis/</url>
    
    <content type="html"><![CDATA[<p>#{}和${}的区别<br>在MyBatis中，#{}和${}都是用于在SQL语句中进行参数的传递，但它们之间有一些重要的区别。<br>#{}用于预编译参数，MyBatis在将SQL语句发送到数据库之前，会使用PreparedStatement参数化查询的方式来处理#{}中的内容，这样可以有效防止SQL注入攻击，并且能够正确地处理特殊字符转义。因此，建议在编写SQL语句时使用#{}来引用参数。<br>${}则是直接进行字符串替换，不会进行预编译，而是将其中的内容直接拼接到sql语句中。这种方式可能会存在sql注入的风险，因此不建议在编写sql语句时使用则是直接进行字符串替换，不会进行预编译，而是将其中的内容直接拼接到SQL语句中。这种方式可能会存在SQL注入的风险，因此不建议在编写SQL语句时使用{}来引用参数，除非你非常清楚自己在做什么并且能够确保参数的安全性。<br>因此，总的来说，推荐在MyBatis中使用#{}来引用参数，以确保SQL的安全性和可读性。</p><p>作者：沉着的码农<br>链接：<a href="https://juejin.cn/post/7314120541720150068">https://juejin.cn/post/7314120541720150068</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <categories>
      
      <category>database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2025/01/06/Spring/"/>
    <url>/2025/01/06/Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-开发"><a href="#Spring-开发" class="headerlink" title="Spring 开发"></a>Spring 开发</h1><h2 id="1-Ioc容器"><a href="#1-Ioc容器" class="headerlink" title="1. Ioc容器"></a>1. Ioc容器</h2><h3 id="1-1-Ioc原理"><a href="#1-1-Ioc原理" class="headerlink" title="1.1 Ioc原理"></a>1.1 Ioc原理</h3>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql Base</title>
    <link href="/2025/01/06/Mysql-Base/"/>
    <url>/2025/01/06/Mysql-Base/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="1-锁"><a href="#1-锁" class="headerlink" title="1. 锁"></a>1. 锁</h2><h3 id="1-1-分类"><a href="#1-1-分类" class="headerlink" title="1.1 分类"></a>1.1 分类</h3><style>.sjtgfyhngfux{zoom:50%;}</style><img src="/2025/01/06/Mysql-Base/image-20250305102930583.png" class="sjtgfyhngfux" alt="image-20250305102930583"><h4 id="1-1-1-按粒度分类"><a href="#1-1-1-按粒度分类" class="headerlink" title="1.1.1 按粒度分类"></a>1.1.1 按粒度分类</h4><p>（1）全局锁 </p><ul><li>读锁</li><li>写锁</li><li>用处</li></ul><p>（2）表锁</p><p>（3）行锁</p><h4 id="1-1-2-按模式分类"><a href="#1-1-2-按模式分类" class="headerlink" title="1.1.2 按模式分类"></a>1.1.2 按模式分类</h4><p>（1）乐观锁</p><p>（2）悲观锁</p><h4 id="1-1-3-属性分类"><a href="#1-1-3-属性分类" class="headerlink" title="1.1.3 属性分类"></a>1.1.3 属性分类</h4><p>（1）共享锁（读锁）</p><p>（2）排他锁（写锁 ）</p><h4 id="1-1-4-状态分类"><a href="#1-1-4-状态分类" class="headerlink" title="1.1.4 状态分类"></a>1.1.4 状态分类</h4><p>（1）意向共享锁</p><p>（2）意向排他锁</p><h4 id="1-1-5-算法分类"><a href="#1-1-5-算法分类" class="headerlink" title="1.1.5 算法分类"></a>1.1.5 算法分类</h4><p>（1）间隙锁</p><p>（2）记录锁</p><p>（3）临键锁</p><h2 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h2><h2 id="3-事务"><a href="#3-事务" class="headerlink" title="3. 事务"></a>3. 事务</h2>]]></content>
    
    
    <categories>
      
      <category>database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot(2)</title>
    <link href="/2024/09/26/Spring-Boot-2/"/>
    <url>/2024/09/26/Spring-Boot-2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot(1)</title>
    <link href="/2024/09/24/Spring-Boot-1/"/>
    <url>/2024/09/24/Spring-Boot-1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-SpringBoot-基础"><a href="#1-SpringBoot-基础" class="headerlink" title="1. SpringBoot 基础"></a>1. SpringBoot 基础</h1><h2 id="1-SpringBoot-配置"><a href="#1-SpringBoot-配置" class="headerlink" title="1. SpringBoot 配置"></a>1. SpringBoot 配置</h2><p><a href="https://docs.spring.io/spring-boot/appendix/application-properties/index.html">https://docs.spring.io/spring-boot/appendix/application-properties/index.html</a></p><h3 id="1-Properties-配置文件"><a href="#1-Properties-配置文件" class="headerlink" title="1. Properties 配置文件"></a>1. Properties 配置文件</h3><p>层级关系通过‘.‘ 分隔</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.application.name</span> = <span class="hljs-string">BigEvent</span><br><span class="hljs-attr">server.servlet.context-path</span> = <span class="hljs-string">/start</span><br><span class="hljs-attr">server.port</span> = <span class="hljs-string">9090</span><br></code></pre></td></tr></table></figure><h3 id="2-yaml-配置文件（更为常见，结构清晰）：层级通过换行和缩进实现"><a href="#2-yaml-配置文件（更为常见，结构清晰）：层级通过换行和缩进实现" class="headerlink" title="2. yaml 配置文件（更为常见，结构清晰）：层级通过换行和缩进实现"></a>2. yaml 配置文件（更为常见，结构清晰）：层级通过换行和缩进实现</h3><p>配置信息方法</p><ul><li>三方技术配置信息<ul><li>如Redis、Mybatis配置文件</li></ul><p></p></li><li>自定义配置信息<ul><li>将配置信息写入yml配置文件</li></ul></li></ul><p>配置信息获取</p><p>@Value（“${键名}”）   </p><ul><li>通过@Value注解获取值</li><li>如果需要获取的值太多，使用@ConfigurationProperties（prefix&#x3D;“前缀”）</li><li>保证名称一致</li></ul><h3 id="3-整合mybatis"><a href="#3-整合mybatis" class="headerlink" title="3. 整合mybatis"></a>3. 整合mybatis</h3><ul><li><p>在pom.xml中添加依赖</p></li><li><p>在application.yml中设置数据库相关信息</p></li><li><p>添加Mapper、添加pojo实体类</p></li><li><p>将映射语句可以基于注解（简单）或XML进行配置</p></li><li><blockquote><p>[!NOTE]</p><p><strong>PO</strong> 用于表示数据库中的数据模型，<strong>VO</strong> 用于表示传递给前端的数据模型，DAO 用于访问数据库，BO 用于表示业务逻辑实体，<strong>DTO</strong> 用于在不同层之间传输数据，<strong>POJO</strong> 用于表示简单的Java 对象。</p><p><strong>PO</strong>：persistent object持久化对象，PO 常常被用作 DAO（数据访问对象）层的数据模型，以及和数据库交互的对象</p><p><strong>VO</strong>：value object值对象，用于展示和传递给前端界面</p><p><strong>DAO</strong>：Data Access Object数据访问对象，访问数据库，DAO 层负责将数据库中的数据转换成 Java 对象，并将 Java 对象的数据保存到数据库中。</p><p><strong>BO</strong>：Bussiness Object业务对象，在 Java 开发中，BO 对象通常由 Service 层或者 Facade 层来创建，并且它们通常包含一些业务逻辑的实现，以及对数据的操作。BO 通常是针对具体的业务场景而设计的，它们是具有业务含义的实体。</p><p><strong>DTO</strong>：DTO 通常用于在不同层之间传输数据，例如在 Controller 层和 Service 层之间传输数据。DTO 对象通常包含一些简单的数据结构，例如字符串、整数、布尔值等等。在 Java 开发中，DTO 对象通常由 Controller 层或者 Service 层来创建，并且它们通常是不可变的。</p><p><strong>POJO</strong>： 是“Plain Old Java Object”的缩写，意为“简单的 Java 对象”。POJO 通常指的是一个没有任何限制、继承或实现特定接口的普通 Java 对象。POJO 对象通常是一种轻量级的 Java 对象，没有任何框架或者注解的依赖。在 Java 开发中，POJO 对象通常用于表示简单的数据模型或者数据传输对象。</p></blockquote></li></ul><h2 id="2-SpringBoot-Bean管理"><a href="#2-SpringBoot-Bean管理" class="headerlink" title="2. SpringBoot Bean管理"></a>2. SpringBoot Bean管理</h2><h3 id="2-1-Bean-扫描"><a href="#2-1-Bean-扫描" class="headerlink" title="2.1 Bean 扫描"></a>2.1 Bean 扫描</h3><p>@SpringBootApplication 注解：组合注解</p><ul><li>SpringBootApplication</li><li>EnableAutoConfiguration</li><li>CompoentScan：默认扫描路径是当前启动类下包以及子包，若想扫描其他路径可以，手动添加@CompoentScan(basePackages&#x3D;”path”)</li></ul><h3 id="2-2-Bean-注册"><a href="#2-2-Bean-注册" class="headerlink" title="2.2 Bean 注册"></a>2.2 Bean 注册</h3><table><thead><tr><th>注解</th><th>说明</th><th>位置</th></tr></thead><tbody><tr><td>@Component</td><td>声明Bean的基础注解</td><td>不属于以下三类时，使用此注解</td></tr><tr><td>@Controller</td><td>@Component的衍生注解</td><td>标注在控制器类上</td></tr><tr><td>@Service</td><td>@Component的衍生注解</td><td>标注在业务类上</td></tr><tr><td>@Repository</td><td>@Component的衍生注解</td><td>标注在数据访问类上</td></tr></tbody></table><ul><li>如果要注册Bean对象来自于第三方，无法使用@Component等注解进行声明Bean的<ul><li>使用@Bean</li><li>使用@Import</li></ul></li></ul><h4 id="2-2-1-Bean"><a href="#2-2-1-Bean" class="headerlink" title="2.2.1 @Bean"></a>2.2.1 @Bean</h4><p><strong>（不建议在启动类里操作）</strong>使用三方对象时，在启动类里调用该对象的构造方法，并添加@Bean注解，将方法返回值交给IOC容器管理，成为IOC容器的bean对象</p><p><img src="/2024/09/24/Spring-Boot-1/image-20240926174352195.png" alt="Bean注解"></p><p>如何获取该对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SpringApplication.run() 方法将Spring初始化好的容器返回，通过context获取</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(SpringbootRegisterApplication.class, args);<br><br><span class="hljs-type">Country</span> <span class="hljs-variable">country</span> <span class="hljs-operator">=</span> context.getBean(Country.class);<br></code></pre></td></tr></table></figure><p><strong>（建议实现配置类）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 放入启动类的子包里</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonConfig</span> &#123;<br><br><span class="hljs-comment">//注入Bean对象，对象默认名字是方法名</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Country <span class="hljs-title function_">country</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Country</span>();<br>&#125;<br>  <br>  <span class="hljs-comment">//可以通过后面(&quot;name&quot;)来指定方法名</span><br>  <span class="hljs-comment">// 如果方法内部需要用到ioc容器中存在的bean对象，那么只需要在方法上声明即可，Spring会自动注入</span><br>  <span class="hljs-meta">@Bean(&quot;name&quot;)</span><br>  <span class="hljs-keyword">public</span> Province <span class="hljs-title function_">province</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Province</span>()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-Import"><a href="#2-2-2-Import" class="headerlink" title="2.2.2 @Import"></a>2.2.2 @Import</h4><ul><li>导入配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(CommonConfig.class)</span><br><br><span class="hljs-meta">@import(&#123;xxx.class, xxy.class&#125;)</span><br><br><span class="hljs-meta">@import()</span><br></code></pre></td></tr></table></figure><ul><li>导入ImportSelector接口实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportSelector</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata)&#123;<br>    <span class="hljs-comment">// 类名在配置文件中写</span><br>    List&lt;String&gt; imports = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> CommonImportSelector.class.getClasssLoader().getResourceAsStream(<span class="hljs-string">&quot;common.import&quot;</span>);<br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>    <br>    <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">while</span>((line = br.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>      imports.add(line);<br>    &#125;<br>    br.close();  <span class="hljs-comment">// 放入finally</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">import</span>.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>])；<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//在import时</span><br><span class="hljs-meta">@Import(CommonImportSelector.class)</span><br></code></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-params">#</span> 配置文件实现<br><span class="hljs-params">#</span> common.imports<br><br>类名1<br>类名2<br>...<br></code></pre></td></tr></table></figure><ul><li>组合注解</li><li>使用EnableXxxx注解，封装@Import注解</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 添加需要的注解 </span><br>publish <span class="hljs-class"><span class="hljs-keyword">@interface</span> 注解名()</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-3-注册条件"><a href="#2-2-3-注册条件" class="headerlink" title="2.2.3 注册条件"></a>2.2.3 注册条件</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Autowire</span><br><span class="hljs-variable">@Value</span> <span class="hljs-comment">// 可以放在参数列表中，用于读取配置文件的值</span><br><span class="hljs-variable">@Conditional</span> <span class="hljs-comment">//包括一系列衍生注解</span><br></code></pre></td></tr></table></figure><p><img src="/2024/09/24/Spring-Boot-1/image-20240930103631530.png" alt="image-20240930103631530"></p><h2 id="3-SpringBoot-自动配置原理"><a href="#3-SpringBoot-自动配置原理" class="headerlink" title="3. SpringBoot 自动配置原理"></a>3. SpringBoot 自动配置原理</h2><h3 id="3-1-自动装配"><a href="#3-1-自动装配" class="headerlink" title="3.1  自动装配"></a>3.1  自动装配</h3><p>约定大于配置，在boot启动后，起步依赖将bean对象自动注入到IOC容器中</p><ul><li>提供一个配置类</li><li>提供一个该类的自动配置类</li><li>提供一个imports文件</li><li>将自动配置类名放入imports文件中</li></ul><p><img src="/2024/09/24/Spring-Boot-1/image-20240930112323228.png" alt="image-20240930112323228"></p><h3 id="3-2-自定义starter"><a href="#3-2-自定义starter" class="headerlink" title="3.2 自定义starter"></a>3.2 自定义starter</h3><p>在starter中引入autoconfigure</p><ul><li>自定义mybatis的starter</li><li><img src="/2024/09/24/Spring-Boot-1/image-20240930114159601.png" alt="image-20240930114159601"></li></ul><h3 id="3-3-Springboot-Web相关注解"><a href="#3-3-Springboot-Web相关注解" class="headerlink" title="3.3 Springboot Web相关注解"></a>3.3 Springboot Web相关注解</h3><p>Spring框架的Web模块所有注解：</p><p>@Controller：将类标记为SpringMVC控制器。</p><p>@RestController：结合了@Controller和@ResponseBody注解的功能，表示这是一个控制器，并且返回值会直接转换为JSON或XML格式。</p><p>@RequestMapping：用于映射HTTP请求到特定的处理方法或控制器类上。可以指定URI、请求方法、请求头信息等等。</p><p>@PathVariable：从URI中获取参数值，并将其绑定到处理器方法的参数上。</p><p>@RequestParam：将HTTP请求参数映射到处理器方法的参数上。可以设置默认值、是否必须、参数名称等等。</p><p>@RequestBody：从HTTP请求体中读取参数，并将其作为Java对象进行解析。</p><p>@ResponseBody：表示返回值应该作为HTTP响应体的内容传输给客户端。可以指定返回内容的类型如JSON或XML。</p><p>@RequestHeader：获取HTTP请求头信息的值，并将其注入到处理器方法的参数上。</p><p>@CookieValue：获取HTTP请求中指定Cookie的值，并将其注入到处理器方法的参数上。</p><p>@SessionAttributes：将模型属性透明地保存在HTTP会话中，以便多个请求之间共享数据。</p><p>@ModelAttribute：将前端传来的数据填充到JavaBean中，并将这个Bean作为模型对象传递给处理器方法。</p><p>@InitBinder：自定义的数据绑定，例如将日期字符串转换为Java Date类型。</p><p>@ExceptionHandler：定义全局异常处理程序，可以在其中定义应该如何处理不同类型的异常。</p><p>@ResponseStatus：指定响应状态码和原因。</p><p>@SessionAttribute：将模型属性注入到HTTP会话中，以便多个请求之间共享数据。</p><p>@RequestPart：从HTTP请求正文中获取多部分（即文件）数据。通常情况下，使用@RequestPart注解来处理上传文件。</p><p>@RequestBodyAdvice：允许对@RequestBody参数进行自定义前置操作。</p><p>@ResponseBodyAdvice：允许对@RequestBody方法返回值进行自定义后置操作。</p><h2 id="4-注册登录"><a href="#4-注册登录" class="headerlink" title="4. 注册登录"></a>4. 注册登录</h2><h3 id="4-1-登录认证"><a href="#4-1-登录认证" class="headerlink" title="4.1 登录认证"></a>4.1 登录认证</h3><p>通过令牌获取数据访问</p><ul><li>令牌就是字符串</li><li>可以承载业务数据，减少后续请求查询数据库的次数</li><li>防篡改，保证信息的合法性和有效性</li></ul><h4 id="4-1-1-JWT-Json-Web-Token"><a href="#4-1-1-JWT-Json-Web-Token" class="headerlink" title="4.1.1 JWT Json Web Token"></a>4.1.1 JWT Json Web Token</h4><p>用于通信双方以json数据格式安全的传输信息。由两个.进行分割</p><ul><li>第一部分：Header（头），记录令牌类型、签名算法。例如{“alg”:”HS256”,”type”:”JWT”}</li><li>第二部分：Paload（有效载荷），携带一些自定义信息、默认信息。{“id”:”1”,”username”:”Tom”}，基于Base64进行编码。</li><li>第三部分：Signature（数字签名），防止Token被篡改、确保安全性。将header、payload，并加入指定密钥，通过指定签名算法（头部的alg）计算而来。</li></ul><p>JWT校验时的签名密钥必须和JWT生成令牌的密钥配套</p><p>如果校验报错说明令牌失效</p><h3 id="4-2-拦截器"><a href="#4-2-拦截器" class="headerlink" title="4.2 拦截器"></a>4.2 拦截器</h3><p>在获取到登录token之前无法访问网页内容，使用拦截器过滤需求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 令牌验证</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;Authorization&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Map&lt;String, Object&gt; claims = JWTUtils.verifyToken(token);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Base</title>
    <link href="/2024/09/24/Java-Base/"/>
    <url>/2024/09/24/Java-Base/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="0-一些问题"><a href="#0-一些问题" class="headerlink" title="0. 一些问题"></a>0. 一些问题</h2><h4 id="1-Java的语言产品为JDK，JDK组成"><a href="#1-Java的语言产品为JDK，JDK组成" class="headerlink" title="1. Java的语言产品为JDK，JDK组成"></a>1. Java的语言产品为<strong>JDK</strong>，JDK组成</h4><ol><li>JVM</li><li>核心类库</li><li>JRE &#x3D; JVM+核心类库</li><li>java开发工具</li><li>JDK &#x3D; JRE + java开发工具</li><li><img src="/2024/09/24/Java-Base/image-20240822185158268.png" alt="image-20240822185158268"></li></ol><h4 id="2-Long-term-Support：-JDK-8（开发环境）-JDK-11-JDK17（教学阶段）"><a href="#2-Long-term-Support：-JDK-8（开发环境）-JDK-11-JDK17（教学阶段）" class="headerlink" title="2. Long term Support： JDK-8（开发环境） JDK-11 JDK17（教学阶段）"></a>2. Long term Support： <strong>JDK-8（开发环境） JDK-11 JDK17（教学阶段）</strong></h4><h4 id="3-java-是执行工具-javac是编译工具"><a href="#3-java-是执行工具-javac是编译工具" class="headerlink" title="3. java 是执行工具 javac是编译工具"></a>3. java 是执行工具 javac是编译工具</h4><h4 id="4-win问题"><a href="#4-win问题" class="headerlink" title="4. win问题"></a>4. win问题</h4><ol><li>文件扩展名问题</li><li>环境变量：用于在命令行任意目录启动程序。</li></ol><h4 id="5-Java跨平台：编译一次，处处可用"><a href="#5-Java跨平台：编译一次，处处可用" class="headerlink" title="5. Java跨平台：编译一次，处处可用"></a>5. Java跨平台：编译一次，处处可用</h4><h4 id="6-方法重载：在一个类中，多个方法的名称相同，但是形参列表不同，称这些方法重载。"><a href="#6-方法重载：在一个类中，多个方法的名称相同，但是形参列表不同，称这些方法重载。" class="headerlink" title="6. 方法重载：在一个类中，多个方法的名称相同，但是形参列表不同，称这些方法重载。"></a>6. 方法重载：在一个类中，多个方法的名称相同，但是形参列表不同，称这些方法重载。</h4><ol><li>形参个数、类型、顺序不同</li><li>与返回值无关，只要名称相同，形参列表不同，即为方法重载</li></ol><h4 id="7-为什么要打包-package"><a href="#7-为什么要打包-package" class="headerlink" title="7. 为什么要打包 package"></a>7. 为什么要打包 package</h4><ol><li>将相似的功能放在同一个包里方便使用</li><li>分开相同名称的类<ol><li>shopping.List</li><li>Packing.List</li></ol></li></ol><h4 id="8-特殊的类"><a href="#8-特殊的类" class="headerlink" title="8. 特殊的类"></a>8. 特殊的类</h4><ol><li><p>所有类都可以看到相同包下的其他类，不需要导入</p></li><li><p>所有类都可以看到在java.lang中的类</p></li><li><p><img src="/2024/09/24/Java-Base/image-20240923100409956.png" alt="image-20240923100409956"></p></li></ol><h4 id="9-TreeSet和HashSet的区别"><a href="#9-TreeSet和HashSet的区别" class="headerlink" title="9. TreeSet和HashSet的区别"></a>9. TreeSet和HashSet的区别</h4><ol><li>HashSet基于哈希表实现，数据无序，允许null，使用equalTo()方法进行比较。</li><li>TreeSet基于红黑树实现，可以保持数据排序（根据Comparable method进行排序，默认升序）。不允许null，并且会throw NullPointerException，因为Tree使用compareTo()方法进行比较，compareTo()会抛出异常。搜索、插入、删除、higher()、floor()、ceiling()等操作时间复杂度为O(log n)</li><li>When to prefer TreeSet over HashSet<ol><li>TreeSet 需要排序的唯一元素，而不是唯一元素。 TreeSet 提供的排序列表总是以升序排列。</li><li>TreeSet 比 HashSet 具有更强的局部性。如果两个条目在顺序上相邻，那么 TreeSet 会将它们放在数据结构中相邻的位置，从而放在内存中，而 HashSet 则会将条目分散到整个内存中，而不管它们与哪个键相关联。</li><li>TreeSet 使用红黑树算法对元素进行排序。 当需要频繁执行读&#x2F;写操作时，TreeSet 是一个不错的选择。</li><li>LinkedHashSet 是介于这两种数据结构之间的另一种数据结构。 它提供像 HashSet 一样的时间复杂性，并保持<strong>插入顺序</strong>（注意，这不是排序顺序，而是元素插入的顺序）。</li></ol></li></ol><h4 id="10-TreeMap和HashMap"><a href="#10-TreeMap和HashMap" class="headerlink" title="10. TreeMap和HashMap"></a>10. TreeMap和HashMap</h4><ol><li>HashMap 不会根据键或值保持任何顺序，如果我们希望键保持排序，则需要使用 TreeMap。</li><li>复杂性：get&#x2F;put&#x2F;containsKey() 操作的平均值为 O(1)，但我们不能保证这一点，因为这完全取决于计算散列所需的时间。</li><li>应用： HashMap 基本上是散列的一种实现。 因此，只要我们需要使用键值对进行散列，就可以使用 HashMap。 例如，在网络应用程序中，用户名作为键存储，而用户数据作为值存储在 HashMap 中，以便更快地检索与用户名相对应的用户数据。</li><li>对于添加、删除、包含键等操作，时间复杂度为 O(log n)，其中 n 是 TreeMap 中元素的数量。</li><li>TreeMap 始终保持元素排序（递增），而 HashMap 中的元素没有顺序。 TreeMap 还为键的首数、尾数、下限和上限提供了方法。</li><li><img src="/2024/09/24/Java-Base/image-20240923105349172.png" alt="image-20240923105349172"></li><li>概述：<ol><li>HashMap 实现 Map 接口，而 TreeMap 实现 SortedMap 接口。 Sorted Map 接口是 Map 的子接口。</li><li>HashMap 实现了 Hashing，而 TreeMap 实现了 Red-Black Tree（一种自平衡二叉搜索树）。 HashMap 和 TreeMap 都有对应的 HashSet 和 TreeSet。</li><li>HashSet 和 TreeSet 实现了 Set 接口。 在 HashSet 和 TreeSet 中，我们只有键，没有值，它们主要用于查看集合中是否存在。 对于上述问题，我们不能使用 HashSet（或 TreeSet），因为我们不能存储计数。 与 HashMap（或 TreeMap）相比，我们更倾向于使用 HashSet（或 TreeSet）的一个例子是打印数组中所有不同的元素。</li></ol></li><li><img src="/2024/09/24/Java-Base/image-20240923105554025.png" alt="image-20240923105554025"></li></ol><h4 id="11-无法直接访问私有变量的情况"><a href="#11-无法直接访问私有变量的情况" class="headerlink" title="11. 无法直接访问私有变量的情况"></a>11. 无法直接访问私有变量的情况</h4><ul><li><strong>跨类访问</strong>：如果你在另一个类中尝试访问<code>Person</code>类的<code>age</code>字段，将会因为访问控制而无法访问。例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">(Person person)</span> &#123;<br>        <span class="hljs-comment">// person.age; // 这是非法的，无法访问私有字段</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>不同包中的类</strong>：如果<code>Person</code>类和另一个类在不同的包中，且该字段是私有的，同样无法直接访问。</p></li><li><p><strong>接口和抽象类</strong>：在实现接口或继承抽象类时，私有字段无法被子类直接访问。</p></li><li><p><strong>反射以外的情况</strong>：尽管使用反射可以访问私有字段，但这通常不被推荐，因为它会破坏封装性。</p></li><li><p>Java中的接口（Interface）是一种引用数据类型，是类的一种特殊形式。它用于定义一组方法的契约，类可以通过实现接口来承诺提供具体的行为。下面是Java接口的主要特性：</p><h5 id="1-抽象性"><a href="#1-抽象性" class="headerlink" title="1. 抽象性"></a>1. <strong>抽象性</strong></h5><p> 接口只定义方法的签名，不提供方法的实现。这意味着接口中的方法都是抽象的，类必须实现这些方法。</p><h5 id="2-多重继承"><a href="#2-多重继承" class="headerlink" title="2. 多重继承"></a>2. <strong>多重继承</strong></h5><p> Java不支持类的多重继承，但一个类可以实现多个接口。这使得接口成为一种灵活的方式来设计系统的行为。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span>, B &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Method A implementation&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Method B implementation&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-常量"><a href="#3-常量" class="headerlink" title="3. 常量"></a>3. <strong>常量</strong></h5><p> 接口可以定义常量，常量是隐式<code>public static final</code>的。这意味着所有实现该接口的类都可以访问这些常量。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">CONSTANT_VALUE</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 隐式public static final</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-默认方法和静态方法"><a href="#4-默认方法和静态方法" class="headerlink" title="4. 默认方法和静态方法"></a>4. <strong>默认方法和静态方法</strong></h5><p> 从Java 8开始，接口可以包含默认方法和静态方法：</p><ul><li><p><strong>默认方法</strong>：可以在接口中提供方法的默认实现，允许接口添加新方法而不影响现有实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">defaultMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Default method implementation&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>静态方法</strong>：可以在接口中定义静态方法，可以通过接口名直接调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Static method implementation&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="5-函数式接口"><a href="#5-函数式接口" class="headerlink" title="5. 函数式接口"></a>5. <strong>函数式接口</strong></h5><p> Java 8引入了函数式编程，允许使用 Lambda 表达式来实例化接口。函数式接口是只包含一个抽象方法的接口。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyFunctionalInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-接口的继承"><a href="#6-接口的继承" class="headerlink" title="6. 接口的继承"></a>6. <strong>接口的继承</strong></h5><p> 接口可以继承其他接口，可以通过多层继承来构建复杂的接口结构。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="7-不支持构造函数"><a href="#7-不支持构造函数" class="headerlink" title="7. 不支持构造函数"></a>7. <strong>不支持构造函数</strong></h5><p> 接口不能包含构造函数，因为它们不能被实例化。接口只能通过实现它的类来创建对象。</p></li></ul><h4 id="12-什么是字节码-采用字节码的好处是什么"><a href="#12-什么是字节码-采用字节码的好处是什么" class="headerlink" title="12. 什么是字节码?采用字节码的好处是什么?"></a>12. <a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81-%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88">什么是字节码?采用字节码的好处是什么?</a></h4><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C、 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p><strong>Java 程序从源代码到运行的过程如下图所示</strong>：</p><img src="java-code-to-machine-code.png" style="zoom:100%;" /><p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 <strong>JIT（Just in Time Compilation）</strong> 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p><p><img src="/2024/09/24/Java-Base/image-20240925153827361.png" alt="image-20240925153827361"></p><blockquote><p>[!NOTE]</p><p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p></blockquote><p>JDK、JRE、JVM、JIT 这四者的关系如下图所示。</p><p><img src="/2024/09/24/Java-Base/image-20240925153940994.png" alt="image-20240925153940994"></p><p>下面这张图是 JVM 的大致结构模型。</p><p><img src="/2024/09/24/Java-Base/jvm-rough-structure-model.png" alt="jvm-rough-structure-model.png"></p><h4 id="13-测试"><a href="#13-测试" class="headerlink" title="13. 测试"></a>13. 测试</h4><h5 id="13-1-通过对输入-输出集划分进行测试用例选择"><a href="#13-1-通过对输入-输出集划分进行测试用例选择" class="headerlink" title="13.1 通过对输入\输出集划分进行测试用例选择"></a>13.1 通过对输入\输出集划分进行测试用例选择</h5><p>子域背后的理念是将输入空间划分为相似的输入集，程序在这些输入集上具有相似的行为。 然后，我们使用每个集合中的一个代表。 这种方法通过选择不同的测试用例来充分利用有限的测试资源，并迫使测试探索随机测试可能无法到达的输入空间部分。 如果我们需要确保我们的测试将探索输出空间的不同部分，我们也可以将输出空间划分为子域（程序具有相似行为的相似输出）。 大多数情况下，对输入空间进行划分就足够了。</p><h5 id="13-2-在划分中涵盖输入输出集边界"><a href="#13-2-在划分中涵盖输入输出集边界" class="headerlink" title="13.2 在划分中涵盖输入输出集边界"></a>13.2 在划分中涵盖输入输出集边界</h5><p>bug经常发生在子集之间的边界</p><ul><li>0 is a boundary between positive numbers and negative numbers</li><li>the maximum and minimum values of numeric types, like <code>int </code>and <code>double</code></li><li>emptiness (the empty string, empty list, empty array) for collection types</li><li>the first and last element of a collection</li></ul><h5 id="13-3-黑盒测试-白盒测试"><a href="#13-3-黑盒测试-白盒测试" class="headerlink" title="13.3 黑盒测试 &amp; 白盒测试"></a>13.3 黑盒测试 &amp; 白盒测试</h5><p><strong>Blackbox testing</strong> means choosing test cases only from the specification, not the implementation of the function. That’s what we’ve been doing in our examples so far. We partitioned and looked for boundaries in <code>multiply </code>and <code>max </code>without looking at the actual code for these functions.</p><p><strong>Whitebox testing</strong> (also called glass box testing) means choosing test cases with knowledge of how the function is actually implemented. For example, if the implementation selects different algorithms depending on the input, then you should partition according to those domains. If the implementation keeps an internal cache that remembers the answers to previous inputs, then you should test repeated inputs.</p><h5 id="13-4-覆盖率"><a href="#13-4-覆盖率" class="headerlink" title="13.4 覆盖率"></a>13.4 覆盖率</h5><p>Here are three common kinds of coverage:</p><ul><li><strong>Statement coverage</strong> : is every statement run by some test case?</li><li><strong>Branch coverage</strong> : for every <code>if </code>or <code>while </code>statement in the program, are both the true and the false direction taken by some test case?</li><li><strong>Path coverage</strong> : is every possible combination of branches — every path through the program — taken by some test case?</li></ul><h5 id="13-5-单元测试和桩-自动化测试和回归测试"><a href="#13-5-单元测试和桩-自动化测试和回归测试" class="headerlink" title="13.5 单元测试和桩 自动化测试和回归测试"></a>13.5 单元测试和桩 自动化测试和回归测试</h5><h4 id="14-Code-Review"><a href="#14-Code-Review" class="headerlink" title="14. Code Review"></a>14. Code Review</h4><p>目的：</p><ul><li>提升代码质量</li><li>提升程序员水平</li></ul><p>养成自己的代码风格</p><p><strong>Dont Repeat Yourself</strong></p><h4 id="15-Final-关键字"><a href="#15-Final-关键字" class="headerlink" title="15. Final 关键字"></a>15. Final 关键字</h4><p>当数组变量被声明为final时，数组的引用是不可变的。</p><p>然而，final数组的内容是可以修改的。</p><h2 id="1-面向对象编程"><a href="#1-面向对象编程" class="headerlink" title="1. 面向对象编程"></a>1. 面向对象编程</h2><h3 id="1-1-封装、继承、多态"><a href="#1-1-封装、继承、多态" class="headerlink" title="1.1 封装、继承、多态"></a>1.1 封装、继承、多态</h3><h4 id="1-1-1-封装"><a href="#1-1-1-封装" class="headerlink" title="1.1.1 封装"></a>1.1.1 封装</h4><p>1）什么是封装</p><p>封装从字面上来理解就是包装的意思，专业点就是信息隐藏，<strong>是指利用抽象将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体</strong>。</p><p>数据被保护在类的内部，尽可能地隐藏内部的实现细节，只保留一些对外接口使之与外部发生联系。</p><p>其他对象只能通过已经授权的操作来与这个封装的对象进行交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。</p><p>使用封装有 4 大好处：</p><ul><li>1、良好的封装能够减少耦合。</li><li>2、类内部的结构可以自由修改。</li><li>3、可以对成员进行更精确的控制。</li><li>4、隐藏信息，实现细节。</li></ul><h4 id="1-1-2-继承"><a href="#1-1-2-继承" class="headerlink" title="1.1.2 继承"></a>1.1.2 继承</h4><p>1）什么是继承</p><p>Java 语言中<strong>继承就是子类继承父类的属性和方法，使得子类对象（实例）具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的方法</strong>。</p><p>2）继承的种类</p><ol><li><p>单继承</p><p>单继承，一个子类只有一个父类，如我们上面讲过的 Animal 类和它的子类。<strong>单继承在类层次结构上比较清晰，但缺点是结构的丰富度有时不能满足使用需求</strong>。</p></li><li><p>多继承</p><p>Java 虽然不支持多继承，但是 Java 有三种实现多继承效果的方式，<strong>分别是</strong>内部类、多层继承和实现接口。</p><ol><li><p><a href="https://javabetter.cn/oo/inner-class.html">内部类</a>可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，可以达到多继承的效果。</p></li><li><p>**多层继承：**子类继承父类，父类如果还继承其他的类，那么这就叫**多层继承**。这样子类就会拥有所有被继承类的属性和方法。</p></li><li><p><a href="https://javabetter.cn/oo/interface.html">实现接口</a>无疑是满足多继承使用需求的最好方式，一个类可以实现多个接口满足自己在丰富性和复杂环境的使用需求。</p></li></ol><p>类和接口相比，<strong>类就是一个实体，有属性和方法，而接口更倾向于一组方法</strong>。</p></li></ol><p>3）实现继承</p><p>在 Java 中，类的继承是单一继承，也就是说一个子类只能拥有一个父类，所以<strong>extends</strong>只能继承一个类。其使用语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">class 子类名 extends 父类名&#123;&#125;<br></code></pre></td></tr></table></figure><p>使用 implements 关键字可以变相使 Java 拥有多继承的特性，使用范围为类实现接口的情况，一个类可以实现多个接口(接口与接口之间用逗号分开)。</p><p>4）继承特点</p><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><a href="https://javabetter.cn/oo/encapsulation-inheritance-polymorphism.html#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">构造方法</a></h5><p><a href="https://javabetter.cn/oo/construct.html">构造方法</a>是一种特殊的方法，<strong>它是一个与类同名的方法</strong>。在继承中<strong>构造方法是一种比较特殊的方法</strong>（比如不能继承），所以要了解和学习在继承中构造方法的规则和要求。</p><p>继承中的构造方法有以下几点需要注意：</p><p><strong>父类的构造方法不能被继承：</strong></p><p>因为构造方法语法是<strong>与类同名</strong>，而继承则不更改方法名，如果子类继承父类的构造方法，那明显与构造方法的语法冲突了。比如 Father 类的构造方法名为 Father()，Son 类如果继承 Father 类的构造方法 Father()，那就和构造方法定义：<strong>构造方法与类同名</strong>冲突了，所以在子类中不能继承父类的构造方法，但子类会调用父类的构造方法。</p><p><strong>子类的构造过程必须调用其父类的构造方法：</strong></p><p>Java 虚拟机**构造子类对象前会先构造父类对象，父类对象构造完成之后再来构造子类特有的属性，**这被称为**内存叠加**。而 Java 虚拟机构造父类对象会执行父类的构造方法，所以子类构造方法必须调用 super()即父类的构造方法。就比如一个简单的继承案例应该这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//无参构造</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span> <span class="hljs-params">(String name)</span>&#123;<span class="hljs-comment">//有参构造</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//无参构造</span><br>       <span class="hljs-built_in">super</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">B</span><span class="hljs-params">(String name)</span> &#123;<span class="hljs-comment">//有参构造</span><br>      <span class="hljs-comment">//super();</span><br>       <span class="hljs-built_in">super</span>(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如果子类的构造方法中没有显示地调用父类构造方法，则系统默认调用父类无参数的构造方法。</strong></p><p><strong>方法重写（Override）</strong>：外壳不变重写内容。如果子类具有和父类一样的方法（参数相同、返回类型相同、方法名相同，但方法体可能不同），我们称之为方法重写。 方法重写用于提供父类已经声明的方法的特殊实现，是实现多态的基础条件。</p><ul><li><p>只能重写继承过来的方法</p></li><li><p>final、static的方法不能被重写</p></li><li><p>重写的方法必须有相同的参数列表</p></li><li><p>重写的方法必须返回相同的类型</p></li><li><p>重写的方法不能使用限制等级更严格的权限修饰符</p></li><li><p>重写后的方法不能抛出比父类级别更高的异常</p><p>可以这样来理解：</p><ul><li>如果被重写的方法是 default，那么重写的方法可以是 default、protected 或者 public。</li><li>如果被重写的方法是 protected，那么重写的方法只能是 protected 或者 public。</li><li>如果被重写的方法是 public， 那么重写的方法就只能是 public。</li></ul></li><li><p>可以在子类中通过super关键字来调用父类中被重写的方法</p></li><li><p>构造方法不能被重写</p></li><li><p>如果一个类继承了抽象类，抽象类中的抽象方法必须在子类中被重写。</p></li><li><p>synchronized关键字对重写规则没有任何影响</p></li><li><p>strictfp关键字对重写规则没有影响。</p></li></ul><p><strong>方法重载（Overload）</strong>：不同方法命名相同。如果一个类有多个名字相同但参数个数不同的方法，我们通常称这些方法为方法重载。 ”我面带着朴实无华的微笑继续说，“如果方法的功能是一样的，但参数不同，使用相同的名字可以提高程序的可读性。</p><p><strong>由于可以通过改变参数类型的方式实现方法重载，那么当传递的参数没有找到匹配的方法时，就会发生隐式的类型转换。</strong></p><p><img src="/2024/09/24/Java-Base/extends-bigsai-0cd258c9-b897-4be3-bdb2-2ddd9c073609.png" alt="img"></p><p>“首先来说一下方法重载时的注意事项，‘两同一不同’。”</p><p>“‘两同’：在同一个类，方法名相同。”</p><p>“‘一不同’：参数不同。”</p><p>“再来说一下方法重写时的注意事项，‘两同一小一大’。”</p><p>“‘两同’：方法名相同，参数相同。”</p><p>“‘一小’：子类方法声明的异常类型要比父类小一些或者相等。”</p><p>“‘一大’：子类方法的访问权限应该比父类的更大或者相等。”</p><p>访问修饰符</p><p>在Java中，访问修饰符的作用范围如下：</p><ol><li><code>private</code>：私有访问修饰符，只能在声明它的类内部访问。无论是否在同一包内，都无法在其他类中直接访问。</li><li><code>default</code>（默认）：默认访问修饰符。如果没有明确指定访问修饰符，即没有使用任何访问修饰符关键字，将被视为默认访问修饰符。默认修饰符允许在同一包内访问，但在其他包中无法直接访问。</li><li><code>protected</code>：受保护的访问修饰符。在同一包内，以及不同包中的子类中无论是否在同一包内），都可以访问受保护的成员。但是，非子类不在同一包内其他类无法直接访问。</li><li><code>public</code>：公共访问修饰符。公共成员可以在任何位置都可见和访问，无论是否在同一包内。</li></ol><h5 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a><a href="https://javabetter.cn/oo/encapsulation-inheritance-polymorphism.html#%E9%9D%9E%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6">非访问修饰符</a></h5><p>访问修饰符用来控制访问权限，而非访问修饰符每个都有各自的作用，下面针对 static、final、abstract 修饰符进行介绍。</p><p><a href="https://javabetter.cn/oo/static.html">static 修饰符</a></p><p>static 翻译为“静态的”，能够与变量，方法和类一起使用，<strong>称为静态变量，静态方法(也称为类变量、类方法)<strong>。如果在一个类中使用 static 修饰变量或者方法的话，它们</strong>可以直接通过类访问，不需要创建一个类的对象来访问成员。</strong></p><p>源代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span>&#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">C1</span><span class="hljs-params">()</span>&#123;&#125;<br>   <span class="hljs-comment">// public static C1()&#123;&#125;// 构造方法不允许被声明为static</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doA</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doB</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">C1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">doC</span><span class="hljs-params">()</span><span class="hljs-comment">//静态方法中不存在当前对象，因而不能使用this和super。</span><br>    &#123;<br>        <span class="hljs-comment">//System.out.println(super.a);</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doA</span><span class="hljs-params">()</span>&#123;&#125;<span class="hljs-comment">//静态方法能被静态方法重写</span><br>   <span class="hljs-comment">// public void doB()&#123;&#125;//静态方法不能被非静态方法重写</span><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://javabetter.cn/oo/final.html">final 修饰符</a></p><p>final 变量：</p><ul><li>final 表示”最后的、最终的”含义，<strong>变量一旦赋值后，不能被重新赋值</strong>。被 final 修饰的实例变量必须显式指定初始值(即不能只声明)。final 修饰符通常和 static 修饰符一起使用来创建类常量。</li></ul><p>final 方法：</p><ul><li><strong>父类中的 final 方法可以被子类继承，但是不能被子类重写</strong>。声明 final 方法的主要目的是防止该方法的内容被修改。</li></ul><p>final 类：</p><ul><li><strong>final 类不能被继承</strong>，没有类能够继承 final 类的任何特性。</li></ul><p>所以无论是变量、方法还是类被 final 修饰之后，都有代表最终、最后的意思。内容无法被修改。</p><p><a href="https://javabetter.cn/oo/abstract.html">abstract 修饰符</a></p><p>abstract 英文名为“抽象的”，主要用来修饰类和方法，称为抽象类和抽象方法。</p><p><strong>抽象方法</strong>：有很多不同类的方法是相似的，但是具体内容又不太一样，所以我们只能抽取他的声明，没有具体的方法体，即抽象方法可以表达概念但无法具体实现。</p><p><strong>抽象类</strong>：<strong>有抽象方法的类必须是抽象类</strong>，抽象类可以表达概念但是无法构造实体的类。</p><h5 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a><a href="https://javabetter.cn/oo/encapsulation-inheritance-polymorphism.html#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B">向上转型</a></h5><p><strong>将子类实例赋值给父类变量</strong></p><p><strong>向上转型</strong> : 通过子类对象(小范围)实例化父类对象(大范围)，这种属于自动转换。用一张图就能很好地表示向上转型的逻辑：</p><p><img src="/2024/09/24/Java-Base/extends-bigsai-0cd258c9-b897-4be3-bdb2-2ddd9c073609.png" alt="img"></p><p>父类引用变量指向子类对象后，只能使用父类已声明的方法，但方法如果被重写会执行子类的方法，如果方法未被重写那么将执行父类的方法。</p><h5 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a><a href="https://javabetter.cn/oo/encapsulation-inheritance-polymorphism.html#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B">向下转型</a></h5><p><strong>将父类实例赋值给子类变量</strong></p><p><strong>向下转型</strong> : 通过父类对象(大范围)实例化子类对象(小范围)，在书写上父类对象需要加括号<code>()</code>强制转换为子类类型。但父类引用变量实际引用必须是子类对象才能成功转型，这里也用一张图就能很好表示向下转型的逻辑：</p><p><img src="/2024/09/24/Java-Base/extends-bigsai-ef0d4716-8b4f-4adf-845e-dd293871b7a7.png" alt="img"></p><p>子类引用变量指向父类引用变量指向的对象后(一个 Son()对象)，就完成向下转型，就可以调用一些子类特有而父类没有的方法 。</p><p>5）<a href="https://javabetter.cn/oo/encapsulation-inheritance-polymorphism.html#_08%E3%80%81%E5%AD%90%E7%88%B6%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F">子父类初始化顺序</a></p><p>在 Java 继承中，父子类初始化先后顺序为：</p><ol><li>父类中静态成员变量和静态代码块</li><li>子类中静态成员变量和静态代码块</li><li>父类中普通成员变量和代码块，父类的构造方法</li><li>子类中普通成员变量和代码块，子类的构造方法</li></ol><p>总的来说，就是<strong>静态&gt;非静态，父类&gt;子类，非构造方法&gt;构造方法</strong>。同一类别（例如普通变量和普通代码块）成员变量和代码块执行从前到后，需要注意逻辑。</p><p>这个也不难理解，静态变量也称类变量，可以看成一个全局变量，静态成员变量和静态代码块在类加载的时候就初始化，而非静态变量和代码块在对象创建的时候初始化。所以静态快于非静态初始化。</p><p>而在创建子类对象的时候需要先创建父类对象，所以父类优先于子类。</p><p>而在调用构造方法的时候，是对成员变量进行一些初始化操作，所以普通成员变量和代码块优于构造方法执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Father</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(++b1+<span class="hljs-string">&quot;父类构造方法&quot;</span>);<br>    &#125;<span class="hljs-comment">//父类构造方法 第四</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a1=<span class="hljs-number">0</span>;<span class="hljs-comment">//父类static 第一 注意顺序</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(++a1+<span class="hljs-string">&quot;父类static&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> b1=a1;<span class="hljs-comment">//父类成员变量和代码块 第三</span><br>    &#123;<br>        System.out.println(++b1+<span class="hljs-string">&quot;父类代码块&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Son</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(++b2+<span class="hljs-string">&quot;子类构造方法&quot;</span>);<br>    &#125;<span class="hljs-comment">//子类构造方法 第六</span><br>    <span class="hljs-keyword">static</span> &#123;<span class="hljs-comment">//子类static第二步</span><br>        System.out.println(++a1+<span class="hljs-string">&quot;子类static&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> b2=b1;<span class="hljs-comment">//子类成员变量和代码块 第五</span><br>    &#123;<br>        System.out.println(++b2 + <span class="hljs-string">&quot;子类代码块&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test9</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Son son=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-1-3-多态（动态绑定）"><a href="#1-1-3-多态（动态绑定）" class="headerlink" title="1.1.3 多态（动态绑定）"></a>1.1.3 多态（动态绑定）</h4><p>Java 的多态是指在面向对象编程中，同一个类的对象在不同情况下表现出来的不同行为和状态。</p><ul><li>子类可以继承父类的字段和方法，子类对象可以直接使用父类中的方法和字段（私有的不行）。</li><li>子类可以重写从父类继承来的方法，使得子类对象调用这个方法时表现出不同的行为。</li><li>可以将子类对象赋给父类类型的引用，这样就可以通过父类类型的引用调用子类中重写的方法，实现多态。</li></ul><p>多态的目的是为了提高代码的灵活性和可扩展性，使得代码更容易维护和扩展。</p><p>比如说，通过允许子类继承父类的方法并重写，增强了代码的复用性。</p><p>再比如说多态可以实现动态绑定，这意味着程序在运行时再确定对象的方法调用也不迟。</p><p>1）什么是多态</p><p>多态的前提条件有三个：</p><ul><li>子类继承父类</li><li>子类重写父类的方法</li><li>父类引用指向子类的对象</li></ul><p>2）多态与后期绑定</p><p>答案是在运行时根据对象的类型进行后期绑定，编译器在编译阶段并不知道对象的类型，但是 Java 的方法调用机制能找到正确的方法体，然后执行，得到正确的结果。</p><p>3）多态与构造方法</p><p>在构造方法中调用多态方法，会产生一个奇妙的结果，我们来看程序清单 3-1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wangxiaosan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Wangsan</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Wangxiaosan</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        System.out.println(<span class="hljs-string">&quot;王小三的年龄：&quot;</span> + <span class="hljs-built_in">this</span>.age);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 子类覆盖父类方法</span><br>        System.out.println(<span class="hljs-string">&quot;我小三上幼儿园的年龄是：&quot;</span> + <span class="hljs-built_in">this</span>.age);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Wangxiaosan</span>(<span class="hljs-number">4</span>);<br><span class="hljs-comment">//      上幼儿园之前</span><br><span class="hljs-comment">//      我小三上幼儿园的年龄是：0</span><br><span class="hljs-comment">//      上幼儿园之后</span><br><span class="hljs-comment">//      王小三的年龄：4</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wangsan</span> &#123;<br>    Wangsan () &#123;<br>        System.out.println(<span class="hljs-string">&quot;上幼儿园之前&quot;</span>);<br>        write();<br>        System.out.println(<span class="hljs-string">&quot;上幼儿园之后&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;老子上幼儿园的年龄是3岁半&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE]</p><p>从输出结果上看，是不是有点诧异？明明在创建 Wangxiaosan 对象的时候，年龄传递的是 4，但输出结果既不是“老子上幼儿园的年龄是 3 岁半”，也不是“我小三上幼儿园的年龄是：4”。</p><p>为什么？</p><p>因为在创建子类对象时，会先去调用父类的构造方法，而父类构造方法中又调用了被子类覆盖的多态方法，由于父类并不清楚子类对象中的字段值是什么，于是把 int 类型的属性暂时初始化为 0，然后再调用子类的构造方法（子类构造方法知道王小二的年龄是 4）。</p></blockquote><p>4）多态与向下转型</p><p>向下转型是指将父类引用强转为子类类型；这是不安全的，因为有的时候，父类引用指向的是父类对象，向下转型就会抛出 ClassCastException，表示类型转换失败；但如果父类引用指向的是子类对象，那么向下转型就是成功的。</p><p>来看程序清单 4-1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wangxiaosi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Wangsi</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;记住仇恨，表明我们要奋发图强的心智&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我不喜欢读书，我就喜欢吃&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Wangsi[] wangsis = &#123; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Wangsi</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Wangxiaosi</span>() &#125;;<br><br>        <span class="hljs-comment">// wangsis[1]能够向下转型</span><br>        ((Wangxiaosi) wangsis[<span class="hljs-number">1</span>]).write();<br>        <span class="hljs-comment">// wangsis[0]不能向下转型</span><br>        ((Wangxiaosi)wangsis[<span class="hljs-number">0</span>]).write();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wangsi</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;勿忘国耻&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;每周读一本好书&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5）总结</p><ul><li><strong>封装</strong>：是对类的封装，封装是对类的属性和方法进行封装，只对外暴露方法而不暴露具体使用细节，所以我们一般设计类成员变量时候大多设为私有而通过一些 get、set 方法去读写。</li><li><strong>继承</strong>：子类继承父类，即“子承父业”，子类拥有父类除私有的所有属性和方法，自己还能在此基础上拓展自己新的属性和方法。主要目的是<strong>复用代码</strong>。</li><li><strong>多态</strong>：多态是同一个行为具有多个不同表现形式或形态的能力。即一个父类可能有若干子类，各子类实现父类方法有多种多样，调用父类方法时，父类引用变量指向不同子类实例而执行不同方法，这就是所谓父类方法是多态的。</li></ul><h3 id="1-2-关键字"><a href="#1-2-关键字" class="headerlink" title="1.2 关键字"></a>1.2 关键字</h3><h4 id="1-2-1-static关键字"><a href="#1-2-1-static关键字" class="headerlink" title="1.2.1 static关键字"></a>1.2.1 static关键字</h4><p>static 关键字的作用可以用一句话来描述：‘<strong>方便在没有创建对象的情况下进行调用</strong>，包括变量和方法’。</p><p>1）静态变量</p><p>如果在声明变量的时候使用了 static 关键字，那么这个变量就被称为静态变量。静态变量只在类加载的时候获取一次内存空间，这使得静态变量很节省内存空间。</p><p>静态变量只能通过类名来直接访问。</p><p>2）静态方法</p><p>静态方法有以下特征：</p><ul><li><p>静态方法属于这个类而不是这个类的对象；</p></li><li><p>调用静态方法的时候不需要创建这个类的对象；</p></li><li><p>静态方法可以访问静态变量。</p></li><li><blockquote><p>[!NOTE]</p><p>静态方法不能访问非静态变量和调用非静态方法</p></blockquote></li></ul><p>3）静态代码块</p><p>静态代码块在初始集合的时候，真的非常有用。在实际的项目开发中，通常使用静态代码块来加载配置文件到内存当中。</p><p>4）静态内部类</p><p>Java 允许我们在一个类中声明一个内部类，它提供了一种令人信服的方式，允许我们只在一个地方使用一些变量，使代码更具有条理性和可读性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一次加载 Singleton 类时并不会初始化 instance，只有第一次调用 <code>getInstance()</code> 方法时 Java 虚拟机才开始加载 SingletonHolder 并初始化 instance，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p><ul><li>静态内部类不能访问外部类的所有成员变量；</li><li>静态内部类可以访问外部类的所有静态变量，包括私有静态变量。</li><li>外部类不能声明为 static。”</li></ul><h4 id="1-2-2-final关键字"><a href="#1-2-2-final关键字" class="headerlink" title="1.2.2 final关键字"></a>1.2.2 final关键字</h4><p>1）final 变量</p><p>被final变量修饰的变量无法重新赋值。</p><p>如果是对象，对象不可以重新赋值，但是可以修改对象的私有变量。</p><p>final修饰的成员变量必须有一个默认值。</p><p>final 和 static一起修饰的变量叫做常量，名全部大写。</p><p>2）final方法</p><p>被final修饰的方法不能被重写。</p><p>一个类是 final 的，和一个类不是 final，但它所有的方法都是 final 的，考虑一下，它们之间有什么区别？</p><ul><li>前者不能被<a href="https://javabetter.cn/oo/extends-bigsai.html">继承</a>，也就是说方法无法被重写；后者可以被继承，然后追加一些非 final 的方法。</li></ul><p>3）final类</p><p>一个类使用了 final 关键字修饰，那么它就无法被继承。</p><p> String 类设计成 final 的原因：</p><ul><li>为了实现字符串常量池</li><li>为了线程安全</li><li>为了 HashCode 的不可变性</li></ul><p>*）不可变类</p><ul><li><strong>确保类是 final 的</strong>，不允许被其他类继承。</li><li><strong>确保所有的成员变量（字段）是 final 的</strong>，这样的话，它们就只能在构造方法中初始化值，并且不会在随后被修改。</li><li><strong>不提供任何 setter 方法。</strong></li><li><strong>如果要修改类的状态，必须返回一个新的对象。</strong></li><li>如果一个不可变类中包含了可变类的对象，那么就需要确保返回的是<strong>可变对象的副本</strong>。</li></ul><h4 id="1-2-4-instanceof关键字"><a href="#1-2-4-instanceof关键字" class="headerlink" title="1.2.4 instanceof关键字"></a>1.2.4 instanceof关键字</h4><p>instanceof 关键字的用法其实很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(object) <span class="hljs-keyword">instanceof</span> (type)<br></code></pre></td></tr></table></figure><p>用意也非常简单，判断对象是否符合指定的类型，结果要么是 true，要么是 false。在<a href="https://javabetter.cn/io/serialize.html">反序列化</a>的时候，instanceof 操作符还是蛮常用的，因为这时候我们不太确定对象属不属于指定的类型，如果不进行判断的话，就容易抛出 ClassCastException 异常。</p><p>通常，我们是这样使用 instanceof 操作符的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先判断类型</span><br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String) &#123;<br>    <span class="hljs-comment">// 然后强制转换</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String) obj;<br>    <span class="hljs-comment">// 然后才能使用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>先用 instanceof 进行类型判断，然后再把 obj 强制转换成我们期望的类型再进行使用。</p><p>JDK 16 的时候，instanceof 模式匹配转了正，意味着使用 instanceof 的时候更便捷了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String s) &#123;<br>    <span class="hljs-comment">// 如果类型匹配 直接使用 s</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以直接在 if 条件判断类型的时候添加一个变量，就不需要再强转和声明新的变量了。</p><h3 id="1-3-注解"><a href="#1-3-注解" class="headerlink" title="1.3 注解"></a>1.3 注解</h3><p>注解是一种用于标注的“元数据”</p><h4 id="1-3-1-注解的生命周期"><a href="#1-3-1-注解的生命周期" class="headerlink" title="1.3.1 注解的生命周期"></a>1.3.1 注解的生命周期</h4><p>1）SOURCE：在源文件中有效，被编译器丢弃。</p><p>2）CLASS：在编译器生成的字节码文件中有效，但在运行时会被处理类文件的 JVM 丢弃。</p><p>3）RUNTIME：在运行时有效。这也是注解生命周期中最常用的一种策略，它允许程序通过反射的方式访问注解，并根据注解的定义执行相应的代码。</p><p>一个重要的元注解<code>@Retention</code>定义了<code>Annotation</code>的生命周期：</p><ul><li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li><li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li><li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li></ul><p>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以，务必要加上<code>@Retention(RetentionPolicy.RUNTIME)</code>这个元注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-2-注解的类型"><a href="#1-3-2-注解的类型" class="headerlink" title="1.3.2 注解的类型"></a>1.3.2 注解的类型</h4><p>截止到 Java 9，注解的类型一共有 11 种，定义在 ElementType 枚举中。</p><p>1）TYPE：用于类、接口、注解、枚举</p><p>2）FIELD：用于字段（类的成员变量），或者枚举常量</p><p>3）METHOD：用于方法</p><p>4）PARAMETER：用于普通方法或者构造方法的参数</p><p>5）CONSTRUCTOR：用于构造方法</p><p>6）LOCAL_VARIABLE：用于变量</p><p>7）ANNOTATION_TYPE：用于注解</p><p>8）PACKAGE：用于包</p><p>9）TYPE_PARAMETER：用于泛型参数</p><p>10）TYPE_USE：用于声明语句、泛型或者强制转换语句中的类型</p><p>11）MODULE：用于模块</p><p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p><ul><li>类或接口：<code>ElementType.TYPE</code>；</li><li>字段：<code>ElementType.FIELD</code>；</li><li>方法：<code>ElementType.METHOD</code>；</li><li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li><li>方法参数：<code>ElementType.PARAMETER</code>。</li></ul><p>例如，定义注解<code>@Report</code>可用在方法上，我们必须添加一个<code>@Target(ElementType.METHOD)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-3-如何定义Annotation"><a href="#1-3-3-如何定义Annotation" class="headerlink" title="1.3.3 如何定义Annotation"></a>1.3.3 如何定义Annotation</h4><p><strong>注解参数</strong></p><p>定义一个注解时，还可以定义配置参数。配置参数可以包括：</p><ul><li>所有基本类型；</li><li>String；</li><li>枚举类型；</li><li>基本类型、String、Class以及枚举的数组。</li></ul><p>因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。</p><p>注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。</p><p>此外，大部分注解会有一个名为<code>value</code>的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。</p><p>如果只写注解，相当于全部使用默认值。</p><p><strong>元注解</strong></p><p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）</p><ul><li>@Target：可以定义<code>Annotation</code>能够被应用于源码的哪些位置<ul><li>类或接口：<code>ElementType.TYPE</code>；</li><li>字段：<code>ElementType.FIELD</code>；</li><li>方法：<code>ElementType.METHOD</code>；</li><li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li><li>方法参数：<code>ElementType.PARAMETER</code>。</li></ul></li><li>@Retention：定义了<code>Annotation</code>的生命周期，如果@Retention不存在，则Annotation默认为CLASS<ul><li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li><li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li><li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li></ul></li><li>@Repeatable：定义<code>Annotation</code>是否可重复。</li><li>@Inherited：使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效</li></ul><p>第一步，用<code>@interface</code>定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步，添加参数、默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p><p>第三步，用元注解配置注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p><h3 id="1-4-包、模块"><a href="#1-4-包、模块" class="headerlink" title="1.4 包、模块"></a>1.4 包、模块</h3><h4 id="1-4-1包"><a href="#1-4-1包" class="headerlink" title="1.4.1包"></a>1.4.1包</h4><p>在java中使用包<code>package</code>来解决名字冲突</p><blockquote><p>[!WARNING]</p><p>包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</p></blockquote><h5 id="1）作用域"><a href="#1）作用域" class="headerlink" title="1）作用域"></a>1）作用域</h5><p>位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。</p><h5 id="2）import"><a href="#2）import" class="headerlink" title="2）import"></a>2）import</h5><ul><li>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有<code>class</code>都导入进来（但不包括子包的class），一般不推荐这种写法，因为在导入了多个包后，很难看出<code>Arrays</code>类属于哪个包。</li><li><code>import static</code>的语法，它可以导入一个类的静态字段和静态方法</li></ul><h5 id="3）编译器查找规则"><a href="#3）编译器查找规则" class="headerlink" title="3）编译器查找规则"></a>3）编译器查找规则</h5><p>当编译器遇到一个<code>class</code>名称时：</p><ul><li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li><li>如果是简单类名，按下面的顺序依次查找：<ul><li>查找当前<code>package</code>是否存在这个<code>class</code>；</li><li>查找<code>import</code>的包是否包含这个<code>class</code>；</li><li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li></ul></li></ul><p>如果按照上面的规则还无法确定类名，则编译报错。</p><p>因此，编写class的时候，编译器会自动帮我们做两个import动作：</p><ul><li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</li><li>默认自动<code>import java.lang.*</code>。</li></ul><blockquote><p>[!WARNING]</p><p>自动导入的是java.lang包，类似java.lang.reflect这些包仍需要手动导入。</p></blockquote><h5 id="4）最佳实践"><a href="#4）最佳实践" class="headerlink" title="4）最佳实践"></a>4）最佳实践</h5><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p><ul><li>org.apache</li><li>org.apache.commons.log</li><li>com.liaoxuefeng.sample</li></ul><p>子包就可以根据功能自行命名。</p><p>要注意不要和<code>java.lang</code>包的类重名，即自己的类不要使用这些名字：</p><ul><li>String</li><li>System</li><li>Runtime</li><li>…</li></ul><p>要注意也不要和JDK常用类重名：</p><ul><li><p>java.util.List</p></li><li><p>java.text.Format</p></li><li><p>java.math.BigInteger</p></li></ul><h4 id="1-4-2-内部类"><a href="#1-4-2-内部类" class="headerlink" title="1.4.2 内部类"></a>1.4.2 内部类</h4><h5 id="Inner-Class"><a href="#Inner-Class" class="headerlink" title="Inner Class"></a><strong>Inner Class</strong></h5><p>如果一个类定义在另一个类的内部，这个类就是Inner Class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-comment">// 定义了一个Inner Class</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述定义的<code>Outer</code>是一个普通类，而<code>Inner</code>是一个Inner Class，它与普通类有个最大的不同，就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// inner class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>(<span class="hljs-string">&quot;Nested&quot;</span>); <span class="hljs-comment">// 实例化一个Outer</span><br>        Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> outer.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>(); <span class="hljs-comment">// 实例化一个Inner</span><br>        inner.hello();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    Outer(String name) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + Outer.<span class="hljs-built_in">this</span>.name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Inner Class和普通Class相比，除了能引用Outer实例外，还有一个额外的“特权”，就是可以修改Outer Class的<code>private</code>字段，因为Inner Class的作用域在Outer Class内部，所以能访问Outer Class的<code>private</code>字段和方法。</p><p>Java编译器编译后的<code>.class</code>文件可以发现，<code>Outer</code>类被编译为<code>Outer.class</code>，而<code>Inner</code>类被编译为<code>Outer$Inner.class</code>。</p><h5 id="Anonymous-Class"><a href="#Anonymous-Class" class="headerlink" title="Anonymous Class"></a>Anonymous Class</h5><p>另外一种定义Inner Class的方法，在方法内部，通过匿名类（Anonymous Class）来定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Anonymous Class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>(<span class="hljs-string">&quot;Nested&quot;</span>);<br>        outer.asyncHello();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    Outer(String name) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyncHello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + Outer.<span class="hljs-built_in">this</span>.name);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>观察<code>asyncHello()</code>方法，我们在方法内部实例化了一个<code>Runnable</code>。<code>Runnable</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了<code>Runnable</code>接口的匿名类，并且通过<code>new</code>实例化该匿名类，然后转型为<code>Runnable</code>。</p><p>匿名类和Inner Class一样，可以访问Outer Class的<code>private</code>字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义Inner Class可以少写很多代码。</p><p>观察Java编译器编译后的<code>.class</code>文件可以发现，<code>Outer</code>类被编译为<code>Outer.class</code>，而匿名类被编译为<code>Outer$1.class</code>。如果有多个匿名类，Java编译器会将每个匿名类依次命名为<code>Outer$1</code>、<code>Outer$2</code>、<code>Outer$3</code></p><p><code>引用评论区评论：3.1.11 内部类 new一个 @ 2024/12/2 09:46:48</code></p><p>一上来就整Runnable要吓死新手们的，是这样的： 在 Java 中，匿名内部类必须继承某个类或实现某个接口，因为匿名内部类的本质是定义一个没有名字的子类或实现类，并立即创建它的实例。 匿名内部类的语法规则</p><ol><li>继承一个类：匿名类可以继承一个具体类。</li><li>实现一个接口：匿名类可以实现一个接口，并需要实现接口的所有抽象方法。</li><li>匿名内部类不能同时继承类和实现接口。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Outer的私有字段&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showPrivateMessage</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Outer的私有方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAnonymousClass</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MyInterface</span> <span class="hljs-variable">myInterfaceImpl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterface</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123; <span class="hljs-comment">//实现接口定义的方法</span><br>                System.out.println(name + <span class="hljs-string">&quot;@&quot;</span> + age);<br>                System.out.println(Outer.<span class="hljs-built_in">this</span>.message); <span class="hljs-comment">//用Outer.this访问外部类的私有方法</span><br>                showPrivateMessage(); <span class="hljs-comment">//不用 Outer.this也可以直接访问外部类的私有方法</span><br>            &#125;<br>        &#125;;<br><br>        myInterfaceImpl.show(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().testAnonymousClass();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，由于可以所有类都继承自Object，所以我们也可以写一个继承Object的匿名内部类，使它就像其他没显式继承的类那样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Outer的私有字段&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showPrivateMessage</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Outer的私有方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAnonymousClass</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123; <span class="hljs-comment">//实现接口定义的方法</span><br>                System.out.println(name + <span class="hljs-string">&quot;@&quot;</span> + age);<br>                System.out.println(Outer.<span class="hljs-built_in">this</span>.message); <span class="hljs-comment">//用Outer.this访问外部类的私有方法</span><br>                showPrivateMessage(); <span class="hljs-comment">//不用 Outer.this也可以直接访问外部类的私有方法</span><br>            &#125;<br>        &#125;.show(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Static-Nested-Class"><a href="#Static-Nested-Class" class="headerlink" title="Static Nested Class"></a>Static Nested Class</h5><p>最后一种内部类和Inner Class类似，但是使用<code>static</code>修饰，称为静态内部类（Static Nested Class）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Static Nested Class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Outer.<span class="hljs-type">StaticNested</span> <span class="hljs-variable">sn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>.StaticNested();<br>        sn.hello();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;OUTER&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    Outer(String name) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticNested</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + Outer.NAME);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个完全独立的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。如果把<code>StaticNested</code>移到<code>Outer</code>之外，就失去了访问<code>private</code>的权限。</p><h3 id="1-5-核心类"><a href="#1-5-核心类" class="headerlink" title="1.5 核心类"></a>1.5 核心类</h3><p>一些基础的类例如String、StringBuilder、StringJoiner、以及包装类型，细节不再阐述，只记录一些需要注意的地方。</p><p>1）primitive类型转化为包装类型 Auto Boxing，反之Auto Unboxing</p><p>2）同String，包装类型的比较也需要使用equals()</p><p>3）我们把能创建“新”对象的静态方法称为静态工厂方法。</p><blockquote><p>[!TIP]</p><p>按照语义编程，而不是针对特定的底层实现去“优化”。</p><p>创建新对象时，优先选用静态工厂方法而不是new操作符。</p></blockquote><h4 id="1-5-1-JavaBean"><a href="#1-5-1-JavaBean" class="headerlink" title="1.5.1 JavaBean"></a>1.5.1 JavaBean</h4><p>在Java中，有很多<code>class</code>的定义都符合这样的规范：</p><ul><li>若干<code>private</code>实例字段；</li><li>通过<code>public</code>方法来读写实例字段。</li></ul><p>如果读写方法符合以下这种命名规范：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 读方法:</span><br><span class="hljs-keyword">public</span> Type <span class="hljs-title function_">getXyz</span><span class="hljs-params">()</span><br><span class="hljs-comment">// 写方法:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setXyz</span><span class="hljs-params">(Type value)</span><br></code></pre></td></tr></table></figure><p>那么这种<code>class</code>被称为<code>JavaBean</code>：</p><p>上面的字段是<code>xyz</code>，那么读写方法名分别以<code>get</code>和<code>set</code>开头，并且后接大写字母开头的字段名<code>Xyz</code>，因此两个读写方法名分别是<code>getXyz()</code>和<code>setXyz()</code>。</p><p><code>boolean</code>字段比较特殊，它的读方法一般命名为<code>isXyz()</code>：</p><p>我们通常把一组对应的读方法（<code>getter</code>）和写方法（<code>setter</code>）称为属性（<code>property</code>）。例如，<code>name</code>属性：</p><ul><li>对应的读方法是<code>String getName()</code></li><li>对应的写方法是<code>setName(String)</code></li></ul><p>只有<code>getter</code>的属性称为只读属性（read-only），例如，定义一个age只读属性：</p><ul><li>对应的读方法是<code>int getAge()</code></li><li>无对应的写方法<code>setAge(int)</code></li></ul><p>类似的，只有<code>setter</code>的属性称为只写属性（write-only）。</p><p>很明显，只读属性很常见，只写属性不常见。</p><p>属性只需要定义<code>getter</code>和<code>setter</code>方法，不一定需要对应的字段。</p><h5 id="1）JavaBean的作用"><a href="#1）JavaBean的作用" class="headerlink" title="1）JavaBean的作用"></a>1）JavaBean的作用</h5><p>JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。</p><h5 id="2）枚举JavaBean属性"><a href="#2）枚举JavaBean属性" class="headerlink" title="2）枚举JavaBean属性"></a>2）枚举JavaBean属性</h5><p>要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的<code>Introspector</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.beans.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">BeanInfo</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> Introspector.getBeanInfo(Person.class);<br>        <span class="hljs-keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;<br>            System.out.println(pd.getName());<br>            System.out.println(<span class="hljs-string">&quot;  &quot;</span> + pd.getReadMethod());<br>            System.out.println(<span class="hljs-string">&quot;  &quot;</span> + pd.getWriteMethod());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-5-2-枚举类"><a href="#1-5-2-枚举类" class="headerlink" title="1.5.2 枚举类"></a>1.5.2 枚举类</h4><p>优点：包括类型信息如：月份、星期几、颜色，优于常量定义</p><p><code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点：</p><ul><li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li><li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li><li>定义的每个实例都是引用类型的唯一实例；</li><li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li></ul><p><strong>name()：</strong>返回常量名</p><p><strong>ordinal()：</strong>返回定义常量的顺序</p><h4 id="1-5-4-记录类"><a href="#1-5-4-记录类" class="headerlink" title="1.5.4 记录类"></a>1.5.4 记录类</h4><p>从Java 14开始，引入了新的<code>Record</code>类。我们定义<code>Record</code>类时，使用关键字<code>record</code>。把上述<code>Point</code>类改写为<code>Record</code>类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Record</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Point</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        System.out.println(p.x());<br>        System.out.println(p.y());<br>        System.out.println(p);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">record</span> <span class="hljs-title class_">Point</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>仔细观察<code>Point</code>的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">record</span> <span class="hljs-title class_">Point</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>把上述定义改写为class，相当于以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> y;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Point</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-built_in">this</span>.x = x;<br>        <span class="hljs-built_in">this</span>.y = y;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">x</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">y</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.y;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;Point[x=%s, y=%s]&quot;</span>, x, y);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        ...<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了用<code>final</code>修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写<code>toString()</code>、<code>equals()</code>和<code>hashCode()</code>方法。</p><p>换句话说，使用<code>record</code>关键字，可以一行写出一个不变类。</p><p>和<code>enum</code>类似，我们自己不能直接从<code>Record</code>派生，只能通过<code>record</code>关键字由编译器实现继承。</p><p>假设<code>Point</code>类的<code>x</code>、<code>y</code>不允许负数，我们就得给<code>Point</code>的构造方法加上检查逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">Point</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-keyword">public</span> Point &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到方法<code>public Point &#123;...&#125;</code>被称为Compact Constructor，它的目的是让我们编写检查逻辑，编译器最终生成的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Point</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-comment">// 这是我们编写的Compact Constructor:</span><br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>        &#125;<br>        <span class="hljs-comment">// 这是编译器继续生成的赋值代码:</span><br>        <span class="hljs-built_in">this</span>.x = x;<br>        <span class="hljs-built_in">this</span>.y = y;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>作为<code>record</code>的<code>Point</code>仍然可以添加静态方法。一种常用的静态方法是<code>of()</code>方法，用来创建<code>Point</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">Point</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Point <span class="hljs-title function_">of</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Point <span class="hljs-title function_">of</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(x, y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-异常处理"><a href="#2-异常处理" class="headerlink" title="2. 异常处理"></a>2. 异常处理</h2><h3 id="2-1-异常"><a href="#2-1-异常" class="headerlink" title="2.1 异常"></a>2.1 异常</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">                     ┌───────────┐<br>                     │  Object   │<br>                     └───────────┘<br>                           ▲<br>                           │<br>                     ┌───────────┐<br>                     │ Throwable │<br>                     └───────────┘<br>                           ▲<br>                 ┌─────────┴─────────┐<br>                 │                   │<br>           ┌───────────┐       ┌───────────┐<br>           │   Error   │       │ Exception │<br>           └───────────┘       └───────────┘<br>                 ▲                   ▲<br>         ┌───────┘              ┌────┴──────────┐<br>         │                      │               │<br>┌─────────────────┐    ┌─────────────────┐┌───────────┐<br>│OutOfMemoryError │<span class="hljs-string">...</span> │RuntimeException ││IOException│<span class="hljs-string">...</span><br>└─────────────────┘    └─────────────────┘└───────────┘<br>                                ▲<br>                    ┌───────────┴─────────────┐<br>                    │                         │<br>         ┌─────────────────────┐ ┌─────────────────────────┐<br>         │NullPointerException │ │IllegalArgumentException │<span class="hljs-string">...</span><br>         └─────────────────────┘ └─────────────────────────┘<br></code></pre></td></tr></table></figure><p>从继承关系可知：<code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p><ul><li><code>OutOfMemoryError</code>：内存耗尽</li><li><code>NoClassDefFoundError</code>：无法加载某个Class</li><li><code>StackOverflowError</code>：栈溢出</li></ul><p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p><p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p><ul><li><code>NumberFormatException</code>：数值类型的格式错误</li><li><code>FileNotFoundException</code>：未找到文件</li><li><code>SocketException</code>：读取网络失败</li></ul><p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p><ul><li><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</li><li><code>IndexOutOfBoundsException</code>：数组索引越界</li></ul><p><code>Exception</code>又分为两大类：</p><ol><li><code>RuntimeException</code>以及它的子类；</li><li>非<code>RuntimeException</code>（包括<code>IOException</code>、<code>ReflectiveOperationException</code>等等）</li></ol><p>Java规定：</p><ul><li>必须捕获的异常，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为Checked Exception。</li><li>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</li></ul><h3 id="2-2-抛出异常"><a href="#2-2-抛出异常" class="headerlink" title="2.2 抛出异常"></a>2.2 抛出异常</h3><p>为了能追踪到完整的异常栈，在构造异常的时候，把原始的<code>Exception</code>实例传进去，新的<code>Exception</code>就可以持有原始<code>Exception</code>信息。</p><h3 id="2-3-自定义异常"><a href="#2-3-自定义异常" class="headerlink" title="2.3 自定义异常"></a>2.3 自定义异常</h3><p>Java标准库定义的常用异常包括：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-built_in">Exception</span><br>├─ <span class="hljs-built_in">RuntimeException</span><br>│  ├─ NullPointerException<br>│  ├─ IndexOutOfBoundsException<br>│  ├─ SecurityException<br>│  └─ IllegalArgumentException<br>│     └─ NumberFormatException<br>├─ IOException<br>│  ├─ UnsupportedCharsetException<br>│  ├─ FileNotFoundException<br>│  └─ SocketException<br>├─ ParseException<br>├─ GeneralSecurityException<br>├─ SQLException<br>└─ TimeoutException<br></code></pre></td></tr></table></figure><p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。</p><p>一个常见的做法是自定义一个<code>BaseException</code>作为“根异常”，然后，派生出各种业务类型的异常。</p><p><code>BaseException</code>需要从一个适合的<code>Exception</code>派生，通常建议从<code>RuntimeException</code>派生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他业务类型的异常就可以从<code>BaseException</code>派生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserNotFoundException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseException</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginFailedException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseException</span> &#123;<br>&#125;<br><br>...<br></code></pre></td></tr></table></figure><p>自定义的<code>BaseException</code>应该提供多个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseException</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseException</span><span class="hljs-params">(String message, Throwable cause)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message, cause);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseException</span><span class="hljs-params">(Throwable cause)</span> &#123;<br>        <span class="hljs-built_in">super</span>(cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述构造方法实际上都是原样照抄<code>RuntimeException</code>。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。</p><h3 id="2-4-日志"><a href="#2-4-日志" class="headerlink" title="2.4 日志"></a>2.4 日志</h3><h4 id="2-4-1-JDK-Logging"><a href="#2-4-1-JDK-Logging" class="headerlink" title="2.4.1 JDK Logging"></a>2.4.1 JDK Logging</h4><p>JDK的Logging定义了7个日志级别，从严重到普通：</p><ul><li>SEVERE</li><li>WARNING</li><li>INFO</li><li>CONFIG</li><li>FINE</li><li>FINER</li><li>FINEST</li></ul><p>因为默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。</p><h4 id="2-4-2-Commons-Logging"><a href="#2-4-2-Commons-Logging" class="headerlink" title="2.4.2 Commons Logging"></a>2.4.2 Commons Logging</h4><p>Commons Logging定义了6个日志级别：</p><ul><li>FATAL</li><li>ERROR</li><li>WARNING</li><li>INFO</li><li>DEBUG</li><li>TRACE</li></ul><p>默认级别是<code>INFO</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">mport org.apache.commons.logging.Log;<br><span class="hljs-keyword">import</span> org.apache.commons.logging.LogFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Log</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LogFactory.getLog(Main.class);<br>        log.info(<span class="hljs-string">&quot;start...&quot;</span>);<br>        log.warn(<span class="hljs-string">&quot;end.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-3-Log4j"><a href="#2-4-3-Log4j" class="headerlink" title="2.4.3 Log4j"></a>2.4.3 Log4j</h4><blockquote><p>[!NOTE]</p><p>Apache Log4j 是基于 Java 的日志记录实用程序。Log4j Java 库的作用是记录信息，帮助应用程序顺利运行，确定发生了什么，并在发生错误时帮助进行调试过程。日志记录库通常会将消息写入日志文件或数据库。</p></blockquote><p>Log4j是一种非常流行的日志框架，最新版本是2.x。</p><p>Log4j是一个组件化设计的日志系统，它的架构大致如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros">log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;User signed in.&quot;</span>);<br> │<br> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐<br> ├──▶│ Appender │───▶│ <span class="hljs-built_in"> Filter </span> │───▶│  Layout  │───▶│<span class="hljs-built_in"> Console </span> │<br> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘<br> │<br> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐<br> ├──▶│ Appender │───▶│ <span class="hljs-built_in"> Filter </span> │───▶│  Layout  │───▶│   File   │<br> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘<br> │<br> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐<br> └──▶│ Appender │───▶│ <span class="hljs-built_in"> Filter </span> │───▶│  Layout  │───▶│  Socket  │<br>     └──────────┘    └──────────┘    └──────────┘    └──────────┘<br></code></pre></td></tr></table></figure><p>当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如：</p><ul><li>console：输出到屏幕；</li><li>file：输出到文件；</li><li>socket：通过网络输出到远程计算机；</li><li>jdbc：输出到数据库</li></ul><p>在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出<code>ERROR</code>级别的日志。</p><p>最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。</p><p>上述结构虽然复杂，但我们在实际使用的时候，并不需要关心Log4j的API，而是通过配置文件来配置它。</p><p>以XML配置为例，使用Log4j的时候，我们把一个<code>log4j2.xml</code>的文件放到<code>classpath</code>下就可以让Log4j读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义日志格式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;log.pattern&quot;</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义文件名变量 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 定义Appender，即目的地 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义输出到屏幕 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;err&quot;</span> <span class="hljs-attr">bufferedIO</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;file.err.filename&#125;&quot;</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;file.err.pattern&#125;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;1 MB&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 保留最近10份 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;10&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> /&gt;</span><br>            <span class="hljs-comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;err&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是<code>INFO</code>级别的日志，会自动输出到屏幕，而<code>ERROR</code>级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。</p><p><strong>最佳实践</strong></p><p>在开发阶段，始终使用Commons Logging接口来写入日志，并且开发阶段无需引入Log4j。如果需要把日志写入文件，只需要把正确的配置文件和Log4j相关的jar包放入<code>classpath</code>，就可以自动把日志切换成使用Log4j写入，无需修改任何代码。</p><h4 id="2-4-4-SLF4J-Logback"><a href="#2-4-4-SLF4J-Logback" class="headerlink" title="2.4.4 SLF4J &amp; Logback"></a>2.4.4 SLF4J &amp; Logback</h4><p>因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。</p><p>SLF4J 或 Simple Logging Facade for Java 是各种 Java 日志记录框架（如 Log4j 2 或 Logback）的抽象层。这允许在部署时插入不同的日志记录框架，而无需更改代码。</p><p><strong>SLF4J特性</strong></p><ul><li><p>支持{}作为占位符，修改Commons Loggings中字符串拼接的问题</p></li><li><p>对比一下Commons Logging和SLF4J的接口：</p><table><thead><tr><th>Commons Logging</th><th>SLF4J</th></tr></thead><tbody><tr><td>org.apache.commons.logging.Log</td><td>org.slf4j.Logger</td></tr><tr><td>org.apache.commons.logging.LogFactory</td><td>org.slf4j.LoggerFactory</td></tr></tbody></table></li></ul><h4 id="2-4-5-SLF4J-和-Logback-Log4J的关系"><a href="#2-4-5-SLF4J-和-Logback-Log4J的关系" class="headerlink" title="2.4.5 SLF4J 和 Logback &amp; Log4J的关系"></a>2.4.5 SLF4J 和 Logback &amp; Log4J的关系</h4><p>简单来说、SLF4J是抽象层，Logback和Log4J是通过引入配置来实现SLF4J的具体Api。</p><h5 id="slf4j绑定log4j的用法"><a href="#slf4j绑定log4j的用法" class="headerlink" title="slf4j绑定log4j的用法"></a>slf4j绑定log4j的用法</h5><p><strong>pom.xml添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>配置文件</strong></p><ol><li><p>必须配置root logger和一个appender。</p></li><li><p>日志输出级别</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义日志格式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;log.pattern&quot;</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义文件名变量 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 定义Appender，即目的地 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义输出到屏幕 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;err&quot;</span> <span class="hljs-attr">bufferedIO</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;file.err.filename&#125;&quot;</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;file.err.pattern&#125;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;1 MB&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 保留最近10份 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;10&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> /&gt;</span><br>            <span class="hljs-comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;err&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h5 id="slf4j绑定logback的用法"><a href="#slf4j绑定logback的用法" class="headerlink" title="slf4j绑定logback的用法"></a><strong>slf4j绑定logback的用法</strong></h5><p><strong>pom.xml添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>配置文件</strong></p><p>配置文件几乎和log4j差不多，如下。选择需要的appender就可以了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span> ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- encoders are assigned the type</span><br><span class="hljs-comment">             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg %n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Insert the current time formatted as &quot;yyyyMMdd&#x27;T&#x27;HHmmss&quot; under</span><br><span class="hljs-comment">         the key &quot;bySecond&quot; into the logger context. This value will be</span><br><span class="hljs-comment">         available to all subsequent configuration elements. --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">timestamp</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;bySecond&quot;</span> <span class="hljs-attr">datePattern</span>=<span class="hljs-string">&quot;yyyyMMdd&#x27;T&#x27;HHmmss&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>testFile-$&#123;bySecond&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">append</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">append</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- encoders are assigned the type</span><br><span class="hljs-comment">             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;DAYFILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>logFile.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- daily rollover --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>logFile.%d&#123;yyyy-MM-dd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- keep 30 days&#x27; worth of history capped at 3GB total size --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">totalSizeCap</span>&gt;</span>3GB<span class="hljs-tag">&lt;/<span class="hljs-name">totalSizeCap</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;debug&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;DAYFILE&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>一个日志的样例</strong></p><p>slf4j+logback</p><p><code>logback</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Console Appender: 输出日志到控制台 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 定义日志输出格式 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5level %logger&#123;36&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- File Appender: 输出日志到文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>logs/app.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5level %logger&#123;36&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 设置日志记录的根级别和输出目的地 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>slf4j</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.rce;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Log.class);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        logger.debug(<span class="hljs-string">&quot;This is a debug message&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;This is an info message&quot;</span>);<br>        logger.warn(<span class="hljs-string">&quot;This is a warn message&quot;</span>);<br>        logger.error(<span class="hljs-string">&quot;This is an error message&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>pom.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 使用最新版本 --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- Logback Classic (SLF4J 实现) --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 使用 Logback 最新版本 --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- Logback Core --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-反射"><a href="#3-反射" class="headerlink" title="3. 反射"></a>3. 反射</h2><h3 id="3-1-Class类"><a href="#3-1-Class类" class="headerlink" title="3.1 Class类"></a>3.1 Class类</h3><p>反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p><p>获取class的Class实例方法</p><p>1）直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> String.class;<br></code></pre></td></tr></table></figure><p>2）如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> s.getClass();<br></code></pre></td></tr></table></figure><p>3）如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>[!CAUTION]</p><p>instanceof 不但匹配制定类型，还匹配制定的子类，用&#x3D;&#x3D;判断class实例可以精确的判断数据类型，但不能作子类型比较。</p></blockquote><p>通过Class.newInstance()可以创建类实例，局限是只能调用public的无参构造方法。</p><h4 id="3-1-1-动态加载"><a href="#3-1-1-动态加载" class="headerlink" title="3.1.1 动态加载"></a>3.1.1 动态加载</h4><p>动态加载<code>class</code>的特性对于Java程序非常重要。利用JVM动态加载<code>class</code>的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Commons Logging优先使用Log4j:</span><br><span class="hljs-type">LogFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (isClassPresent(<span class="hljs-string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;<br>    factory = createLog4j();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    factory = createJdkLog();<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isClassPresent</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Class.forName(name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是为什么我们只需要把Log4j的jar包放到classpath中，Commons Logging就会自动使用Log4j的原因。</p><h3 id="3-2-访问字段"><a href="#3-2-访问字段" class="headerlink" title="3.2 访问字段"></a>3.2 访问字段</h3><p><strong>关键类：Field</strong></p><p><code>Class</code>类提供了以下几个方法来获取字段：</p><ul><li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li><li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li><li>Field[] getFields()：获取所有public的field（包括父类）</li><li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li></ul><p><code>Field</code>对象包含了一个字段的所有信息</p><ul><li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li><li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li><li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><h4 id="3-2-1-获取字段值"><a href="#3-2-1-获取字段值" class="headerlink" title="3.2.1 获取字段值"></a>3.2.1 获取字段值</h4><p>先获取<code>Class</code>实例，再获取<code>Field</code>实例，然后，用<code>Field.get(Object)</code>获取指定实例的指定字段的值。</p><p>如果不知道Field实例的名称可以打印所有Fields然后通过name访问。</p><p>正常情况下，<code>Main</code>类无法访问<code>Person</code>类的<code>private</code>字段。要修复错误，可以将<code>private</code>改为<code>public</code>，或者，在调用<code>Object value = f.get(p);</code>前，先写一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">f.setAccessible(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>调用<code>Field.setAccessible(true)</code>的意思是，别管这个字段是不是<code>public</code>，一律允许访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Xiao Ming&quot;</span>, <span class="hljs-number">20</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> p.getClass();<br>        Field[] fields = c.getDeclaredFields();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        f.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> f.get(p);<br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            System.out.println(field.getName());<br>        &#125;<br>        System.out.println(value);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE]</p><p>如果使用反射可以获取<code>private</code>字段的值，那么类的封装还有什么意义？</p><p>答案是正常情况下，我们总是通过<code>p.name</code>来访问<code>Person</code>的<code>name</code>字段，编译器会根据<code>public</code>、<code>protected</code>和<code>private</code>决定是否允许访问字段，这样就达到了数据封装的目的。</p><p>而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</p><p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p></blockquote><h4 id="3-2-2-设置字段值"><a href="#3-2-2-设置字段值" class="headerlink" title="3.2.2 设置字段值"></a>3.2.2 设置字段值</h4><p>设置字段值是通过<code>Field.set(Object, Object)</code>实现的。同样的，修改非<code>public</code>字段，需要首先调用<code>setAccessible(true)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Xiao Ming&quot;</span>, <span class="hljs-number">20</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> p.getClass();<br>        Field[] fields = c.getDeclaredFields();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        f.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> f.get(p);<br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            System.out.println(field.getName());<br>        &#125;<br>        System.out.println(value);<br>      f.set(p, <span class="hljs-string">&quot;Xiao Hong&quot;</span>);<br>        System.out.println(p.getName()); <span class="hljs-comment">// &quot;Xiao Hong&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-调用方法"><a href="#3-3-调用方法" class="headerlink" title="3.3 调用方法"></a>3.3 调用方法</h3><p><strong>关键类：Method</strong></p><p>和访问字段基本一致。首先获得Method对象。</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li></ul><p>根据Method对象获得方法的所有信息</p><ul><li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li><li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li><li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li><li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><p>通过使用invoke方法进行调用。</p><p><code>Object invoke(Object obj, Object... args) throws IllegalAccessException</code></p><p><strong>调用方法</strong></p><p><code>invoke(对象，可变参数)</code></p><p><strong>调用静态方法</strong></p><p><code>invoke(null, 可变参数)</code></p><p><strong>调用非静态方法</strong></p><p>通过<code>Method.setAccessible(true)</code>允许其调用，再使用invoke进行调用。</p><blockquote><p>[!NOTE]</p><p>如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p></blockquote><p><strong>多态</strong></p><p>我们来考察这样一种情况：一个<code>Person</code>类定义了<code>hello()</code>方法，并且它的子类<code>Student</code>也覆写了<code>hello()</code>方法，那么，从<code>Person.class</code>获取的<code>Method</code>，作用于<code>Student</code>实例时，调用的方法到底是哪个？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// reflection</span><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取Person的hello方法:</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> Person.class.getMethod(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-type">int</span>.class, <span class="hljs-type">int</span>.class);<br>        <span class="hljs-comment">// 对Student实例调用hello方法:</span><br>        h.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(), <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Person:hello&quot;</span> + a + b);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Student:hello&quot;</span> + a + b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上述代码，发现打印出的是<code>Student:hello12</code>，因此，使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。并且invoke的参数列表是可变参数列表。</p><h3 id="3-4-调用构造方法"><a href="#3-4-调用构造方法" class="headerlink" title="3.4 调用构造方法"></a>3.4 调用构造方法</h3><p><strong>关键类：Constructor</strong></p><p>由于Class提供的newInstance()方法只能调用该类的无参构造方法，所以使用Constructor对象来返回Class实例的构造函数方法。该构造方法仅与当前类有关，和父类无关，不存在多态的问题。调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li><li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li></ul><h3 id="3-5-获取继承关系"><a href="#3-5-获取继承关系" class="headerlink" title="3.5 获取继承关系"></a>3.5 获取继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取父类</span><br>class.getSuperClass()<br><span class="hljs-comment">// 获取接口</span><br>class.getInterfaces()<br><span class="hljs-comment">// 判断继承关系</span><br><span class="hljs-comment">// 两个Class实例，要判断一个向上转型是否成立，可以调用</span><br>class.isAssignableFrom()<br><br><span class="hljs-comment">// Integer i = ?</span><br>Integer.class.isAssignableFrom(Integer.class); <span class="hljs-comment">// true，因为Integer可以赋值给Integer</span><br><span class="hljs-comment">// Number n = ?</span><br>Number.class.isAssignableFrom(Integer.class); <span class="hljs-comment">// true，因为Integer可以赋值给Number</span><br><span class="hljs-comment">// Object o = ?</span><br>Object.class.isAssignableFrom(Integer.class); <span class="hljs-comment">// true，因为Integer可以赋值给Object</span><br><span class="hljs-comment">// Integer i = ?</span><br>Integer.class.isAssignableFrom(Number.class); <span class="hljs-comment">// false，因为Number不能赋值给Integer</span><br></code></pre></td></tr></table></figure><ul><li>除<code>Object</code>外，其他任何非<code>interface</code>的<code>Class</code>都必定存在一个父类类型。</li><li><code>getInterfaces()</code>只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型</li></ul><h3 id="3-6-动态代理"><a href="#3-6-动态代理" class="headerlink" title="3.6 动态代理"></a>3.6 动态代理</h3><h2 id="4-泛型"><a href="#4-泛型" class="headerlink" title="4. 泛型"></a>4. 泛型</h2><h3 id="4-1-什么是泛型"><a href="#4-1-什么是泛型" class="headerlink" title="4.1 什么是泛型"></a>4.1 什么是泛型</h3><p>对于ArrayList来说，如果数组内容发生改变，那么要重新定义其他的ArrayList以实现适配。为了解决这个问题，我们把ArrayList变成一个模版<code>ArrayList&lt;T&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T e)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样在代码中就可以实现编写一次代码创建为任意类型的ArrayList</p><p><strong>向上转型</strong></p><p>用一个图来表示泛型的继承关系，就是<code>T</code>不变时，可以向上转型，<code>T</code>本身不能向上转型：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">  <span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">Integer</span><span class="hljs-operator">&gt;</span>     <span class="hljs-variable">ArrayList</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">Number</span><span class="hljs-operator">&gt;</span><br>    ▲                            ▲<br>    │                            │<br>    │                            <span class="hljs-variable">X</span><br>    │                            │<br><span class="hljs-variable">ArrayList</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">Integer</span><span class="hljs-operator">&gt;</span>  <span class="hljs-variable">ArrayList</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">Integer</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-2-使用泛型"><a href="#4-2-使用泛型" class="headerlink" title="4.2 使用泛型"></a>4.2 使用泛型</h3><p>使用ArrayList时，如果不定义泛型类型，泛型类型实际上就是Object。</p><p>编译器如果能自动推断吃泛型类型，就可以省略后面的泛型类型，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Number&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 省略ArrayList的范型类型</span><br></code></pre></td></tr></table></figure><p><strong>泛型接口</strong></p><p><code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code>Comparable&lt;T&gt;</code>这个泛型接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回负数: 当前实例比参数o小</span><br><span class="hljs-comment">     * 返回0: 当前实例与参数o相等</span><br><span class="hljs-comment">     * 返回正数: 当前实例比参数o大</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-编写泛型"><a href="#4-3-编写泛型" class="headerlink" title="4.3 编写泛型"></a>4.3 编写泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>静态方法</strong></p><p>编写泛型类时，要特别注意，泛型类型<code>&lt;T&gt;</code>不能用于静态方法。对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的<code>create()</code>静态方法，我们应该把它改为另一种泛型类型，例如，<code>&lt;K&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>    <br><span class="hljs-comment">//    // 对静态方法使用&lt;T&gt;:</span><br><span class="hljs-comment">//    public static Pair&lt;T&gt; create(T first, T last) &#123;</span><br><span class="hljs-comment">//        return new Pair&lt;T&gt;(first, last);</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-comment">// 静态泛型方法应该使用其他类型区分:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K&gt; Pair&lt;K&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(K first, K last)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;K&gt;(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>多个泛型类型</strong></p><p>泛型还可以定义多种类型。例如，我们希望<code>Pair</code>不总是存储两个类型一样的对象，就可以使用类型<code>&lt;T, K&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T, K&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> K last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, K last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123; ... &#125;<br>    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用的时候，需要指出两种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;String, Integer&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>Java标准库的<code>Map&lt;K, V&gt;</code>就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。</p><h3 id="4-4-擦拭法"><a href="#4-4-擦拭法" class="headerlink" title="4.4 擦拭法"></a>4.4 擦拭法</h3><p>Java语言实现泛型的方式是擦拭法（Type Erasure）。</p><p>虚拟机对泛型一无所知，所有的工作都是编译器做的。所以Java泛型是编译器在编译时实行的，编译器内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是，在需要转型的时候，编译器会根据<code>T</code>的类型自动为我们实行安全地强制转型。</p><p>使用泛型的局限</p><ul><li><code>&lt;T&gt;</code>不能是基本类型，例如<code>int</code>，因为实际类型是<code>Object</code>，<code>Object</code>类型无法持有基本类型</li><li>无法取得带泛型的<code>Class</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Pair&lt;String&gt; p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>        Pair&lt;Integer&gt; p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> p1.getClass();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> p2.getClass();<br>        System.out.println(c1==c2); <span class="hljs-comment">// true</span><br>        System.out.println(c1==Pair.class); <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为<code>T</code>是<code>Object</code>，我们对<code>Pair&lt;String&gt;</code>和<code>Pair&lt;Integer&gt;</code>类型获取<code>Class</code>时，获取到的是同一个<code>Class</code>，也就是<code>Pair</code>类的<code>Class</code>。</p><p>换句话说，所有泛型实例，无论<code>T</code>的类型是什么，<code>getClass()</code>返回同一个<code>Class</code>实例，因为编译后它们全部都是<code>Pair&lt;Object&gt;</code>。</p><ul><li><p>无法判断带泛型的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br><span class="hljs-comment">// Compile error:</span><br><span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> Pair&lt;String&gt;) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>原因和前面一样，并不存在<code>Pair&lt;String&gt;.class</code>，而是只有唯一的<code>Pair.class</code>。</p></li><li><p>不能实例化<code>T</code>类型</p></li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>Java的泛型是采用擦拭法实现的；</p><p>擦拭法决定了泛型<code>&lt;T&gt;</code>：</p><ul><li>不能是基本类型，例如：<code>int</code>；</li><li>不能获取带泛型类型的<code>Class</code>，例如：<code>Pair&lt;String&gt;.class</code>；</li><li>不能判断带泛型类型的类型，例如：<code>x instanceof Pair&lt;String&gt;</code>；</li><li>不能实例化<code>T</code>类型，例如：<code>new T()</code>。</li></ul><p>泛型方法要防止重复定义方法，例如：<code>public boolean equals(T obj)</code>；</p><p>子类可以获取父类的泛型类型<code>&lt;T&gt;</code>。</p><h3 id="4-5-extends-通配符"><a href="#4-5-extends-通配符" class="headerlink" title="4.5 extends 通配符"></a>4.5 extends 通配符</h3><p>使用类似<code>&lt;? extends Number&gt;</code>通配符作为方法参数时表示：</p><ul><li>方法内部可以调用获取<code>Number</code>引用的方法，例如：<code>Number n = obj.getFirst();</code>；</li><li>方法内部无法调用传入<code>Number</code>引用的方法（<code>null</code>除外），例如：<code>obj.setFirst(Number n);</code>。</li></ul><p>即一句话总结：使用<code>extends</code>通配符表示可以读，不能写。</p><p>使用类似<code>&lt;T extends Number&gt;</code>定义泛型类时表示：</p><ul><li>泛型类型限定为<code>Number</code>以及<code>Number</code>的子类。</li></ul><h3 id="4-6-super通配符"><a href="#4-6-super通配符" class="headerlink" title="4.6 super通配符"></a>4.6 super通配符</h3><p>我们再回顾一下<code>extends</code>通配符。作为方法参数，<code>&lt;? extends T&gt;</code>类型和<code>&lt;? super T&gt;</code>类型的区别在于：</p><ul><li><code>&lt;? extends T&gt;</code>允许调用读方法<code>T get()</code>获取<code>T</code>的引用，但不允许调用写方法<code>set(T)</code>传入<code>T</code>的引用（传入<code>null</code>除外）；</li><li><code>&lt;? super T&gt;</code>允许调用写方法<code>set(T)</code>传入<code>T</code>的引用，但不允许调用读方法<code>T get()</code>获取<code>T</code>的引用（获取<code>Object</code>除外）。</li></ul><p>一个是允许读不允许写，另一个是允许写不允许读。</p><p>先记住上面的结论，我们来看Java标准库的<code>Collections</code>类定义的<code>copy()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br>    <span class="hljs-comment">// 把src的每个元素复制到dest中:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;src.size(); i++) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> src.get(i);<br>            dest.add(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的作用是把一个<code>List</code>的每个元素依次添加到另一个<code>List</code>中。它的第一个参数是<code>List&lt;? super T&gt;</code>，表示目标<code>List</code>，第二个参数<code>List&lt;? extends T&gt;</code>，表示要复制的<code>List</code>。我们可以简单地用<code>for</code>循环实现复制。在<code>for</code>循环中，我们可以看到，对于类型<code>&lt;? extends T&gt;</code>的变量<code>src</code>，我们可以安全地获取类型<code>T</code>的引用，而对于类型<code>&lt;? super T&gt;</code>的变量<code>dest</code>，我们可以安全地传入<code>T</code>的引用。</p><p>这个<code>copy()</code>方法的定义就完美地展示了<code>extends</code>和<code>super</code>的意图：</p><ul><li><code>copy()</code>方法内部不会读取<code>dest</code>，因为不能调用<code>dest.get()</code>来获取<code>T</code>的引用；</li><li><code>copy()</code>方法内部也不会修改<code>src</code>，因为不能调用<code>src.add(T)</code>。</li></ul><p>这是由编译器检查来实现的。如果在方法代码中意外修改了<code>src</code>，或者意外读取了<code>dest</code>，就会导致一个编译错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br>    <span class="hljs-comment">// 把src的每个元素复制到dest中:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;<br>        ...<br>        <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dest.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// compile error!</span><br>        src.add(t); <span class="hljs-comment">// compile error!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个<code>copy()</code>方法的另一个好处是可以安全地把一个<code>List&lt;Integer&gt;</code>添加到<code>List&lt;Number&gt;</code>，但是无法反过来添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// copy List&lt;Integer&gt; to List&lt;Number&gt; ok:</span><br>List&lt;Number&gt; numList = ...;<br>List&lt;Integer&gt; intList = ...;<br>Collections.copy(numList, intList);<br><br><span class="hljs-comment">// ERROR: cannot copy List&lt;Number&gt; to List&lt;Integer&gt;:</span><br>Collections.copy(intList, numList);<br></code></pre></td></tr></table></figure><p>而这些都是通过<code>super</code>和<code>extends</code>通配符，并由编译器强制检查来实现的。</p><h5 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h5><p>何时使用<code>extends</code>，何时使用<code>super</code>？为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。</p><p>即：如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符。</p><p>还是以<code>Collections</code>的<code>copy()</code>方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;src.size(); i++) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> src.get(i); <span class="hljs-comment">// src是producer</span><br>            dest.add(t); <span class="hljs-comment">// dest是consumer</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要返回<code>T</code>的<code>src</code>是生产者，因此声明为<code>List&lt;? extends T&gt;</code>，需要写入<code>T</code>的<code>dest</code>是消费者，因此声明为<code>List&lt;? super T&gt;</code>。</p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>使用类似<code>&lt;? super Integer&gt;</code>通配符作为方法参数时表示：</p><ul><li>方法内部可以调用传入<code>Integer</code>引用的方法，例如：<code>obj.setFirst(Integer n);</code>；</li><li>方法内部无法调用获取<code>Integer</code>引用的方法（<code>Object</code>除外），例如：<code>Integer n = obj.getFirst();</code>。</li></ul><p>即使用<code>super</code>通配符表示只能写不能读。</p><p>使用<code>extends</code>和<code>super</code>通配符要遵循PECS原则。</p><p>无限定通配符<code>&lt;?&gt;</code>很少使用，可以用<code>&lt;T&gt;</code>替换，同时它是所有<code>&lt;T&gt;</code>类型的超类。</p><h3 id="4-7-泛型和反射"><a href="#4-7-泛型和反射" class="headerlink" title="4.7 泛型和反射"></a>4.7 泛型和反射</h3><h2 id="5-集合"><a href="#5-集合" class="headerlink" title="5. 集合"></a>5. 集合</h2><h3 id="5-1-List"><a href="#5-1-List" class="headerlink" title="5.1 List"></a>5.1 List</h3><p>Java中list接口主要有两种实现形式</p><table><thead><tr><th></th><th>ArrayList（优先使用）</th><th>LinkedList</th></tr></thead><tbody><tr><td>获取指定元素</td><td>速度很快</td><td>需要从头开始查找元素</td></tr><tr><td>添加元素到末尾</td><td>速度很快</td><td>速度很快</td></tr><tr><td>在指定位置添加&#x2F;删除</td><td>需要移动元素</td><td>不需要移动元素</td></tr><tr><td>内存占用</td><td>少</td><td>较大</td></tr></tbody></table><p>主要的接口方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E e)</span><br>E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object e)</span><br>E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><h4 id="5-1-1-List使用"><a href="#5-1-1-List使用" class="headerlink" title="5.1.1 List使用"></a>5.1.1 List使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化</span><br>List&lt;Integer&gt; list = List.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);<span class="hljs-comment">// 不接受传入null值</span><br><span class="hljs-comment">// 或者使用ArrayList和LinkedList初始化，接受null值</span><br><br><span class="hljs-comment">// 遍历</span><br><span class="hljs-comment">// 1 不推荐，一是代码复杂，二是因为get(int)方法只有ArrayList的实现是高效的，换成LinkedList后，索引越大，访问速度越慢。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> list.get(i);<br>&#125;<br><br><span class="hljs-comment">// 2 使用迭代器Iterator来访问List</span><br><span class="hljs-keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();<br>&#125;<br><br><span class="hljs-comment">// 3 等价于迭代器的for each循环</span><br><span class="hljs-keyword">for</span> (String s : list) &#123;<br>    System.out.println(s);<br>&#125;<br><br><span class="hljs-comment">// List Array转换</span><br><span class="hljs-comment">// 使用toArray()方法会返回一个Object[]数组，丢失信息</span><br><span class="hljs-comment">// 在toArray(T[])方法中传入类型相同的Array来解决类型丢失的问题</span><br>List&lt;Integer&gt; list = List.of(<span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">56</span>);<br>Integer[] array = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[list.size()]);<br><span class="hljs-keyword">for</span> (Integer n : array) &#123;<br>    System.out.println(n);<br>&#125;<br><br><span class="hljs-comment">// equals方法</span><br><span class="hljs-comment">// List的contain() indexOf()的方法使用equals方法进行元素比较，因此如果需要使用这两个方法，必须要重写equals方法</span><br></code></pre></td></tr></table></figure><h5 id="编写equals"><a href="#编写equals" class="headerlink" title="编写equals"></a>编写equals</h5><p>如何正确编写<code>equals()</code>方法？<code>equals()</code>方法要求我们必须满足以下条件：</p><ul><li>自反性（Reflexive）：对于非<code>null</code>的<code>x</code>来说，<code>x.equals(x)</code>必须返回<code>true</code>；</li><li>对称性（Symmetric）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，则<code>y.equals(x)</code>也必须为<code>true</code>；</li><li>传递性（Transitive）：对于非<code>null</code>的<code>x</code>、<code>y</code>和<code>z</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么<code>x.equals(z)</code>也必须为<code>true</code>；</li><li>一致性（Consistent）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，只要<code>x</code>和<code>y</code>状态不变，则<code>x.equals(y)</code>总是一致地返回<code>true</code>或者<code>false</code>；</li><li>对<code>null</code>的比较：即<code>x.equals(null)</code>永远返回<code>false</code>。</li></ul><ol><li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li><li>用<code>instanceof</code>判断传入的待比较的<code>Object</code>是不是当前类型，如果是，继续比较，否则，返回<code>false</code>；</li><li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li></ol><h3 id="5-2-Map"><a href="#5-2-Map" class="headerlink" title="5.2 Map"></a>5.2 Map</h3><p>主要方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">put(K key, V value);<br>V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">containsKey</span><span class="hljs-params">(K key)</span><br>List&lt;K&gt; <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span><br>List&lt;Entry&lt;String, Integer&gt;&gt; <span class="hljs-title function_">entrySet</span><span class="hljs-params">()</span><br><br></code></pre></td></tr></table></figure><blockquote><p>[!IMPORTANT]</p><p>Map中不存在重复的key，因为放入相同的key，只会把原有的key-value对应的value给替换掉。</p><p>遍历Map时，不可假设输出的key是有序的！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 遍历Map,Map存储的是key-value的映射关系，并且，它不保证顺序</span><br><span class="hljs-keyword">for</span> (String key : map.keySet()) &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(key);<br>    System.out.println(key + <span class="hljs-string">&quot; = &quot;</span> + value);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="编写hashCode方法"><a href="#编写hashCode方法" class="headerlink" title="编写hashCode方法"></a>编写hashCode方法</h5><p>在Map内部对key的比较是通过equals()实现的。而通过key计算索引的方式就是调用key对象的hashCode()方法，返回一个int即value的索引，继而返回value。</p><p>正确使用<code>Map</code>必须保证：</p><ol><li><p>作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法，相等的两个<code>key</code>实例调用<code>equals()</code>必须返回<code>true</code>；</p></li><li><p>作为key</p><p>的对象还必须正确覆写hashCode()</p><p>方法，且hashCode()方法要严格遵循以下规范：</p><ul><li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li><li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li></ul></li></ol><p>和实现<code>equals()</code>方法遇到的问题类似，如果<code>firstName</code>或<code>lastName</code>为<code>null</code>，上述代码工作起来就会抛<code>NullPointerException</code>。为了解决这个问题，我们在计算<code>hashCode()</code>的时候，经常借助<code>Objects.hash()</code>来计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Objects.hash(firstName, lastName, age);<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，编写<code>equals()</code>和<code>hashCode()</code>遵循的原则是：</p><p><code>equals()</code>用到的用于比较的每一个字段，都必须在<code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，绝不可放在<code>hashCode()</code>中计算。</p><blockquote><p>[!NOTE]</p><p><code>hashCode()</code>方法编写得越好，<code>HashMap</code>工作的效率就越高。</p></blockquote><h4 id="5-2-1-EnumMap"><a href="#5-2-1-EnumMap" class="headerlink" title="5.2.1 EnumMap"></a>5.2.1 EnumMap</h4><p>如果作为key的对象是<code>enum</code>类型，那么，还可以使用Java集合库提供的一种<code>EnumMap</code>，它在内部以一个非常紧凑的数组存储value，并且根据<code>enum</code>类型的key直接定位到内部数组的索引，并不需要计算<code>hashCode()</code>，不但效率最高，而且没有额外的空间浪费。</p><h4 id="5-2-2-有序Map"><a href="#5-2-2-有序Map" class="headerlink" title="5.2.2 有序Map"></a>5.2.2 <strong>有序Map</strong></h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">      ┌───┐<br>       │<span class="hljs-built_in">Map</span>│<br>       └───┘<br>         ▲<br>    ┌────┴─────┐<br>    │          │<br>┌───────┐ ┌─────────┐<br>│<span class="hljs-variable">HashMap</span>│ │<span class="hljs-variable">SortedMap</span>│<br>└───────┘ └─────────┘<br>               ▲<br>               │<br>          ┌─────────┐<br>          │ <span class="hljs-built_in">TreeMap</span> │<br>          └─────────┘<br></code></pre></td></tr></table></figure><p><code>SortedMap</code>是根据key进行排序的map。<code>SortedMap</code>是接口，它的实现类是<code>TreeMap</code>。</p><p>使用<code>TreeMap</code>时，放入的Key必须实现<code>Comparable</code>接口。<code>String</code>、<code>Integer</code>这些类已经实现了<code>Comparable</code>接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求。</p><blockquote><p>[!WARNING]</p><p>使用TreeMap时，对Key的比较需要正确实现相等、大于和小于逻辑！</p></blockquote><p>如果作为Key的class没有实现<code>Comparable</code>接口，那么，必须在创建<code>TreeMap</code>时同时指定一个自定义排序算法，<code>TreeMap</code>在比较两个Key是否相等时，依赖Key的<code>compareTo()</code>方法或者<code>Comparator.compare()</code>方法。在两个Key相等时，必须返回<code>0</code>。：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自己实现compare方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student p1, Student p2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (p1.score == p2.score) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1.score &gt; p2.score ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用key的compareTo方法</span><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;Person, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Person&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Person p1, Person p2)</span> &#123;<br>                <span class="hljs-keyword">return</span> p1.name.compareTo(p2.name);<br>            &#125;<br>        &#125;);<br>        map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Tom&quot;</span>), <span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>), <span class="hljs-number">2</span>);<br>        map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Lily&quot;</span>), <span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (Person key : map.keySet()) &#123;<br>            System.out.println(key);<br>        &#125;<br>        <span class="hljs-comment">// &#123;Person: Bob&#125;, &#123;Person: Lily&#125;, &#123;Person: Tom&#125;</span><br>        System.out.println(map.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>))); <span class="hljs-comment">// 2</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    Person(String name) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;Person: &quot;</span> + name + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-3-Properties"><a href="#5-2-3-Properties" class="headerlink" title="5.2.3 Properties"></a>5.2.3 Properties</h4><p>典型配置文件：springboot.properties</p><p>配置文件非常常用，所以Java集合库提供了一个<code>Properties</code>来表示一组“配置”。由于历史遗留原因，<code>Properties</code>内部本质上是一个<code>Hashtable</code>，但我们只需要用到<code>Properties</code>自身关于读写配置的接口。</p><h5 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h5><p>用<code>Properties</code>读取配置文件，一共有三步：</p><ol><li>创建<code>Properties</code>实例；</li><li>调用<code>load()</code>读取文件；</li><li>调用<code>getProperty()</code>获取配置。</li></ol><p>调用<code>getProperty()</code>获取配置时，如果key不存在，将返回<code>null</code>。我们还可以提供一个默认值，这样，当key不存在的时候，就返回默认值。</p><h5 id="写入配置文件"><a href="#写入配置文件" class="headerlink" title="写入配置文件"></a>写入配置文件</h5><p>通过<code>setProperty()</code>修改<code>Properties</code>实例</p><h3 id="5-3-Set"><a href="#5-3-Set" class="headerlink" title="5.3 Set"></a>5.3 Set</h3><p>主要方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object e)</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object e)</span><br></code></pre></td></tr></table></figure><p>最常用的Set的实现类是HashSet，HashSet是HashMap的简单封装；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSet</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Set</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// 持有一个HashMap:</span><br>    <span class="hljs-keyword">private</span> HashMap&lt;E, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 放入HashMap的value:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.put(e, PRESENT) == <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.containsKey(o);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.remove(o) == PRESENT;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Set</code>接口并不保证有序，而<code>SortedSet</code>接口则保证元素是有序的：</p><ul><li><code>HashSet</code>是无序的，因为它实现了<code>Set</code>接口，并没有实现<code>SortedSet</code>接口；</li><li><code>TreeSet</code>是有序的，因为它实现了<code>SortedSet</code>接口。</li><li>使用<code>TreeSet</code>和使用<code>TreeMap</code>的要求一样，添加的元素必须正确实现<code>Comparable</code>接口，如果没有实现<code>Comparable</code>接口，那么创建<code>TreeSet</code>时必须传入一个<code>Comparator</code>对象。</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gams">       ┌───┐<br>       │<span class="hljs-keyword">Set</span>│<br>       └───┘<br>         ▲<br>    ┌────┴─────┐<br>    │          │<br>┌───────┐ ┌─────────┐<br>│HashSet│ │SortedSet│<br>└───────┘ └─────────┘<br>               ▲<br>               │<br>          ┌─────────┐<br>          │ TreeSet │<br>          └─────────┘<br></code></pre></td></tr></table></figure><h3 id="5-4-Queue"><a href="#5-4-Queue" class="headerlink" title="5.4 Queue"></a>5.4 Queue</h3><h4 id="5-4-1-Queue"><a href="#5-4-1-Queue" class="headerlink" title="5.4.1 Queue"></a>5.4.1 Queue</h4><p>队列是一种经常使用的集合。<code>Queue</code>实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和<code>List</code>的区别在于，<code>List</code>可以在任意位置添加和删除元素，而<code>Queue</code>只有两个操作：</p><ul><li>把元素添加到队列末尾；</li><li>从队列头部取出元素。</li></ul><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>：获取队列长度；<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E)</span>/<span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E)</span>：添加元素到队尾；<br>E <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>/E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>：获取队首元素并从队列中删除；<br>E <span class="hljs-title function_">element</span><span class="hljs-params">()</span>/E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>：获取队首元素但并不从队列中删除。<br></code></pre></td></tr></table></figure><p>对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：</p><table><thead><tr><th></th><th>throw Exception</th><th>返回false或null</th></tr></thead><tbody><tr><td>添加元素到队尾</td><td>add(E e)</td><td>boolean offer(E e)</td></tr><tr><td>取队首元素并删除</td><td>E remove()</td><td>E poll()</td></tr><tr><td>取队首元素但不删除</td><td>E element()</td><td>E peek()</td></tr></tbody></table><ul><li><strong>注意：</strong><code>LinkedList</code>即实现了<code>List</code>接口，又实现了<code>Queue</code>接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这是一个List:</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-comment">// 这是一个Queue:</span><br>Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>始终按照面向抽象编程的原则编写代码，可以大大提高代码的质量。</p><h4 id="5-4-2-PriorityQueue"><a href="#5-4-2-PriorityQueue" class="headerlink" title="5.4.2 PriorityQueue"></a>5.4.2 PriorityQueue</h4><p><code>PriorityQueue</code>和<code>Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对<code>PriorityQueue</code>调用<code>remove()</code>或<code>poll()</code>方法，返回的总是优先级最高的元素。</p><p>要使用<code>PriorityQueue</code>，我们就必须给每个元素定义“优先级”。我们以实际代码为例，先看看<code>PriorityQueue</code>的行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Queue&lt;String&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-string">&quot;apple&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;pear&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;banana&quot;</span>);<br>        System.out.println(q.poll()); <span class="hljs-comment">// apple</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// banana</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// pear</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// null,因为队列为空</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们放入的顺序是<code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;banana&quot;</code>，但是取出的顺序却是<code>&quot;apple&quot;</code>、<code>&quot;banana&quot;</code>、<code>&quot;pear&quot;</code>，这是因为从字符串的排序看，<code>&quot;apple&quot;</code>排在最前面，<code>&quot;pear&quot;</code>排在最后面。</p><p><strong>因此，放入<code>PriorityQueue</code>的元素，必须实现<code>Comparable</code>接口或者提供一个Comparator的对象，<code>PriorityQueue</code>会根据元素的排序顺序决定出队的优先级。</strong></p><p><strong>银行排队业务实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Queue&lt;User&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserComparator</span>());<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;A1&quot;</span>));<br>        q.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;A2&quot;</span>));<br>        q.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Boss&quot;</span>, <span class="hljs-string">&quot;V1&quot;</span>));<br>        System.out.println(q.poll()); <span class="hljs-comment">// Boss/V1</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// Bob/A1</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// Alice/A2</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// null,因为队列为空</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;User&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(User u1, User u2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (u1.number.charAt(<span class="hljs-number">0</span>) == u2.number.charAt(<span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-comment">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span><br>          <span class="hljs-comment">// 这里实现有问题，不应该使用String的compareTo方法，会导致A10排在A2的前面</span><br>            <span class="hljs-keyword">return</span> u1.number.compareTo(u2.number);<br>          <span class="hljs-comment">// 修改</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> Integer.parseInt(u1.number);<br>          <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> Integer.parseInt(u2.number);<br>          <span class="hljs-keyword">return</span> Integer.compare(num1,num2);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (u1.number.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;V&#x27;</span>) &#123;<br>            <span class="hljs-comment">// u1的号码是V开头,优先级高:</span><br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String number;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, String number)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;/&quot;</span> + number;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-4-3-Deque-双端队列"><a href="#5-4-3-Deque-双端队列" class="headerlink" title="5.4.3 Deque 双端队列"></a>5.4.3 Deque 双端队列</h4><p>们来比较一下<code>Queue</code>和<code>Deque</code>出队和入队的方法：</p><table><thead><tr><th></th><th>Queue</th><th>Deque</th></tr></thead><tbody><tr><td>添加元素到队尾</td><td>add(E e) &#x2F; offer(E e)</td><td>addLast(E e) &#x2F; offerLast(E e)</td></tr><tr><td>取队首元素并删除</td><td>E remove() &#x2F; E poll()</td><td>E removeFirst() &#x2F; E pollFirst()</td></tr><tr><td>取队首元素但不删除</td><td>E element() &#x2F; E peek()</td><td>E getFirst() &#x2F; E peekFirst()</td></tr><tr><td>添加元素到队首</td><td>无</td><td>addFirst(E e) &#x2F; offerFirst(E e)</td></tr><tr><td>取队尾元素并删除</td><td>无</td><td>E removeLast() &#x2F; E pollLast()</td></tr><tr><td>取队尾元素但不删除</td><td>无</td><td>E getLast() &#x2F; E peekLast()</td></tr></tbody></table><p>使用<code>Deque</code>，推荐总是明确调用<code>offerLast()</code>&#x2F;<code>offerFirst()</code>或者<code>pollFirst()</code>&#x2F;<code>pollLast()</code>方法。</p><p><code>Deque</code>是一个接口，它的实现类有<code>ArrayDeque</code>和<code>LinkedList</code>。</p><p>我们发现<code>LinkedList</code>真是一个全能选手，它即是<code>List</code>，又是<code>Queue</code>，还是<code>Deque</code>。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不推荐的写法:</span><br>LinkedList&lt;String&gt; d1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>d1.offerLast(<span class="hljs-string">&quot;z&quot;</span>);<br><span class="hljs-comment">// 推荐的写法：</span><br>Deque&lt;String&gt; d2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>d2.offerLast(<span class="hljs-string">&quot;z&quot;</span>);<br></code></pre></td></tr></table></figure><p>可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。</p><h4 id="5-4-4-Stack"><a href="#5-4-4-Stack" class="headerlink" title="5.4.4 Stack"></a>5.4.4 Stack</h4><p>栈（Stack）是一种后进先出（LIFO）的数据结构，操作栈的元素的方法有：</p><ul><li>把元素压栈：<code>push(E)</code>；</li><li>把栈顶的元素“弹出”：<code>pop(E)</code>；</li><li>取栈顶元素但不弹出：<code>peek(E)</code>。</li></ul><p>在Java中，我们用<code>Deque</code>可以实现<code>Stack</code>的功能，注意只调用<code>push()</code>&#x2F;<code>pop()</code>&#x2F;<code>peek()</code>方法，避免调用<code>Deque</code>的其他方法；</p><p>不要使用遗留类<code>Stack</code>。</p><h5 id="实现案例"><a href="#实现案例" class="headerlink" title="实现案例"></a>实现案例</h5><p><strong>JVM方法调用栈</strong></p><p><strong>计算中缀表达式</strong></p><h3 id="5-5-Iterator"><a href="#5-5-Iterator" class="headerlink" title="5.5 Iterator"></a>5.5 Iterator</h3><p> Java的集合类都可以使用<code>for each</code>循环，<code>List</code>、<code>Set</code>和<code>Queue</code>会迭代每个元素，<code>Map</code>会迭代每个key。以<code>List</code>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>);<br><span class="hljs-keyword">for</span> (String s : list) &#123;<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，Java编译器并不知道如何遍历<code>List</code>。上述代码能够编译通过，只是因为编译器把<code>for each</code>循环通过<code>Iterator</code>改写为了普通的<code>for</code>循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;<br>     <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();<br>     System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们把这种通过<code>Iterator</code>对象遍历集合的模式称为迭代器。</p><p>在编写<code>Iterator</code>的时候，我们通常可以用一个内部类来实现<code>Iterator</code>接口，这个内部类可以直接访问对应的外部类的所有字段和方法。例如，上述代码中，内部类<code>ReverseIterator</code>可以用<code>ReverseList.this</code>获得当前外部类的<code>this</code>引用，然后，通过这个<code>this</code>引用就可以访问<code>ReverseList</code>的所有字段和方法。</p><h3 id="5-6-Collections"><a href="#5-6-Collections" class="headerlink" title="5.6 Collections"></a>5.6 Collections</h3><ol><li><p>创建空集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">List</span>.<span class="hljs-title function_">of</span>()<span class="hljs-string">`、`</span><span class="hljs-title class_">Map</span>.<span class="hljs-title function_">of</span>()<span class="hljs-string">`、`</span><span class="hljs-title class_">Set</span>.<span class="hljs-title function_">of</span>() <span class="hljs-comment">//jdk9+</span><br></code></pre></td></tr></table></figure></li><li><p>创建单元素集合</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">List</span>.of(T<span class="hljs-params">...</span>)<span class="hljs-string">`、`</span><span class="hljs-built_in">Map</span>.of(T<span class="hljs-params">...</span>)<span class="hljs-string">`、`</span><span class="hljs-built_in">Set</span>.of(T<span class="hljs-params">...</span>) <span class="hljs-comment">// jdk9+</span><br></code></pre></td></tr></table></figure></li><li><p>排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(list);<br></code></pre></td></tr></table></figure></li><li><p>洗牌</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.shuffle(list);<br></code></pre></td></tr></table></figure></li><li><p>不可变集合</p></li><li><p>线程安全集合</p></li></ol><h2 id="6-I-O"><a href="#6-I-O" class="headerlink" title="6. I&#x2F;O"></a>6. I&#x2F;O</h2><h3 id="6-1-IO流简介"><a href="#6-1-IO流简介" class="headerlink" title="6.1 IO流简介"></a>6.1 IO流简介</h3><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p><strong>字节流</strong></p><p><strong>字符流</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/Sinte-Beuve/p/5758971.html">https://www.cnblogs.com/Sinte-Beuve/p/5758971.html</a></p><p><a href="https://roadmap.sh/java">https://roadmap.sh/java</a></p><p><a href="https://liaoxuefeng.com/https://liaoxuefeng.com/">廖雪峰的官方网站</a></p><p><a href="https://javabetter.cn/home.html">二哥的Java进阶之路</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
