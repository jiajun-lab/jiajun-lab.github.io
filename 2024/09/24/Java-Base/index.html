

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/source/img/siteicon.jpg">
  <link rel="icon" href="/source/img/siteicon.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lee">
  <meta name="keywords" content="">
  
    <meta name="description" content="Java基础0. 一些问题1. Java的语言产品为JDK，JDK组成 JVM 核心类库 JRE &#x3D; JVM+核心类库 java开发工具 JDK &#x3D; JRE + java开发工具   2. Long term Support： JDK-8（开发环境） JDK-11 JDK17（教学阶段）3. java 是执行工具 javac是编译工具4. win问题 文件扩展名问题 环境变量：">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Base">
<meta property="og:url" content="https://jiajun-lab.github.io/2024/09/24/Java-Base/index.html">
<meta property="og:site_name" content="Lee&#39;s Blog">
<meta property="og:description" content="Java基础0. 一些问题1. Java的语言产品为JDK，JDK组成 JVM 核心类库 JRE &#x3D; JVM+核心类库 java开发工具 JDK &#x3D; JRE + java开发工具   2. Long term Support： JDK-8（开发环境） JDK-11 JDK17（教学阶段）3. java 是执行工具 javac是编译工具4. win问题 文件扩展名问题 环境变量：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jiajun-lab.github.io/2024/09/24/Java-Base/image-20240822185158268.png">
<meta property="og:image" content="https://jiajun-lab.github.io/2024/09/24/Java-Base/image-20240923100409956.png">
<meta property="og:image" content="https://jiajun-lab.github.io/2024/09/24/Java-Base/image-20240923105349172.png">
<meta property="og:image" content="https://jiajun-lab.github.io/2024/09/24/Java-Base/image-20240923105554025.png">
<meta property="og:image" content="https://jiajun-lab.github.io/2024/09/24/Java-Base/java-code-to-machine-code.png">
<meta property="og:image" content="https://jiajun-lab.github.io/2024/09/24/Java-Base/image-20240925153827361.png">
<meta property="og:image" content="https://jiajun-lab.github.io/2024/09/24/Java-Base/image-20240925153940994.png">
<meta property="og:image" content="https://jiajun-lab.github.io/2024/09/24/Java-Base/jvm-rough-structure-model.png">
<meta property="og:image" content="https://jiajun-lab.github.io/2024/09/24/Java-Base/extends-bigsai-0cd258c9-b897-4be3-bdb2-2ddd9c073609.png">
<meta property="og:image" content="https://jiajun-lab.github.io/2024/09/24/Java-Base/extends-bigsai-0cd258c9-b897-4be3-bdb2-2ddd9c073609.png">
<meta property="og:image" content="https://jiajun-lab.github.io/2024/09/24/Java-Base/extends-bigsai-ef0d4716-8b4f-4adf-845e-dd293871b7a7.png">
<meta property="article:published_time" content="2024-09-24T06:39:25.000Z">
<meta property="article:modified_time" content="2025-09-16T01:35:12.933Z">
<meta property="article:author" content="Lee">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://jiajun-lab.github.io/2024/09/24/Java-Base/image-20240822185158268.png">
  
  
  
  <title>Java Base - Lee&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"jiajun-lab.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"tUYpg6nx1J5VCJamrfWcKQkl-gzGzoHsz","app_key":"HM1AWutkOYJ9mXYNjwqc7gSy","server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lee&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java Base"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-09-24 14:39" pubdate>
          2024年9月24日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          22k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          184 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java Base</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="0-一些问题"><a href="#0-一些问题" class="headerlink" title="0. 一些问题"></a>0. 一些问题</h2><h4 id="1-Java的语言产品为JDK，JDK组成"><a href="#1-Java的语言产品为JDK，JDK组成" class="headerlink" title="1. Java的语言产品为JDK，JDK组成"></a>1. Java的语言产品为<strong>JDK</strong>，JDK组成</h4><ol>
<li>JVM</li>
<li>核心类库</li>
<li>JRE &#x3D; JVM+核心类库</li>
<li>java开发工具</li>
<li>JDK &#x3D; JRE + java开发工具</li>
<li><img src="/2024/09/24/Java-Base/image-20240822185158268.png" srcset="/img/loading.gif" lazyload alt="image-20240822185158268"></li>
</ol>
<h4 id="2-Long-term-Support：-JDK-8（开发环境）-JDK-11-JDK17（教学阶段）"><a href="#2-Long-term-Support：-JDK-8（开发环境）-JDK-11-JDK17（教学阶段）" class="headerlink" title="2. Long term Support： JDK-8（开发环境） JDK-11 JDK17（教学阶段）"></a>2. Long term Support： <strong>JDK-8（开发环境） JDK-11 JDK17（教学阶段）</strong></h4><h4 id="3-java-是执行工具-javac是编译工具"><a href="#3-java-是执行工具-javac是编译工具" class="headerlink" title="3. java 是执行工具 javac是编译工具"></a>3. java 是执行工具 javac是编译工具</h4><h4 id="4-win问题"><a href="#4-win问题" class="headerlink" title="4. win问题"></a>4. win问题</h4><ol>
<li>文件扩展名问题</li>
<li>环境变量：用于在命令行任意目录启动程序。</li>
</ol>
<h4 id="5-Java跨平台：编译一次，处处可用"><a href="#5-Java跨平台：编译一次，处处可用" class="headerlink" title="5. Java跨平台：编译一次，处处可用"></a>5. Java跨平台：编译一次，处处可用</h4><h4 id="6-方法重载：在一个类中，多个方法的名称相同，但是形参列表不同，称这些方法重载。"><a href="#6-方法重载：在一个类中，多个方法的名称相同，但是形参列表不同，称这些方法重载。" class="headerlink" title="6. 方法重载：在一个类中，多个方法的名称相同，但是形参列表不同，称这些方法重载。"></a>6. 方法重载：在一个类中，多个方法的名称相同，但是形参列表不同，称这些方法重载。</h4><ol>
<li>形参个数、类型、顺序不同</li>
<li>与返回值无关，只要名称相同，形参列表不同，即为方法重载</li>
</ol>
<h4 id="7-为什么要打包-package"><a href="#7-为什么要打包-package" class="headerlink" title="7. 为什么要打包 package"></a>7. 为什么要打包 package</h4><ol>
<li>将相似的功能放在同一个包里方便使用</li>
<li>分开相同名称的类<ol>
<li>shopping.List</li>
<li>Packing.List</li>
</ol>
</li>
</ol>
<h4 id="8-特殊的类"><a href="#8-特殊的类" class="headerlink" title="8. 特殊的类"></a>8. 特殊的类</h4><ol>
<li><p>所有类都可以看到相同包下的其他类，不需要导入</p>
</li>
<li><p>所有类都可以看到在java.lang中的类</p>
</li>
<li><p><img src="/2024/09/24/Java-Base/image-20240923100409956.png" srcset="/img/loading.gif" lazyload alt="image-20240923100409956"></p>
</li>
</ol>
<h4 id="9-TreeSet和HashSet的区别"><a href="#9-TreeSet和HashSet的区别" class="headerlink" title="9. TreeSet和HashSet的区别"></a>9. TreeSet和HashSet的区别</h4><ol>
<li>HashSet基于哈希表实现，数据无序，允许null，使用equalTo()方法进行比较。</li>
<li>TreeSet基于红黑树实现，可以保持数据排序（根据Comparable method进行排序，默认升序）。不允许null，并且会throw NullPointerException，因为Tree使用compareTo()方法进行比较，compareTo()会抛出异常。搜索、插入、删除、higher()、floor()、ceiling()等操作时间复杂度为O(log n)</li>
<li>When to prefer TreeSet over HashSet<ol>
<li>TreeSet 需要排序的唯一元素，而不是唯一元素。 TreeSet 提供的排序列表总是以升序排列。</li>
<li>TreeSet 比 HashSet 具有更强的局部性。如果两个条目在顺序上相邻，那么 TreeSet 会将它们放在数据结构中相邻的位置，从而放在内存中，而 HashSet 则会将条目分散到整个内存中，而不管它们与哪个键相关联。</li>
<li>TreeSet 使用红黑树算法对元素进行排序。 当需要频繁执行读&#x2F;写操作时，TreeSet 是一个不错的选择。</li>
<li>LinkedHashSet 是介于这两种数据结构之间的另一种数据结构。 它提供像 HashSet 一样的时间复杂性，并保持<strong>插入顺序</strong>（注意，这不是排序顺序，而是元素插入的顺序）。</li>
</ol>
</li>
</ol>
<h4 id="10-TreeMap和HashMap"><a href="#10-TreeMap和HashMap" class="headerlink" title="10. TreeMap和HashMap"></a>10. TreeMap和HashMap</h4><ol>
<li>HashMap 不会根据键或值保持任何顺序，如果我们希望键保持排序，则需要使用 TreeMap。</li>
<li>复杂性：get&#x2F;put&#x2F;containsKey() 操作的平均值为 O(1)，但我们不能保证这一点，因为这完全取决于计算散列所需的时间。</li>
<li>应用： HashMap 基本上是散列的一种实现。 因此，只要我们需要使用键值对进行散列，就可以使用 HashMap。 例如，在网络应用程序中，用户名作为键存储，而用户数据作为值存储在 HashMap 中，以便更快地检索与用户名相对应的用户数据。</li>
<li>对于添加、删除、包含键等操作，时间复杂度为 O(log n)，其中 n 是 TreeMap 中元素的数量。</li>
<li>TreeMap 始终保持元素排序（递增），而 HashMap 中的元素没有顺序。 TreeMap 还为键的首数、尾数、下限和上限提供了方法。</li>
<li><img src="/2024/09/24/Java-Base/image-20240923105349172.png" srcset="/img/loading.gif" lazyload alt="image-20240923105349172"></li>
<li>概述：<ol>
<li>HashMap 实现 Map 接口，而 TreeMap 实现 SortedMap 接口。 Sorted Map 接口是 Map 的子接口。</li>
<li>HashMap 实现了 Hashing，而 TreeMap 实现了 Red-Black Tree（一种自平衡二叉搜索树）。 HashMap 和 TreeMap 都有对应的 HashSet 和 TreeSet。</li>
<li>HashSet 和 TreeSet 实现了 Set 接口。 在 HashSet 和 TreeSet 中，我们只有键，没有值，它们主要用于查看集合中是否存在。 对于上述问题，我们不能使用 HashSet（或 TreeSet），因为我们不能存储计数。 与 HashMap（或 TreeMap）相比，我们更倾向于使用 HashSet（或 TreeSet）的一个例子是打印数组中所有不同的元素。</li>
</ol>
</li>
<li><img src="/2024/09/24/Java-Base/image-20240923105554025.png" srcset="/img/loading.gif" lazyload alt="image-20240923105554025"></li>
</ol>
<h4 id="11-无法直接访问私有变量的情况"><a href="#11-无法直接访问私有变量的情况" class="headerlink" title="11. 无法直接访问私有变量的情况"></a>11. 无法直接访问私有变量的情况</h4><ul>
<li><strong>跨类访问</strong>：如果你在另一个类中尝试访问<code>Person</code>类的<code>age</code>字段，将会因为访问控制而无法访问。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">(Person person)</span> &#123;<br>        <span class="hljs-comment">// person.age; // 这是非法的，无法访问私有字段</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>不同包中的类</strong>：如果<code>Person</code>类和另一个类在不同的包中，且该字段是私有的，同样无法直接访问。</p>
</li>
<li><p><strong>接口和抽象类</strong>：在实现接口或继承抽象类时，私有字段无法被子类直接访问。</p>
</li>
<li><p><strong>反射以外的情况</strong>：尽管使用反射可以访问私有字段，但这通常不被推荐，因为它会破坏封装性。</p>
</li>
<li><p>Java中的接口（Interface）是一种引用数据类型，是类的一种特殊形式。它用于定义一组方法的契约，类可以通过实现接口来承诺提供具体的行为。下面是Java接口的主要特性：</p>
<h5 id="1-抽象性"><a href="#1-抽象性" class="headerlink" title="1. 抽象性"></a>1. <strong>抽象性</strong></h5><p> 接口只定义方法的签名，不提供方法的实现。这意味着接口中的方法都是抽象的，类必须实现这些方法。</p>
<h5 id="2-多重继承"><a href="#2-多重继承" class="headerlink" title="2. 多重继承"></a>2. <strong>多重继承</strong></h5><p> Java不支持类的多重继承，但一个类可以实现多个接口。这使得接口成为一种灵活的方式来设计系统的行为。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span>, B &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Method A implementation&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Method B implementation&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="3-常量"><a href="#3-常量" class="headerlink" title="3. 常量"></a>3. <strong>常量</strong></h5><p> 接口可以定义常量，常量是隐式<code>public static final</code>的。这意味着所有实现该接口的类都可以访问这些常量。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">CONSTANT_VALUE</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 隐式public static final</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="4-默认方法和静态方法"><a href="#4-默认方法和静态方法" class="headerlink" title="4. 默认方法和静态方法"></a>4. <strong>默认方法和静态方法</strong></h5><p> 从Java 8开始，接口可以包含默认方法和静态方法：</p>
<ul>
<li><p><strong>默认方法</strong>：可以在接口中提供方法的默认实现，允许接口添加新方法而不影响现有实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">defaultMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Default method implementation&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>静态方法</strong>：可以在接口中定义静态方法，可以通过接口名直接调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Static method implementation&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="5-函数式接口"><a href="#5-函数式接口" class="headerlink" title="5. 函数式接口"></a>5. <strong>函数式接口</strong></h5><p> Java 8引入了函数式编程，允许使用 Lambda 表达式来实例化接口。函数式接口是只包含一个抽象方法的接口。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyFunctionalInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="6-接口的继承"><a href="#6-接口的继承" class="headerlink" title="6. 接口的继承"></a>6. <strong>接口的继承</strong></h5><p> 接口可以继承其他接口，可以通过多层继承来构建复杂的接口结构。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="7-不支持构造函数"><a href="#7-不支持构造函数" class="headerlink" title="7. 不支持构造函数"></a>7. <strong>不支持构造函数</strong></h5><p> 接口不能包含构造函数，因为它们不能被实例化。接口只能通过实现它的类来创建对象。</p>
</li>
</ul>
<h4 id="12-什么是字节码-采用字节码的好处是什么"><a href="#12-什么是字节码-采用字节码的好处是什么" class="headerlink" title="12. 什么是字节码?采用字节码的好处是什么?"></a>12. <a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81-%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88">什么是字节码?采用字节码的好处是什么?</a></h4><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C、 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<p><strong>Java 程序从源代码到运行的过程如下图所示</strong>：</p>
<img src="java-code-to-machine-code.png" srcset="/img/loading.gif" lazyload style="zoom:100%;" />

<p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 <strong>JIT（Just in Time Compilation）</strong> 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p>
<p><img src="/2024/09/24/Java-Base/image-20240925153827361.png" srcset="/img/loading.gif" lazyload alt="image-20240925153827361"></p>
<blockquote>
<p>[!NOTE]</p>
<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p>
</blockquote>
<p>JDK、JRE、JVM、JIT 这四者的关系如下图所示。</p>
<p><img src="/2024/09/24/Java-Base/image-20240925153940994.png" srcset="/img/loading.gif" lazyload alt="image-20240925153940994"></p>
<p>下面这张图是 JVM 的大致结构模型。</p>
<p><img src="/2024/09/24/Java-Base/jvm-rough-structure-model.png" srcset="/img/loading.gif" lazyload alt="jvm-rough-structure-model.png"></p>
<h4 id="13-测试"><a href="#13-测试" class="headerlink" title="13. 测试"></a>13. 测试</h4><h5 id="13-1-通过对输入-输出集划分进行测试用例选择"><a href="#13-1-通过对输入-输出集划分进行测试用例选择" class="headerlink" title="13.1 通过对输入\输出集划分进行测试用例选择"></a>13.1 通过对输入\输出集划分进行测试用例选择</h5><p>子域背后的理念是将输入空间划分为相似的输入集，程序在这些输入集上具有相似的行为。 然后，我们使用每个集合中的一个代表。 这种方法通过选择不同的测试用例来充分利用有限的测试资源，并迫使测试探索随机测试可能无法到达的输入空间部分。 如果我们需要确保我们的测试将探索输出空间的不同部分，我们也可以将输出空间划分为子域（程序具有相似行为的相似输出）。 大多数情况下，对输入空间进行划分就足够了。</p>
<h5 id="13-2-在划分中涵盖输入输出集边界"><a href="#13-2-在划分中涵盖输入输出集边界" class="headerlink" title="13.2 在划分中涵盖输入输出集边界"></a>13.2 在划分中涵盖输入输出集边界</h5><p>bug经常发生在子集之间的边界</p>
<ul>
<li>0 is a boundary between positive numbers and negative numbers</li>
<li>the maximum and minimum values of numeric types, like <code>int </code>and <code>double</code></li>
<li>emptiness (the empty string, empty list, empty array) for collection types</li>
<li>the first and last element of a collection</li>
</ul>
<h5 id="13-3-黑盒测试-白盒测试"><a href="#13-3-黑盒测试-白盒测试" class="headerlink" title="13.3 黑盒测试 &amp; 白盒测试"></a>13.3 黑盒测试 &amp; 白盒测试</h5><p><strong>Blackbox testing</strong> means choosing test cases only from the specification, not the implementation of the function. That’s what we’ve been doing in our examples so far. We partitioned and looked for boundaries in <code>multiply </code>and <code>max </code>without looking at the actual code for these functions.</p>
<p><strong>Whitebox testing</strong> (also called glass box testing) means choosing test cases with knowledge of how the function is actually implemented. For example, if the implementation selects different algorithms depending on the input, then you should partition according to those domains. If the implementation keeps an internal cache that remembers the answers to previous inputs, then you should test repeated inputs.</p>
<h5 id="13-4-覆盖率"><a href="#13-4-覆盖率" class="headerlink" title="13.4 覆盖率"></a>13.4 覆盖率</h5><p>Here are three common kinds of coverage:</p>
<ul>
<li><strong>Statement coverage</strong> : is every statement run by some test case?</li>
<li><strong>Branch coverage</strong> : for every <code>if </code>or <code>while </code>statement in the program, are both the true and the false direction taken by some test case?</li>
<li><strong>Path coverage</strong> : is every possible combination of branches — every path through the program — taken by some test case?</li>
</ul>
<h5 id="13-5-单元测试和桩-自动化测试和回归测试"><a href="#13-5-单元测试和桩-自动化测试和回归测试" class="headerlink" title="13.5 单元测试和桩 自动化测试和回归测试"></a>13.5 单元测试和桩 自动化测试和回归测试</h5><h4 id="14-Code-Review"><a href="#14-Code-Review" class="headerlink" title="14. Code Review"></a>14. Code Review</h4><p>目的：</p>
<ul>
<li>提升代码质量</li>
<li>提升程序员水平</li>
</ul>
<p>养成自己的代码风格</p>
<p><strong>Dont Repeat Yourself</strong></p>
<h4 id="15-Final-关键字"><a href="#15-Final-关键字" class="headerlink" title="15. Final 关键字"></a>15. Final 关键字</h4><p>当数组变量被声明为final时，数组的引用是不可变的。</p>
<p>然而，final数组的内容是可以修改的。</p>
<h2 id="1-面向对象编程"><a href="#1-面向对象编程" class="headerlink" title="1. 面向对象编程"></a>1. 面向对象编程</h2><h3 id="1-1-封装、继承、多态"><a href="#1-1-封装、继承、多态" class="headerlink" title="1.1 封装、继承、多态"></a>1.1 封装、继承、多态</h3><h4 id="1-1-1-封装"><a href="#1-1-1-封装" class="headerlink" title="1.1.1 封装"></a>1.1.1 封装</h4><p>1）什么是封装</p>
<p>封装从字面上来理解就是包装的意思，专业点就是信息隐藏，<strong>是指利用抽象将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体</strong>。</p>
<p>数据被保护在类的内部，尽可能地隐藏内部的实现细节，只保留一些对外接口使之与外部发生联系。</p>
<p>其他对象只能通过已经授权的操作来与这个封装的对象进行交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。</p>
<p>使用封装有 4 大好处：</p>
<ul>
<li>1、良好的封装能够减少耦合。</li>
<li>2、类内部的结构可以自由修改。</li>
<li>3、可以对成员进行更精确的控制。</li>
<li>4、隐藏信息，实现细节。</li>
</ul>
<h4 id="1-1-2-继承"><a href="#1-1-2-继承" class="headerlink" title="1.1.2 继承"></a>1.1.2 继承</h4><p>1）什么是继承</p>
<p>Java 语言中<strong>继承就是子类继承父类的属性和方法，使得子类对象（实例）具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的方法</strong>。</p>
<p>2）继承的种类</p>
<ol>
<li><p>单继承</p>
<p>单继承，一个子类只有一个父类，如我们上面讲过的 Animal 类和它的子类。<strong>单继承在类层次结构上比较清晰，但缺点是结构的丰富度有时不能满足使用需求</strong>。</p>
</li>
<li><p>多继承</p>
<p>Java 虽然不支持多继承，但是 Java 有三种实现多继承效果的方式，<strong>分别是</strong>内部类、多层继承和实现接口。</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://javabetter.cn/oo/inner-class.html">内部类</a>可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，可以达到多继承的效果。</p>
</li>
<li><p>**多层继承：**子类继承父类，父类如果还继承其他的类，那么这就叫**多层继承**。这样子类就会拥有所有被继承类的属性和方法。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://javabetter.cn/oo/interface.html">实现接口</a>无疑是满足多继承使用需求的最好方式，一个类可以实现多个接口满足自己在丰富性和复杂环境的使用需求。</p>
</li>
</ol>
<p>类和接口相比，<strong>类就是一个实体，有属性和方法，而接口更倾向于一组方法</strong>。</p>
</li>
</ol>
<p>3）实现继承</p>
<p>在 Java 中，类的继承是单一继承，也就是说一个子类只能拥有一个父类，所以<strong>extends</strong>只能继承一个类。其使用语法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">class 子类名 extends 父类名&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>使用 implements 关键字可以变相使 Java 拥有多继承的特性，使用范围为类实现接口的情况，一个类可以实现多个接口(接口与接口之间用逗号分开)。</p>
<p>4）继承特点</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><a target="_blank" rel="noopener" href="https://javabetter.cn/oo/encapsulation-inheritance-polymorphism.html#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">构造方法</a></h5><p><a target="_blank" rel="noopener" href="https://javabetter.cn/oo/construct.html">构造方法</a>是一种特殊的方法，<strong>它是一个与类同名的方法</strong>。在继承中<strong>构造方法是一种比较特殊的方法</strong>（比如不能继承），所以要了解和学习在继承中构造方法的规则和要求。</p>
<p>继承中的构造方法有以下几点需要注意：</p>
<p><strong>父类的构造方法不能被继承：</strong></p>
<p>因为构造方法语法是<strong>与类同名</strong>，而继承则不更改方法名，如果子类继承父类的构造方法，那明显与构造方法的语法冲突了。比如 Father 类的构造方法名为 Father()，Son 类如果继承 Father 类的构造方法 Father()，那就和构造方法定义：<strong>构造方法与类同名</strong>冲突了，所以在子类中不能继承父类的构造方法，但子类会调用父类的构造方法。</p>
<p><strong>子类的构造过程必须调用其父类的构造方法：</strong></p>
<p>Java 虚拟机**构造子类对象前会先构造父类对象，父类对象构造完成之后再来构造子类特有的属性，**这被称为**内存叠加**。而 Java 虚拟机构造父类对象会执行父类的构造方法，所以子类构造方法必须调用 super()即父类的构造方法。就比如一个简单的继承案例应该这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//无参构造</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span> <span class="hljs-params">(String name)</span>&#123;<span class="hljs-comment">//有参构造</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//无参构造</span><br>       <span class="hljs-built_in">super</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">B</span><span class="hljs-params">(String name)</span> &#123;<span class="hljs-comment">//有参构造</span><br>      <span class="hljs-comment">//super();</span><br>       <span class="hljs-built_in">super</span>(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>如果子类的构造方法中没有显示地调用父类构造方法，则系统默认调用父类无参数的构造方法。</strong></p>
<p><strong>方法重写（Override）</strong>：外壳不变重写内容。如果子类具有和父类一样的方法（参数相同、返回类型相同、方法名相同，但方法体可能不同），我们称之为方法重写。 方法重写用于提供父类已经声明的方法的特殊实现，是实现多态的基础条件。</p>
<ul>
<li><p>只能重写继承过来的方法</p>
</li>
<li><p>final、static的方法不能被重写</p>
</li>
<li><p>重写的方法必须有相同的参数列表</p>
</li>
<li><p>重写的方法必须返回相同的类型</p>
</li>
<li><p>重写的方法不能使用限制等级更严格的权限修饰符</p>
</li>
<li><p>重写后的方法不能抛出比父类级别更高的异常</p>
<p>可以这样来理解：</p>
<ul>
<li>如果被重写的方法是 default，那么重写的方法可以是 default、protected 或者 public。</li>
<li>如果被重写的方法是 protected，那么重写的方法只能是 protected 或者 public。</li>
<li>如果被重写的方法是 public， 那么重写的方法就只能是 public。</li>
</ul>
</li>
<li><p>可以在子类中通过super关键字来调用父类中被重写的方法</p>
</li>
<li><p>构造方法不能被重写</p>
</li>
<li><p>如果一个类继承了抽象类，抽象类中的抽象方法必须在子类中被重写。</p>
</li>
<li><p>synchronized关键字对重写规则没有任何影响</p>
</li>
<li><p>strictfp关键字对重写规则没有影响。</p>
</li>
</ul>
<p><strong>方法重载（Overload）</strong>：不同方法命名相同。如果一个类有多个名字相同但参数个数不同的方法，我们通常称这些方法为方法重载。 ”我面带着朴实无华的微笑继续说，“如果方法的功能是一样的，但参数不同，使用相同的名字可以提高程序的可读性。</p>
<p><strong>由于可以通过改变参数类型的方式实现方法重载，那么当传递的参数没有找到匹配的方法时，就会发生隐式的类型转换。</strong></p>
<p><img src="/2024/09/24/Java-Base/extends-bigsai-0cd258c9-b897-4be3-bdb2-2ddd9c073609.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>“首先来说一下方法重载时的注意事项，‘两同一不同’。”</p>
<p>“‘两同’：在同一个类，方法名相同。”</p>
<p>“‘一不同’：参数不同。”</p>
<p>“再来说一下方法重写时的注意事项，‘两同一小一大’。”</p>
<p>“‘两同’：方法名相同，参数相同。”</p>
<p>“‘一小’：子类方法声明的异常类型要比父类小一些或者相等。”</p>
<p>“‘一大’：子类方法的访问权限应该比父类的更大或者相等。”</p>
<p>访问修饰符</p>
<p>在Java中，访问修饰符的作用范围如下：</p>
<ol>
<li><code>private</code>：私有访问修饰符，只能在声明它的类内部访问。无论是否在同一包内，都无法在其他类中直接访问。</li>
<li><code>default</code>（默认）：默认访问修饰符。如果没有明确指定访问修饰符，即没有使用任何访问修饰符关键字，将被视为默认访问修饰符。默认修饰符允许在同一包内访问，但在其他包中无法直接访问。</li>
<li><code>protected</code>：受保护的访问修饰符。在同一包内，以及不同包中的子类中无论是否在同一包内），都可以访问受保护的成员。但是，非子类不在同一包内其他类无法直接访问。</li>
<li><code>public</code>：公共访问修饰符。公共成员可以在任何位置都可见和访问，无论是否在同一包内。</li>
</ol>
<h5 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a><a target="_blank" rel="noopener" href="https://javabetter.cn/oo/encapsulation-inheritance-polymorphism.html#%E9%9D%9E%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6">非访问修饰符</a></h5><p>访问修饰符用来控制访问权限，而非访问修饰符每个都有各自的作用，下面针对 static、final、abstract 修饰符进行介绍。</p>
<p><a target="_blank" rel="noopener" href="https://javabetter.cn/oo/static.html">static 修饰符</a></p>
<p>static 翻译为“静态的”，能够与变量，方法和类一起使用，<strong>称为静态变量，静态方法(也称为类变量、类方法)<strong>。如果在一个类中使用 static 修饰变量或者方法的话，它们</strong>可以直接通过类访问，不需要创建一个类的对象来访问成员。</strong></p>
<p>源代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span>&#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">C1</span><span class="hljs-params">()</span>&#123;&#125;<br>   <span class="hljs-comment">// public static C1()&#123;&#125;// 构造方法不允许被声明为static</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doA</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doB</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">C1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">doC</span><span class="hljs-params">()</span><span class="hljs-comment">//静态方法中不存在当前对象，因而不能使用this和super。</span><br>    &#123;<br>        <span class="hljs-comment">//System.out.println(super.a);</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doA</span><span class="hljs-params">()</span>&#123;&#125;<span class="hljs-comment">//静态方法能被静态方法重写</span><br>   <span class="hljs-comment">// public void doB()&#123;&#125;//静态方法不能被非静态方法重写</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://javabetter.cn/oo/final.html">final 修饰符</a></p>
<p>final 变量：</p>
<ul>
<li>final 表示”最后的、最终的”含义，<strong>变量一旦赋值后，不能被重新赋值</strong>。被 final 修饰的实例变量必须显式指定初始值(即不能只声明)。final 修饰符通常和 static 修饰符一起使用来创建类常量。</li>
</ul>
<p>final 方法：</p>
<ul>
<li><strong>父类中的 final 方法可以被子类继承，但是不能被子类重写</strong>。声明 final 方法的主要目的是防止该方法的内容被修改。</li>
</ul>
<p>final 类：</p>
<ul>
<li><strong>final 类不能被继承</strong>，没有类能够继承 final 类的任何特性。</li>
</ul>
<p>所以无论是变量、方法还是类被 final 修饰之后，都有代表最终、最后的意思。内容无法被修改。</p>
<p><a target="_blank" rel="noopener" href="https://javabetter.cn/oo/abstract.html">abstract 修饰符</a></p>
<p>abstract 英文名为“抽象的”，主要用来修饰类和方法，称为抽象类和抽象方法。</p>
<p><strong>抽象方法</strong>：有很多不同类的方法是相似的，但是具体内容又不太一样，所以我们只能抽取他的声明，没有具体的方法体，即抽象方法可以表达概念但无法具体实现。</p>
<p><strong>抽象类</strong>：<strong>有抽象方法的类必须是抽象类</strong>，抽象类可以表达概念但是无法构造实体的类。</p>
<h5 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a><a target="_blank" rel="noopener" href="https://javabetter.cn/oo/encapsulation-inheritance-polymorphism.html#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B">向上转型</a></h5><p><strong>将子类实例赋值给父类变量</strong></p>
<p><strong>向上转型</strong> : 通过子类对象(小范围)实例化父类对象(大范围)，这种属于自动转换。用一张图就能很好地表示向上转型的逻辑：</p>
<p><img src="/2024/09/24/Java-Base/extends-bigsai-0cd258c9-b897-4be3-bdb2-2ddd9c073609.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>父类引用变量指向子类对象后，只能使用父类已声明的方法，但方法如果被重写会执行子类的方法，如果方法未被重写那么将执行父类的方法。</p>
<h5 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a><a target="_blank" rel="noopener" href="https://javabetter.cn/oo/encapsulation-inheritance-polymorphism.html#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B">向下转型</a></h5><p><strong>将父类实例赋值给子类变量</strong></p>
<p><strong>向下转型</strong> : 通过父类对象(大范围)实例化子类对象(小范围)，在书写上父类对象需要加括号<code>()</code>强制转换为子类类型。但父类引用变量实际引用必须是子类对象才能成功转型，这里也用一张图就能很好表示向下转型的逻辑：</p>
<p><img src="/2024/09/24/Java-Base/extends-bigsai-ef0d4716-8b4f-4adf-845e-dd293871b7a7.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>子类引用变量指向父类引用变量指向的对象后(一个 Son()对象)，就完成向下转型，就可以调用一些子类特有而父类没有的方法 。</p>
<p>5）<a target="_blank" rel="noopener" href="https://javabetter.cn/oo/encapsulation-inheritance-polymorphism.html#_08%E3%80%81%E5%AD%90%E7%88%B6%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F">子父类初始化顺序</a></p>
<p>在 Java 继承中，父子类初始化先后顺序为：</p>
<ol>
<li>父类中静态成员变量和静态代码块</li>
<li>子类中静态成员变量和静态代码块</li>
<li>父类中普通成员变量和代码块，父类的构造方法</li>
<li>子类中普通成员变量和代码块，子类的构造方法</li>
</ol>
<p>总的来说，就是<strong>静态&gt;非静态，父类&gt;子类，非构造方法&gt;构造方法</strong>。同一类别（例如普通变量和普通代码块）成员变量和代码块执行从前到后，需要注意逻辑。</p>
<p>这个也不难理解，静态变量也称类变量，可以看成一个全局变量，静态成员变量和静态代码块在类加载的时候就初始化，而非静态变量和代码块在对象创建的时候初始化。所以静态快于非静态初始化。</p>
<p>而在创建子类对象的时候需要先创建父类对象，所以父类优先于子类。</p>
<p>而在调用构造方法的时候，是对成员变量进行一些初始化操作，所以普通成员变量和代码块优于构造方法执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Father</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(++b1+<span class="hljs-string">&quot;父类构造方法&quot;</span>);<br>    &#125;<span class="hljs-comment">//父类构造方法 第四</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a1=<span class="hljs-number">0</span>;<span class="hljs-comment">//父类static 第一 注意顺序</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(++a1+<span class="hljs-string">&quot;父类static&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> b1=a1;<span class="hljs-comment">//父类成员变量和代码块 第三</span><br>    &#123;<br>        System.out.println(++b1+<span class="hljs-string">&quot;父类代码块&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Son</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(++b2+<span class="hljs-string">&quot;子类构造方法&quot;</span>);<br>    &#125;<span class="hljs-comment">//子类构造方法 第六</span><br>    <span class="hljs-keyword">static</span> &#123;<span class="hljs-comment">//子类static第二步</span><br>        System.out.println(++a1+<span class="hljs-string">&quot;子类static&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> b2=b1;<span class="hljs-comment">//子类成员变量和代码块 第五</span><br>    &#123;<br>        System.out.println(++b2 + <span class="hljs-string">&quot;子类代码块&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test9</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Son son=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1-1-3-多态（动态绑定）"><a href="#1-1-3-多态（动态绑定）" class="headerlink" title="1.1.3 多态（动态绑定）"></a>1.1.3 多态（动态绑定）</h4><p>Java 的多态是指在面向对象编程中，同一个类的对象在不同情况下表现出来的不同行为和状态。</p>
<ul>
<li>子类可以继承父类的字段和方法，子类对象可以直接使用父类中的方法和字段（私有的不行）。</li>
<li>子类可以重写从父类继承来的方法，使得子类对象调用这个方法时表现出不同的行为。</li>
<li>可以将子类对象赋给父类类型的引用，这样就可以通过父类类型的引用调用子类中重写的方法，实现多态。</li>
</ul>
<p>多态的目的是为了提高代码的灵活性和可扩展性，使得代码更容易维护和扩展。</p>
<p>比如说，通过允许子类继承父类的方法并重写，增强了代码的复用性。</p>
<p>再比如说多态可以实现动态绑定，这意味着程序在运行时再确定对象的方法调用也不迟。</p>
<p>1）什么是多态</p>
<p>多态的前提条件有三个：</p>
<ul>
<li>子类继承父类</li>
<li>子类重写父类的方法</li>
<li>父类引用指向子类的对象</li>
</ul>
<p>2）多态与后期绑定</p>
<p>答案是在运行时根据对象的类型进行后期绑定，编译器在编译阶段并不知道对象的类型，但是 Java 的方法调用机制能找到正确的方法体，然后执行，得到正确的结果。</p>
<p>3）多态与构造方法</p>
<p>在构造方法中调用多态方法，会产生一个奇妙的结果，我们来看程序清单 3-1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wangxiaosan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Wangsan</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Wangxiaosan</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        System.out.println(<span class="hljs-string">&quot;王小三的年龄：&quot;</span> + <span class="hljs-built_in">this</span>.age);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 子类覆盖父类方法</span><br>        System.out.println(<span class="hljs-string">&quot;我小三上幼儿园的年龄是：&quot;</span> + <span class="hljs-built_in">this</span>.age);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Wangxiaosan</span>(<span class="hljs-number">4</span>);<br><span class="hljs-comment">//      上幼儿园之前</span><br><span class="hljs-comment">//      我小三上幼儿园的年龄是：0</span><br><span class="hljs-comment">//      上幼儿园之后</span><br><span class="hljs-comment">//      王小三的年龄：4</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wangsan</span> &#123;<br>    Wangsan () &#123;<br>        System.out.println(<span class="hljs-string">&quot;上幼儿园之前&quot;</span>);<br>        write();<br>        System.out.println(<span class="hljs-string">&quot;上幼儿园之后&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;老子上幼儿园的年龄是3岁半&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]</p>
<p>从输出结果上看，是不是有点诧异？明明在创建 Wangxiaosan 对象的时候，年龄传递的是 4，但输出结果既不是“老子上幼儿园的年龄是 3 岁半”，也不是“我小三上幼儿园的年龄是：4”。</p>
<p>为什么？</p>
<p>因为在创建子类对象时，会先去调用父类的构造方法，而父类构造方法中又调用了被子类覆盖的多态方法，由于父类并不清楚子类对象中的字段值是什么，于是把 int 类型的属性暂时初始化为 0，然后再调用子类的构造方法（子类构造方法知道王小二的年龄是 4）。</p>
</blockquote>
<p>4）多态与向下转型</p>
<p>向下转型是指将父类引用强转为子类类型；这是不安全的，因为有的时候，父类引用指向的是父类对象，向下转型就会抛出 ClassCastException，表示类型转换失败；但如果父类引用指向的是子类对象，那么向下转型就是成功的。</p>
<p>来看程序清单 4-1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wangxiaosi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Wangsi</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;记住仇恨，表明我们要奋发图强的心智&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我不喜欢读书，我就喜欢吃&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Wangsi[] wangsis = &#123; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Wangsi</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Wangxiaosi</span>() &#125;;<br><br>        <span class="hljs-comment">// wangsis[1]能够向下转型</span><br>        ((Wangxiaosi) wangsis[<span class="hljs-number">1</span>]).write();<br>        <span class="hljs-comment">// wangsis[0]不能向下转型</span><br>        ((Wangxiaosi)wangsis[<span class="hljs-number">0</span>]).write();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wangsi</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;勿忘国耻&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;每周读一本好书&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>5）总结</p>
<ul>
<li><strong>封装</strong>：是对类的封装，封装是对类的属性和方法进行封装，只对外暴露方法而不暴露具体使用细节，所以我们一般设计类成员变量时候大多设为私有而通过一些 get、set 方法去读写。</li>
<li><strong>继承</strong>：子类继承父类，即“子承父业”，子类拥有父类除私有的所有属性和方法，自己还能在此基础上拓展自己新的属性和方法。主要目的是<strong>复用代码</strong>。</li>
<li><strong>多态</strong>：多态是同一个行为具有多个不同表现形式或形态的能力。即一个父类可能有若干子类，各子类实现父类方法有多种多样，调用父类方法时，父类引用变量指向不同子类实例而执行不同方法，这就是所谓父类方法是多态的。</li>
</ul>
<h3 id="1-2-关键字"><a href="#1-2-关键字" class="headerlink" title="1.2 关键字"></a>1.2 关键字</h3><h4 id="1-2-1-static关键字"><a href="#1-2-1-static关键字" class="headerlink" title="1.2.1 static关键字"></a>1.2.1 static关键字</h4><p>static 关键字的作用可以用一句话来描述：‘<strong>方便在没有创建对象的情况下进行调用</strong>，包括变量和方法’。</p>
<p>1）静态变量</p>
<p>如果在声明变量的时候使用了 static 关键字，那么这个变量就被称为静态变量。静态变量只在类加载的时候获取一次内存空间，这使得静态变量很节省内存空间。</p>
<p>静态变量只能通过类名来直接访问。</p>
<p>2）静态方法</p>
<p>静态方法有以下特征：</p>
<ul>
<li><p>静态方法属于这个类而不是这个类的对象；</p>
</li>
<li><p>调用静态方法的时候不需要创建这个类的对象；</p>
</li>
<li><p>静态方法可以访问静态变量。</p>
</li>
<li><blockquote>
<p>[!NOTE]</p>
<p>静态方法不能访问非静态变量和调用非静态方法</p>
</blockquote>
</li>
</ul>
<p>3）静态代码块</p>
<p>静态代码块在初始集合的时候，真的非常有用。在实际的项目开发中，通常使用静态代码块来加载配置文件到内存当中。</p>
<p>4）静态内部类</p>
<p>Java 允许我们在一个类中声明一个内部类，它提供了一种令人信服的方式，允许我们只在一个地方使用一些变量，使代码更具有条理性和可读性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第一次加载 Singleton 类时并不会初始化 instance，只有第一次调用 <code>getInstance()</code> 方法时 Java 虚拟机才开始加载 SingletonHolder 并初始化 instance，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p>
<ul>
<li>静态内部类不能访问外部类的所有成员变量；</li>
<li>静态内部类可以访问外部类的所有静态变量，包括私有静态变量。</li>
<li>外部类不能声明为 static。”</li>
</ul>
<h4 id="1-2-2-final关键字"><a href="#1-2-2-final关键字" class="headerlink" title="1.2.2 final关键字"></a>1.2.2 final关键字</h4><p>1）final 变量</p>
<p>被final变量修饰的变量无法重新赋值。</p>
<p>如果是对象，对象不可以重新赋值，但是可以修改对象的私有变量。</p>
<p>final修饰的成员变量必须有一个默认值。</p>
<p>final 和 static一起修饰的变量叫做常量，名全部大写。</p>
<p>2）final方法</p>
<p>被final修饰的方法不能被重写。</p>
<p>一个类是 final 的，和一个类不是 final，但它所有的方法都是 final 的，考虑一下，它们之间有什么区别？</p>
<ul>
<li>前者不能被<a target="_blank" rel="noopener" href="https://javabetter.cn/oo/extends-bigsai.html">继承</a>，也就是说方法无法被重写；后者可以被继承，然后追加一些非 final 的方法。</li>
</ul>
<p>3）final类</p>
<p>一个类使用了 final 关键字修饰，那么它就无法被继承。</p>
<p> String 类设计成 final 的原因：</p>
<ul>
<li>为了实现字符串常量池</li>
<li>为了线程安全</li>
<li>为了 HashCode 的不可变性</li>
</ul>
<p>*）不可变类</p>
<ul>
<li><strong>确保类是 final 的</strong>，不允许被其他类继承。</li>
<li><strong>确保所有的成员变量（字段）是 final 的</strong>，这样的话，它们就只能在构造方法中初始化值，并且不会在随后被修改。</li>
<li><strong>不提供任何 setter 方法。</strong></li>
<li><strong>如果要修改类的状态，必须返回一个新的对象。</strong></li>
<li>如果一个不可变类中包含了可变类的对象，那么就需要确保返回的是<strong>可变对象的副本</strong>。</li>
</ul>
<h4 id="1-2-4-instanceof关键字"><a href="#1-2-4-instanceof关键字" class="headerlink" title="1.2.4 instanceof关键字"></a>1.2.4 instanceof关键字</h4><p>instanceof 关键字的用法其实很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(object) <span class="hljs-keyword">instanceof</span> (type)<br></code></pre></td></tr></table></figure>

<p>用意也非常简单，判断对象是否符合指定的类型，结果要么是 true，要么是 false。在<a target="_blank" rel="noopener" href="https://javabetter.cn/io/serialize.html">反序列化</a>的时候，instanceof 操作符还是蛮常用的，因为这时候我们不太确定对象属不属于指定的类型，如果不进行判断的话，就容易抛出 ClassCastException 异常。</p>
<p>通常，我们是这样使用 instanceof 操作符的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先判断类型</span><br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String) &#123;<br>    <span class="hljs-comment">// 然后强制转换</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String) obj;<br>    <span class="hljs-comment">// 然后才能使用</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>先用 instanceof 进行类型判断，然后再把 obj 强制转换成我们期望的类型再进行使用。</p>
<p>JDK 16 的时候，instanceof 模式匹配转了正，意味着使用 instanceof 的时候更便捷了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String s) &#123;<br>    <span class="hljs-comment">// 如果类型匹配 直接使用 s</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以直接在 if 条件判断类型的时候添加一个变量，就不需要再强转和声明新的变量了。</p>
<h3 id="1-3-注解"><a href="#1-3-注解" class="headerlink" title="1.3 注解"></a>1.3 注解</h3><p>注解是一种用于标注的“元数据”</p>
<h4 id="1-3-1-注解的生命周期"><a href="#1-3-1-注解的生命周期" class="headerlink" title="1.3.1 注解的生命周期"></a>1.3.1 注解的生命周期</h4><p>1）SOURCE：在源文件中有效，被编译器丢弃。</p>
<p>2）CLASS：在编译器生成的字节码文件中有效，但在运行时会被处理类文件的 JVM 丢弃。</p>
<p>3）RUNTIME：在运行时有效。这也是注解生命周期中最常用的一种策略，它允许程序通过反射的方式访问注解，并根据注解的定义执行相应的代码。</p>
<p>一个重要的元注解<code>@Retention</code>定义了<code>Annotation</code>的生命周期：</p>
<ul>
<li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li>
<li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li>
<li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li>
</ul>
<p>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以，务必要加上<code>@Retention(RetentionPolicy.RUNTIME)</code>这个元注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1-3-2-注解的类型"><a href="#1-3-2-注解的类型" class="headerlink" title="1.3.2 注解的类型"></a>1.3.2 注解的类型</h4><p>截止到 Java 9，注解的类型一共有 11 种，定义在 ElementType 枚举中。</p>
<p>1）TYPE：用于类、接口、注解、枚举</p>
<p>2）FIELD：用于字段（类的成员变量），或者枚举常量</p>
<p>3）METHOD：用于方法</p>
<p>4）PARAMETER：用于普通方法或者构造方法的参数</p>
<p>5）CONSTRUCTOR：用于构造方法</p>
<p>6）LOCAL_VARIABLE：用于变量</p>
<p>7）ANNOTATION_TYPE：用于注解</p>
<p>8）PACKAGE：用于包</p>
<p>9）TYPE_PARAMETER：用于泛型参数</p>
<p>10）TYPE_USE：用于声明语句、泛型或者强制转换语句中的类型</p>
<p>11）MODULE：用于模块</p>
<p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p>
<ul>
<li>类或接口：<code>ElementType.TYPE</code>；</li>
<li>字段：<code>ElementType.FIELD</code>；</li>
<li>方法：<code>ElementType.METHOD</code>；</li>
<li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li>
<li>方法参数：<code>ElementType.PARAMETER</code>。</li>
</ul>
<p>例如，定义注解<code>@Report</code>可用在方法上，我们必须添加一个<code>@Target(ElementType.METHOD)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1-3-3-如何定义Annotation"><a href="#1-3-3-如何定义Annotation" class="headerlink" title="1.3.3 如何定义Annotation"></a>1.3.3 如何定义Annotation</h4><p><strong>注解参数</strong></p>
<p>定义一个注解时，还可以定义配置参数。配置参数可以包括：</p>
<ul>
<li>所有基本类型；</li>
<li>String；</li>
<li>枚举类型；</li>
<li>基本类型、String、Class以及枚举的数组。</li>
</ul>
<p>因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。</p>
<p>注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。</p>
<p>此外，大部分注解会有一个名为<code>value</code>的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。</p>
<p>如果只写注解，相当于全部使用默认值。</p>
<p><strong>元注解</strong></p>
<p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）</p>
<ul>
<li>@Target：可以定义<code>Annotation</code>能够被应用于源码的哪些位置<ul>
<li>类或接口：<code>ElementType.TYPE</code>；</li>
<li>字段：<code>ElementType.FIELD</code>；</li>
<li>方法：<code>ElementType.METHOD</code>；</li>
<li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li>
<li>方法参数：<code>ElementType.PARAMETER</code>。</li>
</ul>
</li>
<li>@Retention：定义了<code>Annotation</code>的生命周期，如果@Retention不存在，则Annotation默认为CLASS<ul>
<li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li>
<li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li>
<li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li>
</ul>
</li>
<li>@Repeatable：定义<code>Annotation</code>是否可重复。</li>
<li>@Inherited：使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效</li>
</ul>
<p>第一步，用<code>@interface</code>定义注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第二步，添加参数、默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p>
<p>第三步，用元注解配置注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Report &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>    String <span class="hljs-title function_">level</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;info&quot;</span>;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p>
<h3 id="1-4-包、模块"><a href="#1-4-包、模块" class="headerlink" title="1.4 包、模块"></a>1.4 包、模块</h3><h4 id="1-4-1包"><a href="#1-4-1包" class="headerlink" title="1.4.1包"></a>1.4.1包</h4><p>在java中使用包<code>package</code>来解决名字冲突</p>
<blockquote>
<p>[!WARNING]</p>
<p>包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</p>
</blockquote>
<h5 id="1）作用域"><a href="#1）作用域" class="headerlink" title="1）作用域"></a>1）作用域</h5><p>位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。</p>
<h5 id="2）import"><a href="#2）import" class="headerlink" title="2）import"></a>2）import</h5><ul>
<li>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有<code>class</code>都导入进来（但不包括子包的class），一般不推荐这种写法，因为在导入了多个包后，很难看出<code>Arrays</code>类属于哪个包。</li>
<li><code>import static</code>的语法，它可以导入一个类的静态字段和静态方法</li>
</ul>
<h5 id="3）编译器查找规则"><a href="#3）编译器查找规则" class="headerlink" title="3）编译器查找规则"></a>3）编译器查找规则</h5><p>当编译器遇到一个<code>class</code>名称时：</p>
<ul>
<li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li>
<li>如果是简单类名，按下面的顺序依次查找：<ul>
<li>查找当前<code>package</code>是否存在这个<code>class</code>；</li>
<li>查找<code>import</code>的包是否包含这个<code>class</code>；</li>
<li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li>
</ul>
</li>
</ul>
<p>如果按照上面的规则还无法确定类名，则编译报错。</p>
<p>因此，编写class的时候，编译器会自动帮我们做两个import动作：</p>
<ul>
<li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</li>
<li>默认自动<code>import java.lang.*</code>。</li>
</ul>
<blockquote>
<p>[!WARNING]</p>
<p>自动导入的是java.lang包，类似java.lang.reflect这些包仍需要手动导入。</p>
</blockquote>
<h5 id="4）最佳实践"><a href="#4）最佳实践" class="headerlink" title="4）最佳实践"></a>4）最佳实践</h5><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p>
<ul>
<li>org.apache</li>
<li>org.apache.commons.log</li>
<li>com.liaoxuefeng.sample</li>
</ul>
<p>子包就可以根据功能自行命名。</p>
<p>要注意不要和<code>java.lang</code>包的类重名，即自己的类不要使用这些名字：</p>
<ul>
<li>String</li>
<li>System</li>
<li>Runtime</li>
<li>…</li>
</ul>
<p>要注意也不要和JDK常用类重名：</p>
<ul>
<li><p>java.util.List</p>
</li>
<li><p>java.text.Format</p>
</li>
<li><p>java.math.BigInteger</p>
</li>
</ul>
<h4 id="1-4-2-内部类"><a href="#1-4-2-内部类" class="headerlink" title="1.4.2 内部类"></a>1.4.2 内部类</h4><h5 id="Inner-Class"><a href="#Inner-Class" class="headerlink" title="Inner Class"></a><strong>Inner Class</strong></h5><p>如果一个类定义在另一个类的内部，这个类就是Inner Class：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-comment">// 定义了一个Inner Class</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述定义的<code>Outer</code>是一个普通类，而<code>Inner</code>是一个Inner Class，它与普通类有个最大的不同，就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// inner class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>(<span class="hljs-string">&quot;Nested&quot;</span>); <span class="hljs-comment">// 实例化一个Outer</span><br>        Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> outer.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>(); <span class="hljs-comment">// 实例化一个Inner</span><br>        inner.hello();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    Outer(String name) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + Outer.<span class="hljs-built_in">this</span>.name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Inner Class和普通Class相比，除了能引用Outer实例外，还有一个额外的“特权”，就是可以修改Outer Class的<code>private</code>字段，因为Inner Class的作用域在Outer Class内部，所以能访问Outer Class的<code>private</code>字段和方法。</p>
<p>Java编译器编译后的<code>.class</code>文件可以发现，<code>Outer</code>类被编译为<code>Outer.class</code>，而<code>Inner</code>类被编译为<code>Outer$Inner.class</code>。</p>
<h5 id="Anonymous-Class"><a href="#Anonymous-Class" class="headerlink" title="Anonymous Class"></a>Anonymous Class</h5><p>另外一种定义Inner Class的方法，在方法内部，通过匿名类（Anonymous Class）来定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Anonymous Class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>(<span class="hljs-string">&quot;Nested&quot;</span>);<br>        outer.asyncHello();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    Outer(String name) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyncHello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + Outer.<span class="hljs-built_in">this</span>.name);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>观察<code>asyncHello()</code>方法，我们在方法内部实例化了一个<code>Runnable</code>。<code>Runnable</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了<code>Runnable</code>接口的匿名类，并且通过<code>new</code>实例化该匿名类，然后转型为<code>Runnable</code>。</p>
<p>匿名类和Inner Class一样，可以访问Outer Class的<code>private</code>字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义Inner Class可以少写很多代码。</p>
<p>观察Java编译器编译后的<code>.class</code>文件可以发现，<code>Outer</code>类被编译为<code>Outer.class</code>，而匿名类被编译为<code>Outer$1.class</code>。如果有多个匿名类，Java编译器会将每个匿名类依次命名为<code>Outer$1</code>、<code>Outer$2</code>、<code>Outer$3</code></p>
<p><code>引用评论区评论：3.1.11 内部类 new一个 @ 2024/12/2 09:46:48</code></p>
<p>一上来就整Runnable要吓死新手们的，是这样的： 在 Java 中，匿名内部类必须继承某个类或实现某个接口，因为匿名内部类的本质是定义一个没有名字的子类或实现类，并立即创建它的实例。 匿名内部类的语法规则</p>
<ol>
<li>继承一个类：匿名类可以继承一个具体类。</li>
<li>实现一个接口：匿名类可以实现一个接口，并需要实现接口的所有抽象方法。</li>
<li>匿名内部类不能同时继承类和实现接口。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Outer的私有字段&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showPrivateMessage</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Outer的私有方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAnonymousClass</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MyInterface</span> <span class="hljs-variable">myInterfaceImpl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterface</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123; <span class="hljs-comment">//实现接口定义的方法</span><br>                System.out.println(name + <span class="hljs-string">&quot;@&quot;</span> + age);<br>                System.out.println(Outer.<span class="hljs-built_in">this</span>.message); <span class="hljs-comment">//用Outer.this访问外部类的私有方法</span><br>                showPrivateMessage(); <span class="hljs-comment">//不用 Outer.this也可以直接访问外部类的私有方法</span><br>            &#125;<br>        &#125;;<br><br>        myInterfaceImpl.show(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().testAnonymousClass();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>另外，由于可以所有类都继承自Object，所以我们也可以写一个继承Object的匿名内部类，使它就像其他没显式继承的类那样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Outer的私有字段&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showPrivateMessage</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Outer的私有方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAnonymousClass</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123; <span class="hljs-comment">//实现接口定义的方法</span><br>                System.out.println(name + <span class="hljs-string">&quot;@&quot;</span> + age);<br>                System.out.println(Outer.<span class="hljs-built_in">this</span>.message); <span class="hljs-comment">//用Outer.this访问外部类的私有方法</span><br>                showPrivateMessage(); <span class="hljs-comment">//不用 Outer.this也可以直接访问外部类的私有方法</span><br>            &#125;<br>        &#125;.show(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="Static-Nested-Class"><a href="#Static-Nested-Class" class="headerlink" title="Static Nested Class"></a>Static Nested Class</h5><p>最后一种内部类和Inner Class类似，但是使用<code>static</code>修饰，称为静态内部类（Static Nested Class）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Static Nested Class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Outer.<span class="hljs-type">StaticNested</span> <span class="hljs-variable">sn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>.StaticNested();<br>        sn.hello();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;OUTER&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    Outer(String name) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticNested</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + Outer.NAME);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用<code>static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个完全独立的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。如果把<code>StaticNested</code>移到<code>Outer</code>之外，就失去了访问<code>private</code>的权限。</p>
<h3 id="1-5-核心类"><a href="#1-5-核心类" class="headerlink" title="1.5 核心类"></a>1.5 核心类</h3><p>一些基础的类例如String、StringBuilder、StringJoiner、以及包装类型，细节不再阐述，只记录一些需要注意的地方。</p>
<p>1）primitive类型转化为包装类型 Auto Boxing，反之Auto Unboxing</p>
<p>2）同String，包装类型的比较也需要使用equals()</p>
<p>3）我们把能创建“新”对象的静态方法称为静态工厂方法。</p>
<blockquote>
<p>[!TIP]</p>
<p>按照语义编程，而不是针对特定的底层实现去“优化”。</p>
<p>创建新对象时，优先选用静态工厂方法而不是new操作符。</p>
</blockquote>
<h4 id="1-5-1-JavaBean"><a href="#1-5-1-JavaBean" class="headerlink" title="1.5.1 JavaBean"></a>1.5.1 JavaBean</h4><p>在Java中，有很多<code>class</code>的定义都符合这样的规范：</p>
<ul>
<li>若干<code>private</code>实例字段；</li>
<li>通过<code>public</code>方法来读写实例字段。</li>
</ul>
<p>如果读写方法符合以下这种命名规范：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 读方法:</span><br><span class="hljs-keyword">public</span> Type <span class="hljs-title function_">getXyz</span><span class="hljs-params">()</span><br><span class="hljs-comment">// 写方法:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setXyz</span><span class="hljs-params">(Type value)</span><br></code></pre></td></tr></table></figure>

<p>那么这种<code>class</code>被称为<code>JavaBean</code>：</p>
<p>上面的字段是<code>xyz</code>，那么读写方法名分别以<code>get</code>和<code>set</code>开头，并且后接大写字母开头的字段名<code>Xyz</code>，因此两个读写方法名分别是<code>getXyz()</code>和<code>setXyz()</code>。</p>
<p><code>boolean</code>字段比较特殊，它的读方法一般命名为<code>isXyz()</code>：</p>
<p>我们通常把一组对应的读方法（<code>getter</code>）和写方法（<code>setter</code>）称为属性（<code>property</code>）。例如，<code>name</code>属性：</p>
<ul>
<li>对应的读方法是<code>String getName()</code></li>
<li>对应的写方法是<code>setName(String)</code></li>
</ul>
<p>只有<code>getter</code>的属性称为只读属性（read-only），例如，定义一个age只读属性：</p>
<ul>
<li>对应的读方法是<code>int getAge()</code></li>
<li>无对应的写方法<code>setAge(int)</code></li>
</ul>
<p>类似的，只有<code>setter</code>的属性称为只写属性（write-only）。</p>
<p>很明显，只读属性很常见，只写属性不常见。</p>
<p>属性只需要定义<code>getter</code>和<code>setter</code>方法，不一定需要对应的字段。</p>
<h5 id="1）JavaBean的作用"><a href="#1）JavaBean的作用" class="headerlink" title="1）JavaBean的作用"></a>1）JavaBean的作用</h5><p>JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。</p>
<h5 id="2）枚举JavaBean属性"><a href="#2）枚举JavaBean属性" class="headerlink" title="2）枚举JavaBean属性"></a>2）枚举JavaBean属性</h5><p>要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的<code>Introspector</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.beans.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">BeanInfo</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> Introspector.getBeanInfo(Person.class);<br>        <span class="hljs-keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;<br>            System.out.println(pd.getName());<br>            System.out.println(<span class="hljs-string">&quot;  &quot;</span> + pd.getReadMethod());<br>            System.out.println(<span class="hljs-string">&quot;  &quot;</span> + pd.getWriteMethod());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1-5-2-枚举类"><a href="#1-5-2-枚举类" class="headerlink" title="1.5.2 枚举类"></a>1.5.2 枚举类</h4><p>优点：包括类型信息如：月份、星期几、颜色，优于常量定义</p>
<p><code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点：</p>
<ul>
<li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li>
<li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li>
<li>定义的每个实例都是引用类型的唯一实例；</li>
<li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li>
</ul>
<p><strong>name()：</strong>返回常量名</p>
<p><strong>ordinal()：</strong>返回定义常量的顺序</p>
<h4 id="1-5-4-记录类"><a href="#1-5-4-记录类" class="headerlink" title="1.5.4 记录类"></a>1.5.4 记录类</h4><p>从Java 14开始，引入了新的<code>Record</code>类。我们定义<code>Record</code>类时，使用关键字<code>record</code>。把上述<code>Point</code>类改写为<code>Record</code>类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Record</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Point</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        System.out.println(p.x());<br>        System.out.println(p.y());<br>        System.out.println(p);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">record</span> <span class="hljs-title class_">Point</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;&#125;<br></code></pre></td></tr></table></figure>

<p>仔细观察<code>Point</code>的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">record</span> <span class="hljs-title class_">Point</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;&#125;<br></code></pre></td></tr></table></figure>

<p>把上述定义改写为class，相当于以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> y;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Point</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-built_in">this</span>.x = x;<br>        <span class="hljs-built_in">this</span>.y = y;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">x</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">y</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.y;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;Point[x=%s, y=%s]&quot;</span>, x, y);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        ...<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>除了用<code>final</code>修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写<code>toString()</code>、<code>equals()</code>和<code>hashCode()</code>方法。</p>
<p>换句话说，使用<code>record</code>关键字，可以一行写出一个不变类。</p>
<p>和<code>enum</code>类似，我们自己不能直接从<code>Record</code>派生，只能通过<code>record</code>关键字由编译器实现继承。</p>
<p>假设<code>Point</code>类的<code>x</code>、<code>y</code>不允许负数，我们就得给<code>Point</code>的构造方法加上检查逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">Point</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-keyword">public</span> Point &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意到方法<code>public Point &#123;...&#125;</code>被称为Compact Constructor，它的目的是让我们编写检查逻辑，编译器最终生成的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Point</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-comment">// 这是我们编写的Compact Constructor:</span><br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>        &#125;<br>        <span class="hljs-comment">// 这是编译器继续生成的赋值代码:</span><br>        <span class="hljs-built_in">this</span>.x = x;<br>        <span class="hljs-built_in">this</span>.y = y;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>作为<code>record</code>的<code>Point</code>仍然可以添加静态方法。一种常用的静态方法是<code>of()</code>方法，用来创建<code>Point</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">Point</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Point <span class="hljs-title function_">of</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Point <span class="hljs-title function_">of</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(x, y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-异常处理"><a href="#2-异常处理" class="headerlink" title="2. 异常处理"></a>2. 异常处理</h2><h3 id="2-1-异常"><a href="#2-1-异常" class="headerlink" title="2.1 异常"></a>2.1 异常</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">                     ┌───────────┐<br>                     │  Object   │<br>                     └───────────┘<br>                           ▲<br>                           │<br>                     ┌───────────┐<br>                     │ Throwable │<br>                     └───────────┘<br>                           ▲<br>                 ┌─────────┴─────────┐<br>                 │                   │<br>           ┌───────────┐       ┌───────────┐<br>           │   Error   │       │ Exception │<br>           └───────────┘       └───────────┘<br>                 ▲                   ▲<br>         ┌───────┘              ┌────┴──────────┐<br>         │                      │               │<br>┌─────────────────┐    ┌─────────────────┐┌───────────┐<br>│OutOfMemoryError │<span class="hljs-string">...</span> │RuntimeException ││IOException│<span class="hljs-string">...</span><br>└─────────────────┘    └─────────────────┘└───────────┘<br>                                ▲<br>                    ┌───────────┴─────────────┐<br>                    │                         │<br>         ┌─────────────────────┐ ┌─────────────────────────┐<br>         │NullPointerException │ │IllegalArgumentException │<span class="hljs-string">...</span><br>         └─────────────────────┘ └─────────────────────────┘<br></code></pre></td></tr></table></figure>

<p>从继承关系可知：<code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p>
<ul>
<li><code>OutOfMemoryError</code>：内存耗尽</li>
<li><code>NoClassDefFoundError</code>：无法加载某个Class</li>
<li><code>StackOverflowError</code>：栈溢出</li>
</ul>
<p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p>
<p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p>
<ul>
<li><code>NumberFormatException</code>：数值类型的格式错误</li>
<li><code>FileNotFoundException</code>：未找到文件</li>
<li><code>SocketException</code>：读取网络失败</li>
</ul>
<p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p>
<ul>
<li><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</li>
<li><code>IndexOutOfBoundsException</code>：数组索引越界</li>
</ul>
<p><code>Exception</code>又分为两大类：</p>
<ol>
<li><code>RuntimeException</code>以及它的子类；</li>
<li>非<code>RuntimeException</code>（包括<code>IOException</code>、<code>ReflectiveOperationException</code>等等）</li>
</ol>
<p>Java规定：</p>
<ul>
<li>必须捕获的异常，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为Checked Exception。</li>
<li>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</li>
</ul>
<h3 id="2-2-抛出异常"><a href="#2-2-抛出异常" class="headerlink" title="2.2 抛出异常"></a>2.2 抛出异常</h3><p>为了能追踪到完整的异常栈，在构造异常的时候，把原始的<code>Exception</code>实例传进去，新的<code>Exception</code>就可以持有原始<code>Exception</code>信息。</p>
<h3 id="2-3-自定义异常"><a href="#2-3-自定义异常" class="headerlink" title="2.3 自定义异常"></a>2.3 自定义异常</h3><p>Java标准库定义的常用异常包括：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-built_in">Exception</span><br>├─ <span class="hljs-built_in">RuntimeException</span><br>│  ├─ NullPointerException<br>│  ├─ IndexOutOfBoundsException<br>│  ├─ SecurityException<br>│  └─ IllegalArgumentException<br>│     └─ NumberFormatException<br>├─ IOException<br>│  ├─ UnsupportedCharsetException<br>│  ├─ FileNotFoundException<br>│  └─ SocketException<br>├─ ParseException<br>├─ GeneralSecurityException<br>├─ SQLException<br>└─ TimeoutException<br></code></pre></td></tr></table></figure>

<p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。</p>
<p>一个常见的做法是自定义一个<code>BaseException</code>作为“根异常”，然后，派生出各种业务类型的异常。</p>
<p><code>BaseException</code>需要从一个适合的<code>Exception</code>派生，通常建议从<code>RuntimeException</code>派生：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其他业务类型的异常就可以从<code>BaseException</code>派生：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserNotFoundException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseException</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginFailedException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseException</span> &#123;<br>&#125;<br><br>...<br></code></pre></td></tr></table></figure>

<p>自定义的<code>BaseException</code>应该提供多个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseException</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseException</span><span class="hljs-params">(String message, Throwable cause)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message, cause);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseException</span><span class="hljs-params">(Throwable cause)</span> &#123;<br>        <span class="hljs-built_in">super</span>(cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述构造方法实际上都是原样照抄<code>RuntimeException</code>。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。</p>
<h3 id="2-4-日志"><a href="#2-4-日志" class="headerlink" title="2.4 日志"></a>2.4 日志</h3><h4 id="2-4-1-JDK-Logging"><a href="#2-4-1-JDK-Logging" class="headerlink" title="2.4.1 JDK Logging"></a>2.4.1 JDK Logging</h4><p>JDK的Logging定义了7个日志级别，从严重到普通：</p>
<ul>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST</li>
</ul>
<p>因为默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。</p>
<h4 id="2-4-2-Commons-Logging"><a href="#2-4-2-Commons-Logging" class="headerlink" title="2.4.2 Commons Logging"></a>2.4.2 Commons Logging</h4><p>Commons Logging定义了6个日志级别：</p>
<ul>
<li>FATAL</li>
<li>ERROR</li>
<li>WARNING</li>
<li>INFO</li>
<li>DEBUG</li>
<li>TRACE</li>
</ul>
<p>默认级别是<code>INFO</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">mport org.apache.commons.logging.Log;<br><span class="hljs-keyword">import</span> org.apache.commons.logging.LogFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Log</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LogFactory.getLog(Main.class);<br>        log.info(<span class="hljs-string">&quot;start...&quot;</span>);<br>        log.warn(<span class="hljs-string">&quot;end.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="2-4-3-Log4j"><a href="#2-4-3-Log4j" class="headerlink" title="2.4.3 Log4j"></a>2.4.3 Log4j</h4><blockquote>
<p>[!NOTE]</p>
<p>Apache Log4j 是基于 Java 的日志记录实用程序。Log4j Java 库的作用是记录信息，帮助应用程序顺利运行，确定发生了什么，并在发生错误时帮助进行调试过程。日志记录库通常会将消息写入日志文件或数据库。</p>
</blockquote>
<p>Log4j是一种非常流行的日志框架，最新版本是2.x。</p>
<p>Log4j是一个组件化设计的日志系统，它的架构大致如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros">log.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;User signed in.&quot;</span>);<br> │<br> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐<br> ├──▶│ Appender │───▶│ <span class="hljs-built_in"> Filter </span> │───▶│  Layout  │───▶│<span class="hljs-built_in"> Console </span> │<br> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘<br> │<br> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐<br> ├──▶│ Appender │───▶│ <span class="hljs-built_in"> Filter </span> │───▶│  Layout  │───▶│   File   │<br> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘<br> │<br> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐<br> └──▶│ Appender │───▶│ <span class="hljs-built_in"> Filter </span> │───▶│  Layout  │───▶│  Socket  │<br>     └──────────┘    └──────────┘    └──────────┘    └──────────┘<br></code></pre></td></tr></table></figure>

<p>当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如：</p>
<ul>
<li>console：输出到屏幕；</li>
<li>file：输出到文件；</li>
<li>socket：通过网络输出到远程计算机；</li>
<li>jdbc：输出到数据库</li>
</ul>
<p>在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出<code>ERROR</code>级别的日志。</p>
<p>最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。</p>
<p>上述结构虽然复杂，但我们在实际使用的时候，并不需要关心Log4j的API，而是通过配置文件来配置它。</p>
<p>以XML配置为例，使用Log4j的时候，我们把一个<code>log4j2.xml</code>的文件放到<code>classpath</code>下就可以让Log4j读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义日志格式 --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;log.pattern&quot;</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义文件名变量 --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 定义Appender，即目的地 --&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义输出到屏幕 --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;err&quot;</span> <span class="hljs-attr">bufferedIO</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;file.err.filename&#125;&quot;</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;file.err.pattern&#125;&quot;</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;1 MB&quot;</span> /&gt;</span><br>			<span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 保留最近10份 --&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;10&quot;</span> /&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> /&gt;</span><br>            <span class="hljs-comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;err&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span> /&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是<code>INFO</code>级别的日志，会自动输出到屏幕，而<code>ERROR</code>级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。</p>
<p><strong>最佳实践</strong></p>
<p>在开发阶段，始终使用Commons Logging接口来写入日志，并且开发阶段无需引入Log4j。如果需要把日志写入文件，只需要把正确的配置文件和Log4j相关的jar包放入<code>classpath</code>，就可以自动把日志切换成使用Log4j写入，无需修改任何代码。</p>
<h4 id="2-4-4-SLF4J-Logback"><a href="#2-4-4-SLF4J-Logback" class="headerlink" title="2.4.4 SLF4J &amp; Logback"></a>2.4.4 SLF4J &amp; Logback</h4><p>因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。</p>
<p>SLF4J 或 Simple Logging Facade for Java 是各种 Java 日志记录框架（如 Log4j 2 或 Logback）的抽象层。这允许在部署时插入不同的日志记录框架，而无需更改代码。</p>
<p><strong>SLF4J特性</strong></p>
<ul>
<li><p>支持{}作为占位符，修改Commons Loggings中字符串拼接的问题</p>
</li>
<li><p>对比一下Commons Logging和SLF4J的接口：</p>
<table>
<thead>
<tr>
<th>Commons Logging</th>
<th>SLF4J</th>
</tr>
</thead>
<tbody><tr>
<td>org.apache.commons.logging.Log</td>
<td>org.slf4j.Logger</td>
</tr>
<tr>
<td>org.apache.commons.logging.LogFactory</td>
<td>org.slf4j.LoggerFactory</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="2-4-5-SLF4J-和-Logback-Log4J的关系"><a href="#2-4-5-SLF4J-和-Logback-Log4J的关系" class="headerlink" title="2.4.5 SLF4J 和 Logback &amp; Log4J的关系"></a>2.4.5 SLF4J 和 Logback &amp; Log4J的关系</h4><p>简单来说、SLF4J是抽象层，Logback和Log4J是通过引入配置来实现SLF4J的具体Api。</p>
<h5 id="slf4j绑定log4j的用法"><a href="#slf4j绑定log4j的用法" class="headerlink" title="slf4j绑定log4j的用法"></a>slf4j绑定log4j的用法</h5><p><strong>pom.xml添加依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><strong>配置文件</strong></p>
<ol>
<li><p>必须配置root logger和一个appender。</p>
</li>
<li><p>日志输出级别</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义日志格式 --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;log.pattern&quot;</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义文件名变量 --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 定义Appender，即目的地 --&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义输出到屏幕 --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;err&quot;</span> <span class="hljs-attr">bufferedIO</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;file.err.filename&#125;&quot;</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;file.err.pattern&#125;&quot;</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;1 MB&quot;</span> /&gt;</span><br>			<span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 保留最近10份 --&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;10&quot;</span> /&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> /&gt;</span><br>            <span class="hljs-comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;err&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span> /&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h5 id="slf4j绑定logback的用法"><a href="#slf4j绑定logback的用法" class="headerlink" title="slf4j绑定logback的用法"></a><strong>slf4j绑定logback的用法</strong></h5><p><strong>pom.xml添加依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>配置文件</strong></p>
<p>配置文件几乎和log4j差不多，如下。选择需要的appender就可以了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span> ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- encoders are assigned the type</span><br><span class="hljs-comment">             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg %n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Insert the current time formatted as &quot;yyyyMMdd&#x27;T&#x27;HHmmss&quot; under</span><br><span class="hljs-comment">         the key &quot;bySecond&quot; into the logger context. This value will be</span><br><span class="hljs-comment">         available to all subsequent configuration elements. --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">timestamp</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;bySecond&quot;</span> <span class="hljs-attr">datePattern</span>=<span class="hljs-string">&quot;yyyyMMdd&#x27;T&#x27;HHmmss&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>testFile-$&#123;bySecond&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">append</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">append</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- encoders are assigned the type</span><br><span class="hljs-comment">             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;DAYFILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>logFile.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- daily rollover --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>logFile.%d&#123;yyyy-MM-dd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- keep 30 days&#x27; worth of history capped at 3GB total size --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">totalSizeCap</span>&gt;</span>3GB<span class="hljs-tag">&lt;/<span class="hljs-name">totalSizeCap</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;debug&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;DAYFILE&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>一个日志的样例</strong></p>
<p>slf4j+logback</p>
<p><code>logback</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Console Appender: 输出日志到控制台 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 定义日志输出格式 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5level %logger&#123;36&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- File Appender: 输出日志到文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>logs/app.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5level %logger&#123;36&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 设置日志记录的根级别和输出目的地 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><code>slf4j</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.rce;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Log.class);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        logger.debug(<span class="hljs-string">&quot;This is a debug message&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;This is an info message&quot;</span>);<br>        logger.warn(<span class="hljs-string">&quot;This is a warn message&quot;</span>);<br>        logger.error(<span class="hljs-string">&quot;This is an error message&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>pom.xml</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 使用最新版本 --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- Logback Classic (SLF4J 实现) --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 使用 Logback 最新版本 --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- Logback Core --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="3-反射"><a href="#3-反射" class="headerlink" title="3. 反射"></a>3. 反射</h2><h3 id="3-1-Class类"><a href="#3-1-Class类" class="headerlink" title="3.1 Class类"></a>3.1 Class类</h3><p>反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p>
<p>获取class的Class实例方法</p>
<p>1）直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> String.class;<br></code></pre></td></tr></table></figure>

<p>2）如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> s.getClass();<br></code></pre></td></tr></table></figure>

<p>3）如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br></code></pre></td></tr></table></figure>



<blockquote>
<p>[!CAUTION]</p>
<p>instanceof 不但匹配制定类型，还匹配制定的子类，用&#x3D;&#x3D;判断class实例可以精确的判断数据类型，但不能作子类型比较。</p>
</blockquote>
<p>通过Class.newInstance()可以创建类实例，局限是只能调用public的无参构造方法。</p>
<h4 id="3-1-1-动态加载"><a href="#3-1-1-动态加载" class="headerlink" title="3.1.1 动态加载"></a>3.1.1 动态加载</h4><p>动态加载<code>class</code>的特性对于Java程序非常重要。利用JVM动态加载<code>class</code>的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Commons Logging优先使用Log4j:</span><br><span class="hljs-type">LogFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (isClassPresent(<span class="hljs-string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;<br>    factory = createLog4j();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    factory = createJdkLog();<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isClassPresent</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Class.forName(name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这就是为什么我们只需要把Log4j的jar包放到classpath中，Commons Logging就会自动使用Log4j的原因。</p>
<h3 id="3-2-访问字段"><a href="#3-2-访问字段" class="headerlink" title="3.2 访问字段"></a>3.2 访问字段</h3><p><strong>关键类：Field</strong></p>
<p><code>Class</code>类提供了以下几个方法来获取字段：</p>
<ul>
<li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li>
<li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li>
<li>Field[] getFields()：获取所有public的field（包括父类）</li>
<li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li>
</ul>
<p><code>Field</code>对象包含了一个字段的所有信息</p>
<ul>
<li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li>
<li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li>
<li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<h4 id="3-2-1-获取字段值"><a href="#3-2-1-获取字段值" class="headerlink" title="3.2.1 获取字段值"></a>3.2.1 获取字段值</h4><p>先获取<code>Class</code>实例，再获取<code>Field</code>实例，然后，用<code>Field.get(Object)</code>获取指定实例的指定字段的值。</p>
<p>如果不知道Field实例的名称可以打印所有Fields然后通过name访问。</p>
<p>正常情况下，<code>Main</code>类无法访问<code>Person</code>类的<code>private</code>字段。要修复错误，可以将<code>private</code>改为<code>public</code>，或者，在调用<code>Object value = f.get(p);</code>前，先写一句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">f.setAccessible(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>

<p>调用<code>Field.setAccessible(true)</code>的意思是，别管这个字段是不是<code>public</code>，一律允许访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Xiao Ming&quot;</span>, <span class="hljs-number">20</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> p.getClass();<br>        Field[] fields = c.getDeclaredFields();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        f.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> f.get(p);<br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            System.out.println(field.getName());<br>        &#125;<br>        System.out.println(value);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>[!NOTE]</p>
<p>如果使用反射可以获取<code>private</code>字段的值，那么类的封装还有什么意义？</p>
<p>答案是正常情况下，我们总是通过<code>p.name</code>来访问<code>Person</code>的<code>name</code>字段，编译器会根据<code>public</code>、<code>protected</code>和<code>private</code>决定是否允许访问字段，这样就达到了数据封装的目的。</p>
<p>而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</p>
<p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p>
</blockquote>
<h4 id="3-2-2-设置字段值"><a href="#3-2-2-设置字段值" class="headerlink" title="3.2.2 设置字段值"></a>3.2.2 设置字段值</h4><p>设置字段值是通过<code>Field.set(Object, Object)</code>实现的。同样的，修改非<code>public</code>字段，需要首先调用<code>setAccessible(true)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Xiao Ming&quot;</span>, <span class="hljs-number">20</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> p.getClass();<br>        Field[] fields = c.getDeclaredFields();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        f.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> f.get(p);<br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            System.out.println(field.getName());<br>        &#125;<br>        System.out.println(value);<br>      	f.set(p, <span class="hljs-string">&quot;Xiao Hong&quot;</span>);<br>        System.out.println(p.getName()); <span class="hljs-comment">// &quot;Xiao Hong&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-3-调用方法"><a href="#3-3-调用方法" class="headerlink" title="3.3 调用方法"></a>3.3 调用方法</h3><p><strong>关键类：Method</strong></p>
<p>和访问字段基本一致。首先获得Method对象。</p>
<ul>
<li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li>
<li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li>
</ul>
<p>根据Method对象获得方法的所有信息</p>
<ul>
<li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li>
<li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li>
<li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li>
<li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<p>通过使用invoke方法进行调用。</p>
<p><code>Object invoke(Object obj, Object... args) throws IllegalAccessException</code></p>
<p><strong>调用方法</strong></p>
<p><code>invoke(对象，可变参数)</code></p>
<p><strong>调用静态方法</strong></p>
<p><code>invoke(null, 可变参数)</code></p>
<p><strong>调用非静态方法</strong></p>
<p>通过<code>Method.setAccessible(true)</code>允许其调用，再使用invoke进行调用。</p>
<blockquote>
<p>[!NOTE]</p>
<p>如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p>
</blockquote>
<p><strong>多态</strong></p>
<p>我们来考察这样一种情况：一个<code>Person</code>类定义了<code>hello()</code>方法，并且它的子类<code>Student</code>也覆写了<code>hello()</code>方法，那么，从<code>Person.class</code>获取的<code>Method</code>，作用于<code>Student</code>实例时，调用的方法到底是哪个？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// reflection</span><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取Person的hello方法:</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> Person.class.getMethod(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-type">int</span>.class, <span class="hljs-type">int</span>.class);<br>        <span class="hljs-comment">// 对Student实例调用hello方法:</span><br>        h.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(), <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Person:hello&quot;</span> + a + b);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Student:hello&quot;</span> + a + b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行上述代码，发现打印出的是<code>Student:hello12</code>，因此，使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。并且invoke的参数列表是可变参数列表。</p>
<h3 id="3-4-调用构造方法"><a href="#3-4-调用构造方法" class="headerlink" title="3.4 调用构造方法"></a>3.4 调用构造方法</h3><p><strong>关键类：Constructor</strong></p>
<p>由于Class提供的newInstance()方法只能调用该类的无参构造方法，所以使用Constructor对象来返回Class实例的构造函数方法。该构造方法仅与当前类有关，和父类无关，不存在多态的问题。调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p>
<ul>
<li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li>
<li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li>
</ul>
<h3 id="3-5-获取继承关系"><a href="#3-5-获取继承关系" class="headerlink" title="3.5 获取继承关系"></a>3.5 获取继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取父类</span><br>class.getSuperClass()<br><span class="hljs-comment">// 获取接口</span><br>class.getInterfaces()<br><span class="hljs-comment">// 判断继承关系</span><br><span class="hljs-comment">// 两个Class实例，要判断一个向上转型是否成立，可以调用</span><br>class.isAssignableFrom()<br><br><span class="hljs-comment">// Integer i = ?</span><br>Integer.class.isAssignableFrom(Integer.class); <span class="hljs-comment">// true，因为Integer可以赋值给Integer</span><br><span class="hljs-comment">// Number n = ?</span><br>Number.class.isAssignableFrom(Integer.class); <span class="hljs-comment">// true，因为Integer可以赋值给Number</span><br><span class="hljs-comment">// Object o = ?</span><br>Object.class.isAssignableFrom(Integer.class); <span class="hljs-comment">// true，因为Integer可以赋值给Object</span><br><span class="hljs-comment">// Integer i = ?</span><br>Integer.class.isAssignableFrom(Number.class); <span class="hljs-comment">// false，因为Number不能赋值给Integer</span><br></code></pre></td></tr></table></figure>

<ul>
<li>除<code>Object</code>外，其他任何非<code>interface</code>的<code>Class</code>都必定存在一个父类类型。</li>
<li><code>getInterfaces()</code>只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型</li>
</ul>
<h3 id="3-6-动态代理"><a href="#3-6-动态代理" class="headerlink" title="3.6 动态代理"></a>3.6 动态代理</h3><h2 id="4-泛型"><a href="#4-泛型" class="headerlink" title="4. 泛型"></a>4. 泛型</h2><h3 id="4-1-什么是泛型"><a href="#4-1-什么是泛型" class="headerlink" title="4.1 什么是泛型"></a>4.1 什么是泛型</h3><p>对于ArrayList来说，如果数组内容发生改变，那么要重新定义其他的ArrayList以实现适配。为了解决这个问题，我们把ArrayList变成一个模版<code>ArrayList&lt;T&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T e)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样在代码中就可以实现编写一次代码创建为任意类型的ArrayList</p>
<p><strong>向上转型</strong></p>
<p>用一个图来表示泛型的继承关系，就是<code>T</code>不变时，可以向上转型，<code>T</code>本身不能向上转型：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">  <span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">Integer</span><span class="hljs-operator">&gt;</span>     <span class="hljs-variable">ArrayList</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">Number</span><span class="hljs-operator">&gt;</span><br>    ▲                            ▲<br>    │                            │<br>    │                            <span class="hljs-variable">X</span><br>    │                            │<br><span class="hljs-variable">ArrayList</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">Integer</span><span class="hljs-operator">&gt;</span>  <span class="hljs-variable">ArrayList</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">Integer</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="4-2-使用泛型"><a href="#4-2-使用泛型" class="headerlink" title="4.2 使用泛型"></a>4.2 使用泛型</h3><p>使用ArrayList时，如果不定义泛型类型，泛型类型实际上就是Object。</p>
<p>编译器如果能自动推断吃泛型类型，就可以省略后面的泛型类型，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Number&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 省略ArrayList的范型类型</span><br></code></pre></td></tr></table></figure>



<p><strong>泛型接口</strong></p>
<p><code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code>Comparable&lt;T&gt;</code>这个泛型接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回负数: 当前实例比参数o小</span><br><span class="hljs-comment">     * 返回0: 当前实例与参数o相等</span><br><span class="hljs-comment">     * 返回正数: 当前实例比参数o大</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="4-3-编写泛型"><a href="#4-3-编写泛型" class="headerlink" title="4.3 编写泛型"></a>4.3 编写泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p><strong>静态方法</strong></p>
<p>编写泛型类时，要特别注意，泛型类型<code>&lt;T&gt;</code>不能用于静态方法。对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的<code>create()</code>静态方法，我们应该把它改为另一种泛型类型，例如，<code>&lt;K&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>    <br><span class="hljs-comment">//    // 对静态方法使用&lt;T&gt;:</span><br><span class="hljs-comment">//    public static Pair&lt;T&gt; create(T first, T last) &#123;</span><br><span class="hljs-comment">//        return new Pair&lt;T&gt;(first, last);</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-comment">// 静态泛型方法应该使用其他类型区分:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K&gt; Pair&lt;K&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(K first, K last)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;K&gt;(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>多个泛型类型</strong></p>
<p>泛型还可以定义多种类型。例如，我们希望<code>Pair</code>不总是存储两个类型一样的对象，就可以使用类型<code>&lt;T, K&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T, K&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> K last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, K last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123; ... &#125;<br>    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用的时候，需要指出两种类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;String, Integer&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure>

<p>Java标准库的<code>Map&lt;K, V&gt;</code>就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。</p>
<h3 id="4-4-擦拭法"><a href="#4-4-擦拭法" class="headerlink" title="4.4 擦拭法"></a>4.4 擦拭法</h3><p>Java语言实现泛型的方式是擦拭法（Type Erasure）。</p>
<p>虚拟机对泛型一无所知，所有的工作都是编译器做的。所以Java泛型是编译器在编译时实行的，编译器内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是，在需要转型的时候，编译器会根据<code>T</code>的类型自动为我们实行安全地强制转型。</p>
<p>使用泛型的局限</p>
<ul>
<li><code>&lt;T&gt;</code>不能是基本类型，例如<code>int</code>，因为实际类型是<code>Object</code>，<code>Object</code>类型无法持有基本类型</li>
<li>无法取得带泛型的<code>Class</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Pair&lt;String&gt; p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>        Pair&lt;Integer&gt; p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> p1.getClass();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> p2.getClass();<br>        System.out.println(c1==c2); <span class="hljs-comment">// true</span><br>        System.out.println(c1==Pair.class); <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因为<code>T</code>是<code>Object</code>，我们对<code>Pair&lt;String&gt;</code>和<code>Pair&lt;Integer&gt;</code>类型获取<code>Class</code>时，获取到的是同一个<code>Class</code>，也就是<code>Pair</code>类的<code>Class</code>。</p>
<p>换句话说，所有泛型实例，无论<code>T</code>的类型是什么，<code>getClass()</code>返回同一个<code>Class</code>实例，因为编译后它们全部都是<code>Pair&lt;Object&gt;</code>。</p>
<ul>
<li><p>无法判断带泛型的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br><span class="hljs-comment">// Compile error:</span><br><span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> Pair&lt;String&gt;) &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>原因和前面一样，并不存在<code>Pair&lt;String&gt;.class</code>，而是只有唯一的<code>Pair.class</code>。</p>
</li>
<li><p>不能实例化<code>T</code>类型</p>
</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>Java的泛型是采用擦拭法实现的；</p>
<p>擦拭法决定了泛型<code>&lt;T&gt;</code>：</p>
<ul>
<li>不能是基本类型，例如：<code>int</code>；</li>
<li>不能获取带泛型类型的<code>Class</code>，例如：<code>Pair&lt;String&gt;.class</code>；</li>
<li>不能判断带泛型类型的类型，例如：<code>x instanceof Pair&lt;String&gt;</code>；</li>
<li>不能实例化<code>T</code>类型，例如：<code>new T()</code>。</li>
</ul>
<p>泛型方法要防止重复定义方法，例如：<code>public boolean equals(T obj)</code>；</p>
<p>子类可以获取父类的泛型类型<code>&lt;T&gt;</code>。</p>
<h3 id="4-5-extends-通配符"><a href="#4-5-extends-通配符" class="headerlink" title="4.5 extends 通配符"></a>4.5 extends 通配符</h3><p>使用类似<code>&lt;? extends Number&gt;</code>通配符作为方法参数时表示：</p>
<ul>
<li>方法内部可以调用获取<code>Number</code>引用的方法，例如：<code>Number n = obj.getFirst();</code>；</li>
<li>方法内部无法调用传入<code>Number</code>引用的方法（<code>null</code>除外），例如：<code>obj.setFirst(Number n);</code>。</li>
</ul>
<p>即一句话总结：使用<code>extends</code>通配符表示可以读，不能写。</p>
<p>使用类似<code>&lt;T extends Number&gt;</code>定义泛型类时表示：</p>
<ul>
<li>泛型类型限定为<code>Number</code>以及<code>Number</code>的子类。</li>
</ul>
<h3 id="4-6-super通配符"><a href="#4-6-super通配符" class="headerlink" title="4.6 super通配符"></a>4.6 super通配符</h3><p>我们再回顾一下<code>extends</code>通配符。作为方法参数，<code>&lt;? extends T&gt;</code>类型和<code>&lt;? super T&gt;</code>类型的区别在于：</p>
<ul>
<li><code>&lt;? extends T&gt;</code>允许调用读方法<code>T get()</code>获取<code>T</code>的引用，但不允许调用写方法<code>set(T)</code>传入<code>T</code>的引用（传入<code>null</code>除外）；</li>
<li><code>&lt;? super T&gt;</code>允许调用写方法<code>set(T)</code>传入<code>T</code>的引用，但不允许调用读方法<code>T get()</code>获取<code>T</code>的引用（获取<code>Object</code>除外）。</li>
</ul>
<p>一个是允许读不允许写，另一个是允许写不允许读。</p>
<p>先记住上面的结论，我们来看Java标准库的<code>Collections</code>类定义的<code>copy()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br>    <span class="hljs-comment">// 把src的每个元素复制到dest中:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;src.size(); i++) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> src.get(i);<br>            dest.add(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>它的作用是把一个<code>List</code>的每个元素依次添加到另一个<code>List</code>中。它的第一个参数是<code>List&lt;? super T&gt;</code>，表示目标<code>List</code>，第二个参数<code>List&lt;? extends T&gt;</code>，表示要复制的<code>List</code>。我们可以简单地用<code>for</code>循环实现复制。在<code>for</code>循环中，我们可以看到，对于类型<code>&lt;? extends T&gt;</code>的变量<code>src</code>，我们可以安全地获取类型<code>T</code>的引用，而对于类型<code>&lt;? super T&gt;</code>的变量<code>dest</code>，我们可以安全地传入<code>T</code>的引用。</p>
<p>这个<code>copy()</code>方法的定义就完美地展示了<code>extends</code>和<code>super</code>的意图：</p>
<ul>
<li><code>copy()</code>方法内部不会读取<code>dest</code>，因为不能调用<code>dest.get()</code>来获取<code>T</code>的引用；</li>
<li><code>copy()</code>方法内部也不会修改<code>src</code>，因为不能调用<code>src.add(T)</code>。</li>
</ul>
<p>这是由编译器检查来实现的。如果在方法代码中意外修改了<code>src</code>，或者意外读取了<code>dest</code>，就会导致一个编译错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br>    <span class="hljs-comment">// 把src的每个元素复制到dest中:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;<br>        ...<br>        <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dest.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// compile error!</span><br>        src.add(t); <span class="hljs-comment">// compile error!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个<code>copy()</code>方法的另一个好处是可以安全地把一个<code>List&lt;Integer&gt;</code>添加到<code>List&lt;Number&gt;</code>，但是无法反过来添加：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// copy List&lt;Integer&gt; to List&lt;Number&gt; ok:</span><br>List&lt;Number&gt; numList = ...;<br>List&lt;Integer&gt; intList = ...;<br>Collections.copy(numList, intList);<br><br><span class="hljs-comment">// ERROR: cannot copy List&lt;Number&gt; to List&lt;Integer&gt;:</span><br>Collections.copy(intList, numList);<br></code></pre></td></tr></table></figure>

<p>而这些都是通过<code>super</code>和<code>extends</code>通配符，并由编译器强制检查来实现的。</p>
<h5 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h5><p>何时使用<code>extends</code>，何时使用<code>super</code>？为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。</p>
<p>即：如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符。</p>
<p>还是以<code>Collections</code>的<code>copy()</code>方法为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;src.size(); i++) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> src.get(i); <span class="hljs-comment">// src是producer</span><br>            dest.add(t); <span class="hljs-comment">// dest是consumer</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要返回<code>T</code>的<code>src</code>是生产者，因此声明为<code>List&lt;? extends T&gt;</code>，需要写入<code>T</code>的<code>dest</code>是消费者，因此声明为<code>List&lt;? super T&gt;</code>。</p>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>使用类似<code>&lt;? super Integer&gt;</code>通配符作为方法参数时表示：</p>
<ul>
<li>方法内部可以调用传入<code>Integer</code>引用的方法，例如：<code>obj.setFirst(Integer n);</code>；</li>
<li>方法内部无法调用获取<code>Integer</code>引用的方法（<code>Object</code>除外），例如：<code>Integer n = obj.getFirst();</code>。</li>
</ul>
<p>即使用<code>super</code>通配符表示只能写不能读。</p>
<p>使用<code>extends</code>和<code>super</code>通配符要遵循PECS原则。</p>
<p>无限定通配符<code>&lt;?&gt;</code>很少使用，可以用<code>&lt;T&gt;</code>替换，同时它是所有<code>&lt;T&gt;</code>类型的超类。</p>
<h3 id="4-7-泛型和反射"><a href="#4-7-泛型和反射" class="headerlink" title="4.7 泛型和反射"></a>4.7 泛型和反射</h3><h2 id="5-集合"><a href="#5-集合" class="headerlink" title="5. 集合"></a>5. 集合</h2><h3 id="5-1-List"><a href="#5-1-List" class="headerlink" title="5.1 List"></a>5.1 List</h3><p>Java中list接口主要有两种实现形式</p>
<table>
<thead>
<tr>
<th></th>
<th>ArrayList（优先使用）</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td>获取指定元素</td>
<td>速度很快</td>
<td>需要从头开始查找元素</td>
</tr>
<tr>
<td>添加元素到末尾</td>
<td>速度很快</td>
<td>速度很快</td>
</tr>
<tr>
<td>在指定位置添加&#x2F;删除</td>
<td>需要移动元素</td>
<td>不需要移动元素</td>
</tr>
<tr>
<td>内存占用</td>
<td>少</td>
<td>较大</td>
</tr>
</tbody></table>
<p>主要的接口方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E e)</span><br>E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object e)</span><br>E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure>

<h4 id="5-1-1-List使用"><a href="#5-1-1-List使用" class="headerlink" title="5.1.1 List使用"></a>5.1.1 List使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化</span><br>List&lt;Integer&gt; list = List.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);<span class="hljs-comment">// 不接受传入null值</span><br><span class="hljs-comment">// 或者使用ArrayList和LinkedList初始化，接受null值</span><br><br><span class="hljs-comment">// 遍历</span><br><span class="hljs-comment">// 1 不推荐，一是代码复杂，二是因为get(int)方法只有ArrayList的实现是高效的，换成LinkedList后，索引越大，访问速度越慢。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> list.get(i);<br>&#125;<br><br><span class="hljs-comment">// 2 使用迭代器Iterator来访问List</span><br><span class="hljs-keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();<br>&#125;<br><br><span class="hljs-comment">// 3 等价于迭代器的for each循环</span><br><span class="hljs-keyword">for</span> (String s : list) &#123;<br>    System.out.println(s);<br>&#125;<br><br><span class="hljs-comment">// List Array转换</span><br><span class="hljs-comment">// 使用toArray()方法会返回一个Object[]数组，丢失信息</span><br><span class="hljs-comment">// 在toArray(T[])方法中传入类型相同的Array来解决类型丢失的问题</span><br>List&lt;Integer&gt; list = List.of(<span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">56</span>);<br>Integer[] array = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[list.size()]);<br><span class="hljs-keyword">for</span> (Integer n : array) &#123;<br>    System.out.println(n);<br>&#125;<br><br><span class="hljs-comment">// equals方法</span><br><span class="hljs-comment">// List的contain() indexOf()的方法使用equals方法进行元素比较，因此如果需要使用这两个方法，必须要重写equals方法</span><br></code></pre></td></tr></table></figure>

<h5 id="编写equals"><a href="#编写equals" class="headerlink" title="编写equals"></a>编写equals</h5><p>如何正确编写<code>equals()</code>方法？<code>equals()</code>方法要求我们必须满足以下条件：</p>
<ul>
<li>自反性（Reflexive）：对于非<code>null</code>的<code>x</code>来说，<code>x.equals(x)</code>必须返回<code>true</code>；</li>
<li>对称性（Symmetric）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，则<code>y.equals(x)</code>也必须为<code>true</code>；</li>
<li>传递性（Transitive）：对于非<code>null</code>的<code>x</code>、<code>y</code>和<code>z</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么<code>x.equals(z)</code>也必须为<code>true</code>；</li>
<li>一致性（Consistent）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，只要<code>x</code>和<code>y</code>状态不变，则<code>x.equals(y)</code>总是一致地返回<code>true</code>或者<code>false</code>；</li>
<li>对<code>null</code>的比较：即<code>x.equals(null)</code>永远返回<code>false</code>。</li>
</ul>
<ol>
<li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li>
<li>用<code>instanceof</code>判断传入的待比较的<code>Object</code>是不是当前类型，如果是，继续比较，否则，返回<code>false</code>；</li>
<li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li>
</ol>
<h3 id="5-2-Map"><a href="#5-2-Map" class="headerlink" title="5.2 Map"></a>5.2 Map</h3><p>主要方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">put(K key, V value);<br>V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">containsKey</span><span class="hljs-params">(K key)</span><br>List&lt;K&gt; <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span><br>List&lt;Entry&lt;String, Integer&gt;&gt; <span class="hljs-title function_">entrySet</span><span class="hljs-params">()</span><br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!IMPORTANT]</p>
<p>Map中不存在重复的key，因为放入相同的key，只会把原有的key-value对应的value给替换掉。</p>
<p>遍历Map时，不可假设输出的key是有序的！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 遍历Map,Map存储的是key-value的映射关系，并且，它不保证顺序</span><br><span class="hljs-keyword">for</span> (String key : map.keySet()) &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(key);<br>    System.out.println(key + <span class="hljs-string">&quot; = &quot;</span> + value);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="编写hashCode方法"><a href="#编写hashCode方法" class="headerlink" title="编写hashCode方法"></a>编写hashCode方法</h5><p>在Map内部对key的比较是通过equals()实现的。而通过key计算索引的方式就是调用key对象的hashCode()方法，返回一个int即value的索引，继而返回value。</p>
<p>正确使用<code>Map</code>必须保证：</p>
<ol>
<li><p>作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法，相等的两个<code>key</code>实例调用<code>equals()</code>必须返回<code>true</code>；</p>
</li>
<li><p>作为key</p>
<p>的对象还必须正确覆写hashCode()</p>
<p>方法，且hashCode()方法要严格遵循以下规范：</p>
<ul>
<li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li>
<li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li>
</ul>
</li>
</ol>
<p>和实现<code>equals()</code>方法遇到的问题类似，如果<code>firstName</code>或<code>lastName</code>为<code>null</code>，上述代码工作起来就会抛<code>NullPointerException</code>。为了解决这个问题，我们在计算<code>hashCode()</code>的时候，经常借助<code>Objects.hash()</code>来计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Objects.hash(firstName, lastName, age);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以，编写<code>equals()</code>和<code>hashCode()</code>遵循的原则是：</p>
<p><code>equals()</code>用到的用于比较的每一个字段，都必须在<code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，绝不可放在<code>hashCode()</code>中计算。</p>
<blockquote>
<p>[!NOTE]</p>
<p><code>hashCode()</code>方法编写得越好，<code>HashMap</code>工作的效率就越高。</p>
</blockquote>
<h4 id="5-2-1-EnumMap"><a href="#5-2-1-EnumMap" class="headerlink" title="5.2.1 EnumMap"></a>5.2.1 EnumMap</h4><p>如果作为key的对象是<code>enum</code>类型，那么，还可以使用Java集合库提供的一种<code>EnumMap</code>，它在内部以一个非常紧凑的数组存储value，并且根据<code>enum</code>类型的key直接定位到内部数组的索引，并不需要计算<code>hashCode()</code>，不但效率最高，而且没有额外的空间浪费。</p>
<h4 id="5-2-2-有序Map"><a href="#5-2-2-有序Map" class="headerlink" title="5.2.2 有序Map"></a>5.2.2 <strong>有序Map</strong></h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">     	 ┌───┐<br>       │<span class="hljs-built_in">Map</span>│<br>       └───┘<br>         ▲<br>    ┌────┴─────┐<br>    │          │<br>┌───────┐ ┌─────────┐<br>│<span class="hljs-variable">HashMap</span>│ │<span class="hljs-variable">SortedMap</span>│<br>└───────┘ └─────────┘<br>               ▲<br>               │<br>          ┌─────────┐<br>          │ <span class="hljs-built_in">TreeMap</span> │<br>          └─────────┘<br></code></pre></td></tr></table></figure>



<p><code>SortedMap</code>是根据key进行排序的map。<code>SortedMap</code>是接口，它的实现类是<code>TreeMap</code>。</p>
<p>使用<code>TreeMap</code>时，放入的Key必须实现<code>Comparable</code>接口。<code>String</code>、<code>Integer</code>这些类已经实现了<code>Comparable</code>接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求。</p>
<blockquote>
<p>[!WARNING]</p>
<p>使用TreeMap时，对Key的比较需要正确实现相等、大于和小于逻辑！</p>
</blockquote>
<p>如果作为Key的class没有实现<code>Comparable</code>接口，那么，必须在创建<code>TreeMap</code>时同时指定一个自定义排序算法，<code>TreeMap</code>在比较两个Key是否相等时，依赖Key的<code>compareTo()</code>方法或者<code>Comparator.compare()</code>方法。在两个Key相等时，必须返回<code>0</code>。：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自己实现compare方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student p1, Student p2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (p1.score == p2.score) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1.score &gt; p2.score ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用key的compareTo方法</span><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;Person, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Person&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Person p1, Person p2)</span> &#123;<br>                <span class="hljs-keyword">return</span> p1.name.compareTo(p2.name);<br>            &#125;<br>        &#125;);<br>        map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Tom&quot;</span>), <span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>), <span class="hljs-number">2</span>);<br>        map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Lily&quot;</span>), <span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (Person key : map.keySet()) &#123;<br>            System.out.println(key);<br>        &#125;<br>        <span class="hljs-comment">// &#123;Person: Bob&#125;, &#123;Person: Lily&#125;, &#123;Person: Tom&#125;</span><br>        System.out.println(map.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>))); <span class="hljs-comment">// 2</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    Person(String name) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;Person: &quot;</span> + name + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-2-3-Properties"><a href="#5-2-3-Properties" class="headerlink" title="5.2.3 Properties"></a>5.2.3 Properties</h4><p>典型配置文件：springboot.properties</p>
<p>配置文件非常常用，所以Java集合库提供了一个<code>Properties</code>来表示一组“配置”。由于历史遗留原因，<code>Properties</code>内部本质上是一个<code>Hashtable</code>，但我们只需要用到<code>Properties</code>自身关于读写配置的接口。</p>
<h5 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h5><p>用<code>Properties</code>读取配置文件，一共有三步：</p>
<ol>
<li>创建<code>Properties</code>实例；</li>
<li>调用<code>load()</code>读取文件；</li>
<li>调用<code>getProperty()</code>获取配置。</li>
</ol>
<p>调用<code>getProperty()</code>获取配置时，如果key不存在，将返回<code>null</code>。我们还可以提供一个默认值，这样，当key不存在的时候，就返回默认值。</p>
<h5 id="写入配置文件"><a href="#写入配置文件" class="headerlink" title="写入配置文件"></a>写入配置文件</h5><p>通过<code>setProperty()</code>修改<code>Properties</code>实例</p>
<h3 id="5-3-Set"><a href="#5-3-Set" class="headerlink" title="5.3 Set"></a>5.3 Set</h3><p>主要方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object e)</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object e)</span><br></code></pre></td></tr></table></figure>

<p>最常用的Set的实现类是HashSet，HashSet是HashMap的简单封装；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSet</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Set</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// 持有一个HashMap:</span><br>    <span class="hljs-keyword">private</span> HashMap&lt;E, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 放入HashMap的value:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.put(e, PRESENT) == <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.containsKey(o);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.remove(o) == PRESENT;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Set</code>接口并不保证有序，而<code>SortedSet</code>接口则保证元素是有序的：</p>
<ul>
<li><code>HashSet</code>是无序的，因为它实现了<code>Set</code>接口，并没有实现<code>SortedSet</code>接口；</li>
<li><code>TreeSet</code>是有序的，因为它实现了<code>SortedSet</code>接口。</li>
<li>使用<code>TreeSet</code>和使用<code>TreeMap</code>的要求一样，添加的元素必须正确实现<code>Comparable</code>接口，如果没有实现<code>Comparable</code>接口，那么创建<code>TreeSet</code>时必须传入一个<code>Comparator</code>对象。</li>
</ul>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gams">       ┌───┐<br>       │<span class="hljs-keyword">Set</span>│<br>       └───┘<br>         ▲<br>    ┌────┴─────┐<br>    │          │<br>┌───────┐ ┌─────────┐<br>│HashSet│ │SortedSet│<br>└───────┘ └─────────┘<br>               ▲<br>               │<br>          ┌─────────┐<br>          │ TreeSet │<br>          └─────────┘<br></code></pre></td></tr></table></figure>

<h3 id="5-4-Queue"><a href="#5-4-Queue" class="headerlink" title="5.4 Queue"></a>5.4 Queue</h3><h4 id="5-4-1-Queue"><a href="#5-4-1-Queue" class="headerlink" title="5.4.1 Queue"></a>5.4.1 Queue</h4><p>队列是一种经常使用的集合。<code>Queue</code>实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和<code>List</code>的区别在于，<code>List</code>可以在任意位置添加和删除元素，而<code>Queue</code>只有两个操作：</p>
<ul>
<li>把元素添加到队列末尾；</li>
<li>从队列头部取出元素。</li>
</ul>
<p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>：获取队列长度；<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E)</span>/<span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E)</span>：添加元素到队尾；<br>E <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>/E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>：获取队首元素并从队列中删除；<br>E <span class="hljs-title function_">element</span><span class="hljs-params">()</span>/E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>：获取队首元素但并不从队列中删除。<br></code></pre></td></tr></table></figure>

<p>对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>throw Exception</th>
<th>返回false或null</th>
</tr>
</thead>
<tbody><tr>
<td>添加元素到队尾</td>
<td>add(E e)</td>
<td>boolean offer(E e)</td>
</tr>
<tr>
<td>取队首元素并删除</td>
<td>E remove()</td>
<td>E poll()</td>
</tr>
<tr>
<td>取队首元素但不删除</td>
<td>E element()</td>
<td>E peek()</td>
</tr>
</tbody></table>
<ul>
<li><strong>注意：</strong><code>LinkedList</code>即实现了<code>List</code>接口，又实现了<code>Queue</code>接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这是一个List:</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-comment">// 这是一个Queue:</span><br>Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>

<p>始终按照面向抽象编程的原则编写代码，可以大大提高代码的质量。</p>
<h4 id="5-4-2-PriorityQueue"><a href="#5-4-2-PriorityQueue" class="headerlink" title="5.4.2 PriorityQueue"></a>5.4.2 PriorityQueue</h4><p><code>PriorityQueue</code>和<code>Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对<code>PriorityQueue</code>调用<code>remove()</code>或<code>poll()</code>方法，返回的总是优先级最高的元素。</p>
<p>要使用<code>PriorityQueue</code>，我们就必须给每个元素定义“优先级”。我们以实际代码为例，先看看<code>PriorityQueue</code>的行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Queue&lt;String&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-string">&quot;apple&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;pear&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;banana&quot;</span>);<br>        System.out.println(q.poll()); <span class="hljs-comment">// apple</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// banana</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// pear</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// null,因为队列为空</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们放入的顺序是<code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;banana&quot;</code>，但是取出的顺序却是<code>&quot;apple&quot;</code>、<code>&quot;banana&quot;</code>、<code>&quot;pear&quot;</code>，这是因为从字符串的排序看，<code>&quot;apple&quot;</code>排在最前面，<code>&quot;pear&quot;</code>排在最后面。</p>
<p><strong>因此，放入<code>PriorityQueue</code>的元素，必须实现<code>Comparable</code>接口或者提供一个Comparator的对象，<code>PriorityQueue</code>会根据元素的排序顺序决定出队的优先级。</strong></p>
<p><strong>银行排队业务实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Queue&lt;User&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserComparator</span>());<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;A1&quot;</span>));<br>        q.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;A2&quot;</span>));<br>        q.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Boss&quot;</span>, <span class="hljs-string">&quot;V1&quot;</span>));<br>        System.out.println(q.poll()); <span class="hljs-comment">// Boss/V1</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// Bob/A1</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// Alice/A2</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// null,因为队列为空</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;User&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(User u1, User u2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (u1.number.charAt(<span class="hljs-number">0</span>) == u2.number.charAt(<span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-comment">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span><br>          	<span class="hljs-comment">// 这里实现有问题，不应该使用String的compareTo方法，会导致A10排在A2的前面</span><br>            <span class="hljs-keyword">return</span> u1.number.compareTo(u2.number);<br>          	<span class="hljs-comment">// 修改</span><br>          	<span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> Integer.parseInt(u1.number);<br>          	<span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> Integer.parseInt(u2.number);<br>          	<span class="hljs-keyword">return</span> Integer.compare(num1,num2);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (u1.number.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;V&#x27;</span>) &#123;<br>            <span class="hljs-comment">// u1的号码是V开头,优先级高:</span><br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String number;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, String number)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;/&quot;</span> + number;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-4-3-Deque-双端队列"><a href="#5-4-3-Deque-双端队列" class="headerlink" title="5.4.3 Deque 双端队列"></a>5.4.3 Deque 双端队列</h4><p>们来比较一下<code>Queue</code>和<code>Deque</code>出队和入队的方法：</p>
<table>
<thead>
<tr>
<th></th>
<th>Queue</th>
<th>Deque</th>
</tr>
</thead>
<tbody><tr>
<td>添加元素到队尾</td>
<td>add(E e) &#x2F; offer(E e)</td>
<td>addLast(E e) &#x2F; offerLast(E e)</td>
</tr>
<tr>
<td>取队首元素并删除</td>
<td>E remove() &#x2F; E poll()</td>
<td>E removeFirst() &#x2F; E pollFirst()</td>
</tr>
<tr>
<td>取队首元素但不删除</td>
<td>E element() &#x2F; E peek()</td>
<td>E getFirst() &#x2F; E peekFirst()</td>
</tr>
<tr>
<td>添加元素到队首</td>
<td>无</td>
<td>addFirst(E e) &#x2F; offerFirst(E e)</td>
</tr>
<tr>
<td>取队尾元素并删除</td>
<td>无</td>
<td>E removeLast() &#x2F; E pollLast()</td>
</tr>
<tr>
<td>取队尾元素但不删除</td>
<td>无</td>
<td>E getLast() &#x2F; E peekLast()</td>
</tr>
</tbody></table>
<p>使用<code>Deque</code>，推荐总是明确调用<code>offerLast()</code>&#x2F;<code>offerFirst()</code>或者<code>pollFirst()</code>&#x2F;<code>pollLast()</code>方法。</p>
<p><code>Deque</code>是一个接口，它的实现类有<code>ArrayDeque</code>和<code>LinkedList</code>。</p>
<p>我们发现<code>LinkedList</code>真是一个全能选手，它即是<code>List</code>，又是<code>Queue</code>，还是<code>Deque</code>。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不推荐的写法:</span><br>LinkedList&lt;String&gt; d1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>d1.offerLast(<span class="hljs-string">&quot;z&quot;</span>);<br><span class="hljs-comment">// 推荐的写法：</span><br>Deque&lt;String&gt; d2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>d2.offerLast(<span class="hljs-string">&quot;z&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。</p>
<h4 id="5-4-4-Stack"><a href="#5-4-4-Stack" class="headerlink" title="5.4.4 Stack"></a>5.4.4 Stack</h4><p>栈（Stack）是一种后进先出（LIFO）的数据结构，操作栈的元素的方法有：</p>
<ul>
<li>把元素压栈：<code>push(E)</code>；</li>
<li>把栈顶的元素“弹出”：<code>pop(E)</code>；</li>
<li>取栈顶元素但不弹出：<code>peek(E)</code>。</li>
</ul>
<p>在Java中，我们用<code>Deque</code>可以实现<code>Stack</code>的功能，注意只调用<code>push()</code>&#x2F;<code>pop()</code>&#x2F;<code>peek()</code>方法，避免调用<code>Deque</code>的其他方法；</p>
<p>不要使用遗留类<code>Stack</code>。</p>
<h5 id="实现案例"><a href="#实现案例" class="headerlink" title="实现案例"></a>实现案例</h5><p><strong>JVM方法调用栈</strong></p>
<p><strong>计算中缀表达式</strong></p>
<h3 id="5-5-Iterator"><a href="#5-5-Iterator" class="headerlink" title="5.5 Iterator"></a>5.5 Iterator</h3><p> Java的集合类都可以使用<code>for each</code>循环，<code>List</code>、<code>Set</code>和<code>Queue</code>会迭代每个元素，<code>Map</code>会迭代每个key。以<code>List</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>);<br><span class="hljs-keyword">for</span> (String s : list) &#123;<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，Java编译器并不知道如何遍历<code>List</code>。上述代码能够编译通过，只是因为编译器把<code>for each</code>循环通过<code>Iterator</code>改写为了普通的<code>for</code>循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;<br>     <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();<br>     System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们把这种通过<code>Iterator</code>对象遍历集合的模式称为迭代器。</p>
<p>在编写<code>Iterator</code>的时候，我们通常可以用一个内部类来实现<code>Iterator</code>接口，这个内部类可以直接访问对应的外部类的所有字段和方法。例如，上述代码中，内部类<code>ReverseIterator</code>可以用<code>ReverseList.this</code>获得当前外部类的<code>this</code>引用，然后，通过这个<code>this</code>引用就可以访问<code>ReverseList</code>的所有字段和方法。</p>
<h3 id="5-6-Collections"><a href="#5-6-Collections" class="headerlink" title="5.6 Collections"></a>5.6 Collections</h3><ol>
<li><p>创建空集合</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">List</span>.<span class="hljs-title function_">of</span>()<span class="hljs-string">`、`</span><span class="hljs-title class_">Map</span>.<span class="hljs-title function_">of</span>()<span class="hljs-string">`、`</span><span class="hljs-title class_">Set</span>.<span class="hljs-title function_">of</span>() <span class="hljs-comment">//jdk9+</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>创建单元素集合</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">List</span>.of(T<span class="hljs-params">...</span>)<span class="hljs-string">`、`</span><span class="hljs-built_in">Map</span>.of(T<span class="hljs-params">...</span>)<span class="hljs-string">`、`</span><span class="hljs-built_in">Set</span>.of(T<span class="hljs-params">...</span>) <span class="hljs-comment">// jdk9+</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(list);<br></code></pre></td></tr></table></figure>
</li>
<li><p>洗牌</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.shuffle(list);<br></code></pre></td></tr></table></figure>
</li>
<li><p>不可变集合</p>
</li>
<li><p>线程安全集合</p>
</li>
</ol>
<h2 id="6-I-O"><a href="#6-I-O" class="headerlink" title="6. I&#x2F;O"></a>6. I&#x2F;O</h2><h3 id="6-1-IO流简介"><a href="#6-1-IO流简介" class="headerlink" title="6.1 IO流简介"></a>6.1 IO流简介</h3><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p><strong>字节流</strong></p>
<p><strong>字符流</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Sinte-Beuve/p/5758971.html">https://www.cnblogs.com/Sinte-Beuve/p/5758971.html</a></p>
<p><a target="_blank" rel="noopener" href="https://roadmap.sh/java">https://roadmap.sh/java</a></p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/https://liaoxuefeng.com/">廖雪峰的官方网站</a></p>
<p><a target="_blank" rel="noopener" href="https://javabetter.cn/home.html">二哥的Java进阶之路</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/java/" class="category-chain-item">java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/java/" class="print-no-link">#java</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java Base</div>
      <div>https://jiajun-lab.github.io/2024/09/24/Java-Base/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lee</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年9月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/09/24/Spring-Boot-1/" title="Spring Boot(1)">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Spring Boot(1)</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"tUYpg6nx1J5VCJamrfWcKQkl-gzGzoHsz","appKey":"HM1AWutkOYJ9mXYNjwqc7gSy","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
