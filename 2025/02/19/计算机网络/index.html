

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/source/img/siteicon.jpg">
  <link rel="icon" href="/source/img/siteicon.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lee">
  <meta name="keywords" content="">
  
    <meta name="description" content="计算机网络（面试题）1. 介绍TCP&#x2F;IP模型和OSI模型的区别首先从网络模型的结构来讲，TCP&#x2F;IP模型分为四层：应用层，传输层，网络层，网络接口层；OSI模型分为七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 TCP&#x2F;IP模型可以简单的与OSI模型进行对应。OSI的物理层和数据链路层与TCP的网络接口层对应；OSI的上三层与TCP的应用层对应。">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="https://jiajun-lab.github.io/2025/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Lee&#39;s Blog">
<meta property="og:description" content="计算机网络（面试题）1. 介绍TCP&#x2F;IP模型和OSI模型的区别首先从网络模型的结构来讲，TCP&#x2F;IP模型分为四层：应用层，传输层，网络层，网络接口层；OSI模型分为七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 TCP&#x2F;IP模型可以简单的与OSI模型进行对应。OSI的物理层和数据链路层与TCP的网络接口层对应；OSI的上三层与TCP的应用层对应。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:\Users\MasterLi\Documents\GitHub\hexo_myblog\source_posts\%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C\image-20250223140337972.png">
<meta property="og:image" content="c:\Users\MasterLi\Documents\GitHub\hexo_myblog\source_posts\%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C\image-20250223214005765.png">
<meta property="og:image" content="c:\Users\MasterLi\Documents\GitHub\hexo_myblog\source\_posts\%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C\image-20250302214202082.png">
<meta property="og:image" content="c:\Users\MasterLi\Documents\GitHub\hexo_myblog\source\_posts\%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C\image-20250302233703435.png">
<meta property="og:image" content="c:\Users\MasterLi\Documents\GitHub\hexo_myblog\source\_posts\%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C\image-20250302233740538.png">
<meta property="article:published_time" content="2025-02-19T14:11:57.000Z">
<meta property="article:modified_time" content="2025-09-16T01:35:12.942Z">
<meta property="article:author" content="Lee">
<meta property="article:tag" content="实习">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="c:\Users\MasterLi\Documents\GitHub\hexo_myblog\source_posts\%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C\image-20250223140337972.png">
  
  
  
  <title>计算机网络 - Lee&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"jiajun-lab.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"tUYpg6nx1J5VCJamrfWcKQkl-gzGzoHsz","app_key":"HM1AWutkOYJ9mXYNjwqc7gSy","server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lee&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="计算机网络"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-02-19 22:11" pubdate>
          2025年2月19日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          73 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">计算机网络</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="计算机网络（面试题）"><a href="#计算机网络（面试题）" class="headerlink" title="计算机网络（面试题）"></a>计算机网络（面试题）</h1><h3 id="1-介绍TCP-IP模型和OSI模型的区别"><a href="#1-介绍TCP-IP模型和OSI模型的区别" class="headerlink" title="1. 介绍TCP&#x2F;IP模型和OSI模型的区别"></a>1. 介绍TCP&#x2F;IP模型和OSI模型的区别</h3><p>首先从网络模型的结构来讲，TCP&#x2F;IP模型分为四层：应用层，传输层，网络层，网络接口层；OSI模型分为七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p>TCP&#x2F;IP模型可以简单的与OSI模型进行对应。OSI的物理层和数据链路层与TCP的网络接口层对应；OSI的上三层与TCP的应用层对应。</p>
<p>虽然OSI参考模型描写的更为完善，但是由于其实现的复杂性，现在更为广泛使用的模型是TCP的四层模型。</p>
<ol>
<li>其中应用层主要用于两个设备上的应用程序进行数据交换，应用层的数据单位为报文。包括HTTP协议、SMTP协议、POP3等。</li>
<li>传输层主要用于两个设备进程之间的通信提供数据传输服务。主要包括TCP 面向连接的可靠数据传输服务和UDP无连接的尽最大努力的数据传输服务。</li>
<li>网络层的核心功能是<strong>转发和路由</strong>。网络层主要包括IP协议。数据为IP数据报。<strong>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</strong>网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做 <strong>网际层</strong> 或 <strong>IP 层</strong>。</li>
<li>网络接口层可以看成是数据链路层和物理层的合体。链路层将IP数据报组装成帧，每一帧包括必要的控制信息。物理层实现相邻计算机节点之间的比特流透明传输。</li>
</ol>
<h3 id="2-从输入-URL-到页面展示到底发生了什么？"><a href="#2-从输入-URL-到页面展示到底发生了什么？" class="headerlink" title="2. 从输入 URL 到页面展示到底发生了什么？"></a>2. 从输入 URL 到页面展示到底发生了什么？</h3><ol>
<li>在浏览器中输入指定网页的 URL。</li>
<li>浏览器通过 DNS 协议，层层解析域名并获取域名对应的 IP 地址。</li>
<li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。</li>
<li>基于HTTP&#x2F;HTTPs协议，浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li>
<li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li>
<li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL，再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li>
<li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li>
</ol>
<h3 id="3-HTTP请求报文和响应报文是怎样的，有哪些常见的字段？"><a href="#3-HTTP请求报文和响应报文是怎样的，有哪些常见的字段？" class="headerlink" title="3. HTTP请求报文和响应报文是怎样的，有哪些常见的字段？"></a>3. HTTP请求报文和响应报文是怎样的，有哪些常见的字段？</h3><p>TTP报文分为请求报文和响应报文。</p>
<p>（1） 请求报文 请求报文主要由请求行、请求头、空行、请求体构成。 请求行包括如下字段：</p>
<ul>
<li>方法（Method）：指定要执行的操作，如 GET、POST、PUT、DELETE 等。</li>
<li>资源路径（Resource Path）：请求的资源的URI（统一资源标识符）。</li>
<li>HTTP版本（HTTP Version）：使用的HTTP协议版本，如 HTTP&#x2F;1.1 或 HTTP&#x2F;2.0。</li>
</ul>
<p>请求头的字段较多，常使用的包含以下几个：</p>
<ul>
<li>Host：请求的服务器的域名。</li>
<li>Accept：客户端能够处理的媒体类型。</li>
<li>Accept-Encoding：客户端能够解码的内容编码。</li>
<li>Authorization：用于认证的凭证信息，比如token数据。</li>
<li>Content-Length：请求体的长度。</li>
<li>Content-Type：请求体的媒体类型。</li>
<li>Cookie：存储在客户端的cookie数据。</li>
<li>If-None-Match：资源的ETag值，用于缓存控制。</li>
<li>Connection：管理连接的选项，如 keep-alive。</li>
</ul>
<p>空行是请求头部和请求主体之间的空行，用于分隔请求头部和请求主体。而请求体通常用于 POST 和 PUT 请求，包含发送给服务器的数据。</p>
<p>（2) 响应报文</p>
<p>HTTP响应报文是服务器向客户端返回的数据格式，用于传达服务器对客户端请求的处理结果以及相关的数据。一个标准的HTTP响应报文通常包含状态行、响应头、空行、响应体。</p>
<p>状态行包含HTTP版本、状态码和状态消息。例如：<code>HTTP/1.1 200 OK</code></p>
<p>响应头部也是以键值对的形式提供的额外信息，类似于请求头部，用于告知客户端有关响应的详细信息。一些常见的响应头部字段包括：</p>
<ul>
<li>Content-Type：指定响应主体的媒体类型。</li>
<li>Content-Length：指定响应主体的长度（字节数）。</li>
<li>Server：指定服务器的信息。</li>
<li><strong>Expires</strong>: 响应的过期时间，之后内容被认为是过时的。</li>
<li><strong>ETag</strong>: 响应体的实体标签，用于缓存和条件请求。</li>
<li><strong>Last-Modified</strong>： 资源最后被修改的日期和时间。</li>
<li>Location：在重定向时指定新的资源位置。</li>
<li>Set-Cookie：在响应中设置Cookie。</li>
<li>Access-Control-Allow-Origin: 跨源资源共享（CORS）策略，指示哪些域可以访问资源。</li>
</ul>
<p>空行（Empty Line）在响应头和响应体之间，表示响应头的结束。而响应体是服务端实际传输的数据，可以是文本、HTML页面、图片、视频等，也可能为空。</p>
<h3 id="4-HTTP有哪些请求方式？"><a href="#4-HTTP有哪些请求方式？" class="headerlink" title="4. HTTP有哪些请求方式？"></a>4. HTTP有哪些请求方式？</h3><ul>
<li><p><strong>方法定义</strong>: 能够清晰地定义每个请求方法的基本用途，知道哪些方法可能会改变服务器状态，哪些不会，并能够根据场景选择合适的HTTP方法。</p>
</li>
<li><p><strong>安全性</strong>: 了解每种方法在安全性方面的考虑，特别是GET和POST方法的区别。</p>
</li>
<li><p><strong>幂等性</strong>: 理解幂等性的概念，并能识别哪些HTTP方法是幂等的（如GET、PUT、DELETE）。</p>
</li>
<li><p>GET：<code>GET</code> 方法请求一个指定资源的表示形式，使用 <code>GET</code> 的请求应该只被用于获取数据。</p>
</li>
<li><p>HEAD：<code>HEAD</code> 方法请求一个与 <code>GET</code> 请求的响应相同的响应，但没有响应体。</p>
</li>
<li><p>POST：<code>POST</code> 方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用。1）可以创建新的资源或提交数据到服务器进行处理。2）客户端可以只发送部分资源内容。3）如果请求成功，服务器会返回一个表示新资源的 URI。4）POST 请求不具有幂等性。</p>
</li>
<li><p>PUT：<code>PUT</code> 方法用有效载荷请求替换目标资源的所有当前表示。1）可以更新整个资源。2）客户端需要发送完整的资源内容。3）如果服务器上不存在该资源，则会创建一个新的资源。4）PUT 请求具有幂等性，即执行多次 PUT 请求的结果应该相同。</p>
</li>
<li><p>DELETE：<code>DELETE</code> 方法删除指定的资源。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/CONNECT"><code>CONNECT</code></a>:<code>CONNECT</code> 方法建立一个到由目标资源标识的服务器的隧道。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS"><code>OPTIONS</code></a>:<code>OPTIONS</code> 方法用于描述目标资源的通信选项。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/TRACE"><code>TRACE</code></a>:<code>TRACE</code> 方法沿着到目标资源的路径执行一个消息环回测试。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/PATCH"><code>PATCH</code></a>:<code>PATCH</code> 方法用于对资源应用部分修改。</p>
</li>
</ul>
<h3 id="5-GET请求和POST请求的区别"><a href="#5-GET请求和POST请求的区别" class="headerlink" title="5. GET请求和POST请求的区别"></a>5. GET请求和POST请求的区别</h3><ul>
<li>GET语义是从服务器获取指定的资源，请求参数一般写在url中，字符限制为ASCII。get在只进行请求指定资源时是安全的、幂等的、可被缓存的。浏览器中的GET请求可以被保存为书签。</li>
<li>POST是根据请求报文body对指定资源做出处理。会修改服务器上的资源，所以是不安全的，多次提交就会创建多个资源，所以不是幂等的。</li>
</ul>
<h3 id="6-HTTP中常见的状态码有哪些"><a href="#6-HTTP中常见的状态码有哪些" class="headerlink" title="6. HTTP中常见的状态码有哪些"></a>6. HTTP中常见的状态码有哪些</h3><p>1XX：协议处理的中间状态</p>
<p>2XX：成功报文已被正确处理</p>
<ul>
<li>200 OK：标识一切正常，如果不是HEAD请求，会返回body数据</li>
<li>204 NO Content：响应头没有body数据</li>
<li>206 Partial Content：应用于 HTTP 分块下载或断点续传</li>
</ul>
<p>3XX：资源重定向</p>
<ul>
<li>301 永久重定向</li>
<li>302 临时重定向</li>
<li>304 缓存重定向</li>
</ul>
<p>4XX：报文有误</p>
<ul>
<li>400 Bad Request 笼统错误</li>
<li>403 Forbidden 服务器禁止访问资源</li>
<li>404 Not Found 资源不存在</li>
</ul>
<p>5XX：服务器内部错误</p>
<ul>
<li>500 笼统错误</li>
<li>501 功能未支持</li>
<li>502 网关错误</li>
<li>503 Service Unavailable</li>
</ul>
<h3 id="7-什么是强缓存和协商缓存"><a href="#7-什么是强缓存和协商缓存" class="headerlink" title="7. 什么是强缓存和协商缓存"></a>7. 什么是强缓存和协商缓存</h3><p><img src="C:\Users\MasterLi\Documents\GitHub\hexo_myblog\source_posts\计算机网络\image-20250223140337972.png" srcset="/img/loading.gif" lazyload alt="image-20250223140337972"></p>
<ul>
<li>强制缓存：强制缓存是浏览器判断能否是由从本地缓存读取，是否使用缓存的主动性在于浏览器这边。<ul>
<li>Cache-Control 和 Expires两个头部字段实现</li>
<li>Cache-Control的优先级高于Expire<ul>
<li>第一次请求服务器资源时，服务器返回资源的同时在响应头部加上Cache-Control，在其中设置过期时间大小，再次访问时根据请求时间与过期时间来计算资源是否过期</li>
<li>再次收到请求时会更新Cache-Control的值</li>
</ul>
</li>
</ul>
</li>
<li>协商缓存：在强制缓存失效时，可以根据响应头中是否含有协商缓存对应的字段来使用协商缓存。通过服务端来告知本地的缓存是否可以使用的方式叫做协商缓存。<ul>
<li>方法一：基于请求头部中的If-Modified-Since和响应头部中的Last-Modified字段实现。基于时间实现。<ul>
<li>响应头中的last-Modified标识响应资源的最后修改时间</li>
<li>请求头中的If-Modified-Since，当强制缓存发现资源过期时发现响应头中具有Last-Modified声明，则再次发起请求的时候带上Last-Modified的时间，服务器收到请求后将If-Modified-since与Last-Modified进行对比，如果修改时间较新，说明资源被修改，返回最新资源Http 200 OK，否则响应Http 304</li>
</ul>
</li>
<li>方法二：基于请求头部中的If-None-Match字段与响应头部中的Etag。基于唯一标识符的方法。<ul>
<li>响应头部中Etag是唯一标识响应资源；</li>
<li>请求头部中的If-None-Match：当资源过期时，浏览器发现响应头有Etag，则再次向服务器发起请求时会将If-None-Match的值设置为Etag的值。服务器收到后进行对比，如果资源变化没有返回304，如果资源变化了返回200</li>
</ul>
</li>
<li>第二种可以更准确的判断文件内容是否被修改，避免由于时间篡改的不可靠问题</li>
<li>Etag优先级高于LastModified<ul>
<li>最后修改时间可能会出现变化</li>
<li>文件是秒级以内修改的</li>
<li>服务器不能精确获得最后修改时间。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8-HTTP"><a href="#8-HTTP" class="headerlink" title="8. HTTP"></a>8. HTTP</h3><p>HTTP1.0 和 HTTP1.1的区别</p>
<ol>
<li><strong>持久连接</strong>：<code>HTTP/1.1</code> 默认支持持久连接，允许在一个TCP连接上发送多个HTTP请求和响应，减少了连接建立和关闭的开销。而<code>HTTP/1.0</code> 默认为短连接，每次请求都需要建立一个TCP连接，并通过<code>Connection: keep-alive</code>头来实现持久连接。</li>
<li><strong>管道化</strong>：<code>HTTP/1.1</code> 支持管道化(不是默认开启)，允许客户端在第一个请求的响应到达之前发送多个请求，这可以减少等待时间，提高效率。HTTP&#x2F;1.0不支持管道化。</li>
<li><strong>缓存控制</strong>：<code>HTTP1.0</code>主要使用<code>If-Modified-Since/Expires</code>来做为缓存判断的标准，而<code>HTTP1.1</code>则引入了更多的缓存控制策略例如<code>Etag / If-None-Match</code>等更多可供选择的缓存头来控制缓存策略。</li>
<li>错误处理：<code>HTTP/1.1</code> 增加了一些新的HTTP状态码，如<code>100 Continue</code>，用于增强错误处理和请求的中间响应。</li>
<li><code>Host</code> 头：<code>HTTP/1.1</code> 引入了<code>Host</code>头，允许客户端指定请求的主机名，这使得在同一台服务器上托管多个域名成为可能。HTTP&#x2F;1.0没有这个头字段。</li>
<li>带宽优化 ：<code>HTTP1.0</code>中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能， 而<code>HTTP1.1</code>则在请求头引入了<code>range</code>头域，它允许只请求资源的某个部分，即返回码是<code>206（Partial Content）</code></li>
</ol>
<h4 id="8-1-HTTP-1-1"><a href="#8-1-HTTP-1-1" class="headerlink" title="8.1 HTTP&#x2F;1.1"></a>8.1 HTTP&#x2F;1.1</h4><p>优点：</p>
<ul>
<li>简单</li>
<li>灵活和易于扩展</li>
<li>应用广泛 跨平台</li>
</ul>
<p>缺点：</p>
<ul>
<li>无状态<ul>
<li>好处：不需要额外资源来记录状态信息，还能减轻服务器负担，把更多的CPU和内存用来提供服务。</li>
<li>坏处：没有记忆能力，在有关联性操作的时候会非常麻烦。解决无状态的问题最简单的就是Cookie技术。在请求和响应报文中写入Cookie信息来控制客户端的状态。</li>
</ul>
</li>
<li>明文传输<ul>
<li>信息裸奔，不安全，可以使用HTTPS的方式解决</li>
</ul>
</li>
</ul>
<p>性能：基于TCP&#x2F;IP并且使用了请求-应答，性能问题主要在这两点中</p>
<ul>
<li>长连接：HTTP&#x2F;1.0中的问题，就是每发起一个请求，都要新建一次TCP链接，通信开销较大。只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</li>
<li>管道传输网络：使用长连接使得管道成为了可能。在同一个TCP链接里用户可以发起多个请求，只要第一个请求发出，可以直接发出第二个请求，可以减少整体的响应时间。管道解决了请求的队头堵塞，没有解决响应的队头堵塞。</li>
<li>队头阻塞：当顺序发送的请求队列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也被一并阻塞</li>
</ul>
<h4 id="8-2-HTTP-2-0"><a href="#8-2-HTTP-2-0" class="headerlink" title="8.2 HTTP&#x2F;2.0"></a>8.2 HTTP&#x2F;2.0</h4><ul>
<li>HTTP&#x2F;2协议是基于HTTPs的所以安全。</li>
<li>头部压缩<ul>
<li>如果发出多个头部相同的请求，协议会帮你消除重复的部分</li>
<li><code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，只发送索引号，这样可以提高速度。</li>
</ul>
</li>
<li>二进制格式<ul>
<li>不再是纯文本报文，全面采用二进制格式，将原有报文分为头信息帧和数据帧。增加数据传输效率</li>
</ul>
</li>
<li>并发传输<ul>
<li>多条Stream复用在一条TCP链接。不同HTTP请求使用独一无二的Stream ID来区分，接收端可以通过Stream ID有序组装成HTTP消息，不同stream的帧可以乱序发送。</li>
</ul>
</li>
<li>服务器主动推源<ul>
<li>双方都可以建立Stream，客户端奇数号，服务端偶数号</li>
</ul>
</li>
</ul>
<p>HTTP2.0 的问题主要出现在TCP中，如果TCP出现丢包需要重传时，所有Stream必须等重传后应用层才能继续</p>
<h4 id="8-3-HTTP-3-0"><a href="#8-3-HTTP-3-0" class="headerlink" title="8.3 HTTP&#x2F;3.0"></a>8.3 HTTP&#x2F;3.0</h4><p>将下层协议改为UDP，基于UDP的QUIC协议可以实现TCP的可靠性传输。</p>
<ul>
<li>无队头阻塞：也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。多个Stream独立。</li>
<li>更快的链接建立<ul>
<li>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl实现的表示层，难以合并在一起。</li>
<li>HTTP3 再数据传输前需要QUIC协议握手，但是只需要1RTT，QUIC协议包括TLS&#x2F;1.3协议</li>
<li>并且可以实现对话恢复时0-RTT的效果。</li>
<li><img src="C:\Users\MasterLi\Documents\GitHub\hexo_myblog\source_posts\计算机网络\image-20250223214005765.png" srcset="/img/loading.gif" lazyload alt="image-20250223214005765"></li>
</ul>
</li>
<li>连接迁移<ul>
<li>当移动设备的网络从4G切换到WIFI时，意味着IP地址变化了，必须要断开链接再重新链接。包括TCP的三次握手和TLS的四次握手以及TCP的慢启动。</li>
<li>QUIC协议通过连接ID标记通信两端，客户端和服务器可以各自选择一组ID来标记自己，即使IP地址变化，只要有上下文信息，就可以无缝复用原链接，达到了连接迁移的功能。</li>
</ul>
</li>
</ul>
<h4 id="8-4-HTTP和HTTPs的区别"><a href="#8-4-HTTP和HTTPs的区别" class="headerlink" title="8.4 HTTP和HTTPs的区别"></a>8.4 HTTP和HTTPs的区别</h4><p>两者的主要区别在于安全性和数据加密：</p>
<ol>
<li><strong>加密层</strong>：<code>HTTPS</code> 在<code>HTTP</code> 的基础上增加了<code>SSL/TLS</code> 协议作为加密层，确保数据传输的安全性。而<code>HTTP</code> 数据传输是明文的，容易受到攻击。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>
<li><strong>端口</strong>：<code>HTTPS</code> 通常使用端口<code>443</code> ，而<code>HTTP</code> 使用端口80。</li>
<li>HTTPS 协议需要向 CA 申请数字证书，来保证服务器的身份是可信的。</li>
</ol>
<h4 id="8-5-HTTPs的工作原理"><a href="#8-5-HTTPs的工作原理" class="headerlink" title="8.5 HTTPs的工作原理"></a>8.5 HTTPs的工作原理</h4><p><code>HTTPS</code> 主要基于<code>SSL/TLS</code> 协议，确保了数据传输的安全性和完整性, 其建立连接并传输数据的过程如下：</p>
<ol>
<li><strong>密钥交换</strong>：客户端发起HTTPS请求，客户端随机数，协议版本，加密，服务器会发送其公钥证书给客户端。</li>
<li><strong>证书验证</strong>：客户端会验证服务器的证书是否由受信任的证书颁发机构（<code>CA</code> ）签发，并检查证书的有效性。</li>
<li><strong>加密通信</strong>：一旦证书验证通过，客户端会生成一个随机的对称加密密钥，并使用服务器的公钥加密这个密钥，然后发送给服务器。</li>
<li><strong>建立安全连接</strong>：服务器使用自己的私钥解密得到对称加密密钥，此时客户端和服务器都有了相同的密钥，可以进行加密和解密操作。</li>
<li><strong>数据传输</strong>：使用对称加密密钥对所有传输的数据进行加密，确保数据在传输过程中的安全性。</li>
<li><strong>完整性校验</strong>：SSL&#x2F;TLS协议还包括消息完整性校验机制，如消息认证码，确保数据在传输过程中未被篡改。</li>
<li><strong>结束连接</strong>：数据传输完成后，通信双方会进行会话密钥的销毁，以确保不会留下安全隐患。</li>
</ol>
<h3 id="9-TCP"><a href="#9-TCP" class="headerlink" title="9 TCP"></a>9 TCP</h3><h4 id="9-1-TCP连接如何确保可靠性"><a href="#9-1-TCP连接如何确保可靠性" class="headerlink" title="9.1 TCP连接如何确保可靠性"></a>9.1 TCP连接如何确保可靠性</h4><p>TCP连接主要通过TCP头部的字段以及超时重传、流量控制、拥塞控制方法确保传输的可靠性。</p>
<ul>
<li>首先每个TCP段都有一个序列号seq，确保数据包的顺序正确。还有确认应答号ack用于解决丢包问题</li>
<li>TCP首部中含有校验和字段，通过校验和可以进行数据校验，如果检测到错误，接收方会丢弃该数据包。</li>
<li>使用滑动窗口机制进行流量控制，确保接收方能够处理发送方的数据量</li>
<li>使用超时重传、快速重传、SACK、D-SACK等方式解决数据包丢失问题</li>
<li>TCP使用滑动窗口机制进行流量控制，确保接收方可以处理发送方的数据</li>
<li>TCP通过慢启动、拥塞避免、快重传和快恢复来控制数据的发送速率，防止网络拥塞。</li>
</ul>
<h4 id="9-2-拥塞控制是怎么实现的嘛"><a href="#9-2-拥塞控制是怎么实现的嘛" class="headerlink" title="9.2 拥塞控制是怎么实现的嘛"></a>9.2 拥塞控制是怎么实现的嘛</h4><p>TCP拥塞控制可以在网络出现拥塞时动态地调整数据传输的速率，以防止网络过载。TCP拥塞控制的主要机制包括以下几个方面：</p>
<ol>
<li><strong>慢启动（Slow Start）：</strong>发送方每收到一个ACK，拥塞窗口的大小就会加1。 初始阶段，TCP发送方会以较小的发送窗口开始传输数据。随着每次成功收到确认的数据，发送方逐渐增加发送窗口的大小，实现指数级的增长，这称为慢启动。这有助于在网络刚开始传输时谨慎地逐步增加速率，以避免引发拥塞。</li>
<li><strong>拥塞避免（Congestion Avoidance）：</strong> 一旦达到一定的阈值（通常是慢启动阈值ssthresh），TCP发送方就会进入拥塞避免阶段。在拥塞避免阶段，发送方以线性增加的方式增加发送窗口的大小，而不再是指数级的增长。这有助于控制发送速率，以避免引起网络拥塞。</li>
<li><strong>快速重传（Fast Retransmit）：</strong> 如果发送方连续收到相同的确认，它会认为发生了数据包的丢失，并会快速重传未确认的数据包，而不必等待超时。这有助于更快地恢复由于拥塞引起的数据包丢失。<ul>
<li>超时重传算法：ssthresh &#x3D; cwnd&#x2F;2 cwnd &#x3D; 初始值。</li>
<li>快速重传算法：当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速的重传。 cwnd &#x3D; cwnd&#x2F;2 ssthresh &#x3D; cwnd，之后进入快速恢复算法。</li>
</ul>
</li>
<li><strong>快速恢复（Fast Recovery）：</strong> 在发生快速重传后，TCP进入快速恢复阶段。在这个阶段，发送方不会回到慢启动阶段，而是将慢启动阈值设置为当前窗口的一半，并将拥塞窗口大小设置为慢启动阈值加上已确认但未被快速重传的数据块的数量。这有助于更快地从拥塞中恢复。</li>
</ol>
<img src="C:\Users\MasterLi\Documents\GitHub\hexo_myblog\source\_posts\计算机网络\image-20250302214202082.png" srcset="/img/loading.gif" lazyload alt="image-20250302214202082" style="zoom:50%;" />

<h4 id="9-3-流量控制怎么实现"><a href="#9-3-流量控制怎么实现" class="headerlink" title="9.3 流量控制怎么实现"></a>9.3 流量控制怎么实现</h4><p><strong>流量控制</strong>就是让发送方发送速率不要过快，让接收方来得及接收。利用<strong>滑动窗口机制</strong>就可以实施流量控制，主要方法就是动态调整发送方和接收方之间数据传输速率。</p>
<ul>
<li><strong>滑动窗口大小：</strong> 在TCP通信中，每个TCP报文段都包含一个窗口字段，该字段指示发送方可以发送多少字节的数据而不等待确认。这个窗口大小是动态调整的。</li>
<li><strong>接收方窗口大小：</strong> 接收方通过TCP报文中的窗口字段告诉发送方自己当前的可接收窗口大小。这是接收方缓冲区中还有多少可用空间。</li>
<li><strong>流量控制的目标：</strong> 流量控制的目标是确保发送方不要发送超过接收方缓冲区容量的数据。如果接收方的缓冲区快满了，它会减小窗口大小，通知发送方暂停发送，以防止溢出。</li>
<li><strong>动态调整：</strong> 发送方会根据接收方的窗口大小动态调整发送数据的速率。如果接收方的窗口大小增加，发送方可以加速发送数据。如果窗口大小减小，发送方将减缓发送数据的速率。</li>
<li><strong>确认机制：</strong> 接收方会定期发送确认（ACK）报文，告知发送方已成功接收数据。这也与流量控制密切相关，因为接收方可以通过ACK报文中的窗口字段来通知发送方它的当前窗口大小。</li>
<li>当接收窗口为0时，启动计时器，如果计时器超时，发送方发送窗口探帧报文，可以打破死锁局面。</li>
</ul>
<h4 id="9-4-UDP怎么实现可靠传输"><a href="#9-4-UDP怎么实现可靠传输" class="headerlink" title="9.4 UDP怎么实现可靠传输"></a>9.4 UDP怎么实现可靠传输</h4><p>UDP它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。传输层无法保证数据的可靠传输，只能通过<strong>应用层</strong>来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。关键在于两点，从应用层角度考虑：</p>
<p>（1）提供超时重传，能避免数据报丢失。</p>
<p>（2）提供确认序列号，可以对数据报进行确认和排序。</p>
<p><strong>本端</strong>：首先在UDP数据报定义一个首部，首部包含确认序列号和时间戳，时间戳是用来计算RTT(数据报传输的往返时间)，计算出合适的RTO(重传的超时时间)。然后以等-停的方式发送数据报，即收到对端的确认之后才发送下一个的数据报。当时间超时，本端重传数据报，同时RTO扩大为原来的两倍，重新开始计时。</p>
<p><strong>对端</strong>：接受到一个数据报之后取下该数据报首部的时间戳和确认序列号，并添加本端的确认数据报首部之后发送给本端。根据此序列号对已收到的数据报进行排序并丢弃重复的数据报。</p>
<h4 id="9-5-TCP为什么是三次握手，可以是两次或者更多吗"><a href="#9-5-TCP为什么是三次握手，可以是两次或者更多吗" class="headerlink" title="9.5 TCP为什么是三次握手，可以是两次或者更多吗"></a>9.5 TCP为什么是三次握手，可以是两次或者更多吗</h4><p>(1) 三次握手的过程</p>
<ol>
<li><strong>第一次握手</strong>：客户端向服务器发送一个<code>SYN</code> （同步序列编号）报文，请求建立连接，客户端进入<code>SYN_SENT</code> 状态。</li>
<li><strong>第二次握手</strong>：服务器收到<code>SYN</code> 报文后，如果同意建立连接，则会发送一个<code>SYN-ACK</code> （同步确认）报文作为响应，同时进入<code>SYN_RCVD</code> 状态。</li>
<li><strong>第三次握手</strong>：客户端收到服务器的<code>SYN-ACK</code> 报文后，会发送一个<code>ACK</code> （确认）报文作为最终响应，之后客户端和服务器都进入<code>ESTABLISHED</code> 状态，连接建立成功。</li>
</ol>
<p>通过三次握手，客户端和服务器都能够确认对方的接收和发送能力。第一次握手确认了客户端到服务器的通道是开放的；第二次握手确认了服务器到客户端的通道是开放的；第三次握手则确认了客户端接收到服务器的确认，从而确保了双方的通道都是可用的。</p>
<p>而如果仅使用两次握手，服务器可能无法确定客户端的接收能力是否正常，比如客户端可能已经关闭了连接，但之前发送的连接请求报文在网络上延迟到达了服务器，服务器就会主动去建立一个连接，但是客户端接收不到，导致资源的浪费。三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。而四次握手可以优化为三次。</p>
<ul>
<li><p>三次握手可以阻止重复历史链接的初始化：在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接造成资源浪费。</p>
</li>
<li><p>三次握手可以同步双方初始序列号：两次握手只能保证一方的初始序列号被对方成功接收</p>
</li>
<li><p>三次握手可以避免浪费资源：</p>
<ul>
<li>只有两次握手的情况下服务端每收到一个SYN就建立一个连接，如果多个SYN重复发送，收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。</li>
</ul>
</li>
</ul>
<h4 id="9-6-TCP为什么是四次挥手"><a href="#9-6-TCP为什么是四次挥手" class="headerlink" title="9.6 TCP为什么是四次挥手"></a>9.6 TCP为什么是四次挥手</h4><p>客户端：FIN_WAIT1 FIN_WAIT2 TIME_WAIT CLOSE</p>
<p>服务端：CLOSE_WAIT LAST_ACK CLOSE</p>
<ul>
<li>服务端需要等待数据的发送和处理，所以ACK和FIN会分开发送。</li>
</ul>
<p>（1）四次挥手的过程</p>
<ol>
<li>第一次挥手：客户端发送一个<code>FIN</code>报文给服务端，表示自己要断开数据传送，报文中会指定一个序列号 <code>(seq=x)</code>。然后,客户端进入<code>FIN-WAIT-1 </code>状态。</li>
<li>第二次挥手：服务端收到<code>FIN</code>报文后，回复<code>ACK</code>报文给客户端，且把客户端的序列号值<code>+1</code>，作为ACK报文的序列号<code>(seq=x+1)</code>。然后，服务端进入<code>CLOSE-WAIT(seq=x+1)</code>状态，客户端进入<code>FIN-WAIT-2</code>状态。</li>
<li>第三次挥手：服务端也要断开连接时，发送<code>FIN</code>报文给客户端，且指定一个序列号<code>(seq=y+1)</code>，随后服务端进入<code>LAST-ACK</code>状态。</li>
<li>第四次挥手：客户端收到<code>FIN</code>报文后，发出<code>ACK</code>报文进行应答，并把服务端的序列号值<code>+1</code>作为<code>ACK</code>报文序列号<code>(seq=y+2)</code>。此时客户端进入<code>TIME-WAIT</code>状态。服务端在收到客户端的<code>ACK </code>报文后进入<code>CLOSE</code> 状态。如果客户端等待<code>2MSL</code>没有收到回复，才关闭连接。</li>
</ol>
<p>（2）为什么需要四次挥手</p>
<p><code>TCP</code>是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。 当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后才会完全关闭<code> TCP</code> 连接。因此两次挥手可以释放一端到另一端的<code>TCP</code>连接，完全释放连接一共需要四次挥手。</p>
<p>只有通过四次挥手，才可以确保双方都能接收到对方的最后一个数据段的确认，主动关闭方在发送完最后一个<code>ACK</code>后进入<code>TIME-WAIT</code> 状态，这是为了确保被动关闭方接收到最终的<code>ACK</code> ，如果被动关闭方没有接收到，它可以重发<code>FIN</code> 报文，主动关闭方可以再次发送<code>ACK</code> 。</p>
<p>而如果使用三次挥手，被动关闭方可能在发送最后一个数据段后立即关闭连接，而主动关闭方可能还没有接收到这个数据段的确认</p>
<h4 id="9-7-HTTP和TCP的Keep-Alive是一个东西吗"><a href="#9-7-HTTP和TCP的Keep-Alive是一个东西吗" class="headerlink" title="9.7 HTTP和TCP的Keep-Alive是一个东西吗"></a>9.7 HTTP和TCP的Keep-Alive是一个东西吗</h4><ul>
<li>HTTP的Keep-Alive是由应用层（用户态）实现，HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</li>
<li>TCP的Keep-Alive是TCP的保活机制，如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件：<ul>
<li>如果对端程序正常工作。TCP的保活探测报文发送给对端对端正常响应，这样TCP的保活时间会重置，等待下一个TCP保活时间到来。</li>
<li>否则TCP会报告连接死亡。</li>
</ul>
</li>
</ul>
<ol>
<li><code>HTTP</code> 的 <code>Keep-Alive</code>，是由应用层实现的，称为 HTTP 长连接</li>
</ol>
<p>每次请求都要经历这样的过程：建立 <code>TCP</code>连接 -&gt; <code>HTTP</code>请求资源 -&gt; 响应资源 -&gt; 释放连接，这就是HTTP短连接，但是这样每次建立连接都只能请求一次资源，所以<code>HTTP </code>的 <code>Keep-Alive</code>实现了使用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销，就就是 <strong>HTTP 长连接</strong>。通过设置HTTP头<code>Connection: keep-alive</code>来实现。</p>
<ol>
<li><code>TCP</code> 的 <code>Keepalive</code>，是由<code>TCP </code>层（内核态）实现的，称为 <code>TCP </code>保活机制，是一种用于在 <code>TCP </code>连接上检测空闲连接状态的机制</li>
</ol>
<p>当<code>TCP</code>连接建立后，如果一段时间内没有任何数据传输，<code>TCP Keepalive</code>会发送探测包来检查连接是否仍然有效。</p>
<p>补充说明：</p>
<p>其实这里tcp的keepalive，不只是支持http，还可以支持ftp和smtp的，他是一个能力，类似于gc。</p>
<p>http的这个keepalive感觉更是一种策略吧，比如你有一个http用了keepalive，然后过了一会，你不传输数据了，这个时候没有通知对方close，这个时候tcp的keepalive就会起到用处去关闭这次链接。</p>
<h4 id="9-8-DNS查询过程"><a href="#9-8-DNS查询过程" class="headerlink" title="9.8 DNS查询过程"></a>9.8 DNS查询过程</h4><img src="C:\Users\MasterLi\Documents\GitHub\hexo_myblog\source\_posts\计算机网络\image-20250302233703435.png" srcset="/img/loading.gif" lazyload alt="image-20250302233703435" style="zoom:50%;" />

<img src="C:\Users\MasterLi\Documents\GitHub\hexo_myblog\source\_posts\计算机网络\image-20250302233740538.png" srcset="/img/loading.gif" lazyload alt="image-20250302233740538" style="zoom:50%;" />



<h4 id="9-9-CDN是什么，有什么作用"><a href="#9-9-CDN是什么，有什么作用" class="headerlink" title="9.9 CDN是什么，有什么作用"></a>9.9 CDN是什么，有什么作用</h4><ul>
<li>内容分发网络（CDN）是一个互连服务器网络，可加快数据密集型应用程序的网页加载速度。CDN 可以表示内容分发网络或内容分配网络。当用户访问某个网站时，来自该网站服务器的数据必须通过互联网传输到用户的计算机。如果用户距离该服务器较远，则加载大文件（例如视频或网站图像）将需要很长时间。相反，如果网站内容存储在距离用户较近的 CDN 服务器上，就可以更快到达他们的计算机。<ul>
<li><strong>就近访问</strong>：CDN 在全球范围内部署了多个服务器节点，用户的请求会被路由到距离最近的 CDN 节点，提供快速的内容访问。</li>
<li><strong>内容缓存</strong>：CDN 节点会缓存静态资源，如图片、样式表、脚本等。当用户请求访问这些资源时，CDN 会首先检查是否已经缓存了该资源。如果有缓存，CDN 节点会直接返回缓存的资源，如果没有缓存所需资源，它会从源服务器（原始服务器）回源获取资源，并将资源缓存到节点中，以便以后的请求。通过缓存内容，减少了对原始服务器的请求，减轻了源站的负载。</li>
<li>可用性：即使某些节点出现问题，用户请求可以被重定向到其他健康的节点。</li>
</ul>
</li>
</ul>
<h4 id="9-10-Cookie和Session"><a href="#9-10-Cookie和Session" class="headerlink" title="9.10 Cookie和Session"></a>9.10 Cookie和Session</h4><p>(1) Cookie和Session是什么？</p>
<p><code>Cookie </code>和 <code>Session </code>都用于管理用户的状态和身份, <code>Cookie</code>通过在客户端记录信息确定用户身份，<code>Session</code>通过在服务器端记录信息确定用户身份。</p>
<ol>
<li>Cookie</li>
</ol>
<ul>
<li>通常，服务器会将一个或多个<code> Cookie</code> 发送到用户浏览器，然后浏览器将这些 <code>Cookie</code> 存储在本地。</li>
<li>服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的<code>Cookie</code>得到客户端特有的信息，从而动态生成与该客户端相对应的内容。</li>
</ul>
<ol>
<li>Session</li>
</ol>
<p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是<code>Session</code>。Session 主要用于维护用户登录状态、存储用户的临时数据和上下文信息等。服务器为每个用户分配一个唯一的<code>Session ID</code>，通常存储在<code>Cookie</code>中。</p>
<p>（2） Cookie和Session的区别？</p>
<ul>
<li>存储位置：<code>Cookie</code> 数据存储在用户的浏览器中，而 <code>Session</code> 数据存储在服务器上。</li>
<li>数据容量：<code>Cookie</code> 存储容量较小，一般为几 KB。<code>Session</code> 存储容量较大，通常没有固定限制，取决于服务器的配置和资源。</li>
<li>安全性：由于 <code>Cookie</code> 存储在用户浏览器中，因此可以被用户读取和篡改。相比之下，Session 数据存储在服务器上，更难被用户访问和修改。</li>
<li>生命周期：<code>Cookie</code>可以设置过期时间，<code>Session</code> 依赖于会话的持续时间或用户活动。</li>
<li>传输方式：<code>Cookie</code> 在每次 <code>HTTP</code> 请求中都会被自动发送到服务器，而 <code>Session ID</code> 通常通过<code> Cookie</code> 或 URL 参数传递。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%AE%9E%E4%B9%A0/" class="print-no-link">#实习</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>计算机网络</div>
      <div>https://jiajun-lab.github.io/2025/02/19/计算机网络/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lee</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年2月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/09/16/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/" title="">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/01/24/%E5%90%8E%E7%AB%AF%E9%9D%A2%E7%BB%8F/" title="后端面经">
                        <span class="hidden-mobile">后端面经</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"tUYpg6nx1J5VCJamrfWcKQkl-gzGzoHsz","appKey":"HM1AWutkOYJ9mXYNjwqc7gSy","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
